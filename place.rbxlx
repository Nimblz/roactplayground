<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX542362E2AA274252B9D6FAA973557D9C">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AutoJointsMode">0</token>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">RBXC4CC51F9FA8F4009AA5943FDBD74C395</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">false</bool>
			<float name="Gravity">150</float>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TemporaryLegacyPhysicsSolverOverrideStreaming">false</bool>
			<bool name="TerrainWeldsFixed">true</bool>
		</Properties>
		<Item class="Camera" referent="RBXC4CC51F9FA8F4009AA5943FDBD74C395">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>1.63285387</X>
					<Y>31.3030548</Y>
					<Z>-6.55012798</Z>
					<R00>-0.448547602</R00>
					<R01>-0.344625831</R01>
					<R02>0.824644208</R02>
					<R10>-0</R10>
					<R11>0.922669649</R11>
					<R12>0.385591447</R12>
					<R20>-0.893759012</R20>
					<R21>0.172956124</R21>
					<R22>-0.413861215</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-0.0164347887</X>
					<Y>30.5318718</Y>
					<Z>-5.72240543</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXEF0888A1C010415980EAB2FE8F69D32A">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX439F1C11EF0749AF98C9EA1BB736BFC3">
			<Properties>
				<string name="Name">baseplates</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Model" referent="RBX288DDBC4EBFD43BBBF71529DC7014DDB">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">checkerSegment</string>
					<Ref name="PrimaryPart">RBXC858519E185B4A84B7B9CA8FD0BD1037</Ref>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Part" referent="RBX332A571D632E403BBAAFFAF8454E4669">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-24</X>
							<Y>-2</Y>
							<Z>24</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Baseplate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>48</X>
							<Y>4</Y>
							<Z>48</Z>
						</Vector3>
					</Properties>
					<Item class="Texture" referent="RBX7C6BCCBB7C994EF59A90141568AEE791">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">2</token>
							<string name="Name">Back</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX877304CC47424AF2821BA0617C2A4712">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">4</token>
							<string name="Name">Bottom</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX20D98CE09F2B432F982A4B3CECE7581B">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">5</token>
							<string name="Name">Front</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX398F2E33A53C4D59ADB397544000DB69">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">3</token>
							<string name="Name">Left</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX7C86EC60B8A045D9AE279F8CE353866C">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">0</token>
							<string name="Name">Right</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXE350E20F5FF04C7090BD24B7ED02BE92">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">1</token>
							<string name="Name">Top</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBXD47380FC1D364A8D81F31CDD73E14362">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-24</X>
							<Y>-2</Y>
							<Z>-24</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4289769658</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Baseplate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>48</X>
							<Y>4</Y>
							<Z>48</Z>
						</Vector3>
					</Properties>
					<Item class="Texture" referent="RBXD2E91E646B2C4118A2F7B00E8BE2A7FD">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">2</token>
							<string name="Name">Back</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXE979D610A6E244C9A7DC56695F2F5B07">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">4</token>
							<string name="Name">Bottom</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX64917BFC46D040B4BCB7D15F1A236987">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">5</token>
							<string name="Name">Front</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX8517AB7160DF4678893EB7DA2E850C3A">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">3</token>
							<string name="Name">Left</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX86F595B8A7984CF19EE683BB920D7D02">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">0</token>
							<string name="Name">Right</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX570A7FC101AC49BBACA1BAC35FC78C83">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">1</token>
							<string name="Name">Top</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBXC5B953B8A42244C486D9D0632872D1B6">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>24</X>
							<Y>-2</Y>
							<Z>24</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4289769658</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Baseplate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>48</X>
							<Y>4</Y>
							<Z>48</Z>
						</Vector3>
					</Properties>
					<Item class="Texture" referent="RBX8862F0AACA3C49F69897EFC7E635F0F7">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">2</token>
							<string name="Name">Back</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXA929CFA067DE4F7D91A9943BEF16AD19">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">4</token>
							<string name="Name">Bottom</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXAEE1758B45304D6A844493D0D3E58BC1">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">5</token>
							<string name="Name">Front</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX19DF6EBA596A4F9195E616CA81E96766">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">3</token>
							<string name="Name">Left</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX4813A0AC5704485DBBF027C14CC106FE">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">0</token>
							<string name="Name">Right</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX4E82AF8ADC85496DA20070887B6B9BDC">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">1</token>
							<string name="Name">Top</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBX3021EFB8C9E94D63B44613BD2855CF49">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>24</X>
							<Y>-2</Y>
							<Z>-24</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Baseplate</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>48</X>
							<Y>4</Y>
							<Z>48</Z>
						</Vector3>
					</Properties>
					<Item class="Texture" referent="RBX62A57846916544EBAA473EF522622952">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">2</token>
							<string name="Name">Back</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXF814590123084869A8B7CB5BFBEE4B24">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">4</token>
							<string name="Name">Bottom</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXC8FF591DE3CB4D599897DE09335635F6">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">5</token>
							<string name="Name">Front</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX69149F13ACCC40E4A0F296D1F660D61B">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">3</token>
							<string name="Name">Left</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBX9522518BAD844E30AAAC9D2D699B8E7F">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">0</token>
							<string name="Name">Right</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
					<Item class="Texture" referent="RBXFE37BA8E5FE540B3AA8FEF238465C2FD">
						<Properties>
							<Color3 name="Color3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="Face">1</token>
							<string name="Name">Top</string>
							<float name="OffsetStudsU">0</float>
							<float name="OffsetStudsV">0</float>
							<float name="StudsPerTileU">8</float>
							<float name="StudsPerTileV">8</float>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
							<float name="Transparency">0.899999976</float>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBXC858519E185B4A84B7B9CA8FD0BD1037">
					<Properties>
						<bool name="Anchored">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-2</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">false</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4294928076</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">BoundingBox</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">1</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>96</X>
							<Y>4</Y>
							<Z>96</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="PackageLink" referent="RBXF2C36EA36C4E444DAB1EE0BF23306D69">
					<Properties>
						<bool name="AutoUpdate">true</bool>
						<string name="Name">PackageLink</string>
						<int64 name="OriginalHash">-1415433746134024180</int64>
						<Content name="PackageIdSerialize"><url>rbxassetid://3304640366</url></Content>
						<string name="SymbolicLink"></string>
						<BinaryString name="Tags"></BinaryString>
						<int64 name="VersionIdSerialize">4</int64>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX0BF76905B6A54024B8EF1DB526A640C2">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">TestNPC</string>
				<Ref name="PrimaryPart">RBX171125596A0841AF87FBDE41F83A337E</Ref>
				<BinaryString name="Tags">UmlnUmVuZGVyZXIASW50ZXJhY3RhYmxlAERpYWxvZ09uSW50ZXJhY3Q=</BinaryString>
			</Properties>
			<Item class="Part" referent="RBX171125596A0841AF87FBDE41F83A337E">
				<Properties>
					<bool name="Anchored">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-28</X>
						<Y>4</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4292178749</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">Root</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7209F0EBF4EB41AAA401E6D08E7188F0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ComponentProps</string>
					<string name="ScriptGuid">{DC4FA95B-4FFE-40F3-9683-4535961905E0}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	return {
		RigRenderer = {
			equipped = {
				"piratehat",
				"eyepatch",
				"beard",
			},
			scale = 1,
		},
		Interactable = {
			maxUseDistance = 10,
		},
		Dialogue = {
			id = "testDialog"
		}
	}
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="UnionOperation" referent="RBXAA6CBEA5390C43E8A1DBC39017808E8E">
				<Properties>
					<bool name="Anchored">true</bool>
					<Content name="AssetId"><null></null></Content>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-28</X>
						<Y>3.50695801</Y>
						<Z>-0.0104714632</Z>
						<R00>0</R00>
						<R01>1</R01>
						<R02>0</R02>
						<R10>-1</R10>
						<R11>0</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CastShadow">true</bool>
					<BinaryString name="ChildData">Q1NHSzFhMTA4MGVhYWJiYzA1MDA3MzhmNDNjOWYxNjc1YjYx</BinaryString>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4293040960</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<token name="FormFactor">3</token>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<Vector3 name="InitialSize">
						<X>7.01391602</X>
						<Y>4</Y>
						<Z>4.02968597</Z>
					</Vector3>
					<BinaryString name="LODData"></BinaryString>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<BinaryString name="MeshData">Q1NHS2QyZTgyN2Q2NGYwMTkzMjc3YTkyNTU0ZWRlODY2MDFi</BinaryString>
					<string name="Name">Union</string>
					<SharedString name="PhysicalConfigData">CLRkqnIOEGwqJfkcOaVQeg==</SharedString>
					<BinaryString name="PhysicsData"></BinaryString>
					<float name="Reflectance">0</float>
					<token name="RenderFidelity">1</token>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0.5</float>
					<bool name="UsePartColor">false</bool>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="size">
						<X>7.01391602</X>
						<Y>4</Y>
						<Z>4.02968597</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX41A45427952943168A6DB99C703FC0C1">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>4</Y>
					<Z>31</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4291045404</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">BanMeButton</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags">QmFuT25JbnRlcmFjdABJbnRlcmFjdGFibGU=</BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>2</X>
					<Y>2</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX017CAAE061C7440C8F7A33F479E075FD">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>3</Y>
					<Z>32</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>6</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="Texture" referent="RBXDA4B24EB39A8422AA69520775E3B75FA">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">2</token>
					<string name="Name">Back</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXFFD07B4F30D34A14B5E089F2A41AF76D">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">4</token>
					<string name="Name">Bottom</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXCA993EC2C1CE4765B9DF3A3A2811071B">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">5</token>
					<string name="Name">Front</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXBE68012774D3414FA1160744808360BA">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">3</token>
					<string name="Name">Left</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXC6EFAA5E1D3C41BEAA9A09508723D421">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">0</token>
					<string name="Name">Right</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXB29DF98338AB4BAE80ED2BD33B212978">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">1</token>
					<string name="Name">Top</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX17F02B34C1604CD7AC1E6C01847EBC7F">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>30</X>
					<Y>6</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>12</Y>
					<Z>8</Z>
				</Vector3>
			</Properties>
			<Item class="Texture" referent="RBXB4B16B81055C43809B3EBA01B1F3C2E2">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">2</token>
					<string name="Name">Back</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBX6EDB9903D0E740DA975F3E724987DE17">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">4</token>
					<string name="Name">Bottom</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBX1F63902F29E649F2904FBAB9446F10B2">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">5</token>
					<string name="Name">Front</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBX183332C4D63D4A27856C99689DEBC51E">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">3</token>
					<string name="Name">Left</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBXFD3EB9346E8D4C869283C424DB9E59BB">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">0</token>
					<string name="Name">Right</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
			<Item class="Texture" referent="RBX9001677989B6444F87332939A902A6E8">
				<Properties>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="Face">1</token>
					<string name="Name">Top</string>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://1369654266</url></Content>
					<float name="Transparency">0.899999976</float>
				</Properties>
			</Item>
		</Item>
		<Item class="TrussPart" referent="RBX5AC5ECB19E974A1580F9084AA167FD60">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>30</X>
					<Y>5</Y>
					<Z>-4</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Truss</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2</X>
					<Y>12</Y>
					<Z>2</Z>
				</Vector3>
				<token name="style">0</token>
			</Properties>
		</Item>
		<Item class="Model" referent="RBXA644945B7B0145868C5806E41BD4B523">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Ship</string>
				<Ref name="PrimaryPart">null</Ref>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Part" referent="RBXDC592B1BC30649BD9EFB0A7F709A9596">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-53.5</X>
						<Y>16</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CastShadow">false</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294928076</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">272</token>
					<string name="Name">RootPart</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags">SW50ZXJhY3RhYmxl</BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0.800000012</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>35</X>
						<Y>12</Y>
						<Z>39</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX569C49C7C1874920A50628DF06A4EFB2">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">ViewModel</string>
					<Ref name="PrimaryPart">RBX32AA89116FDB4A4AB6550D8716A45C1A</Ref>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Part" referent="RBXBB73EB4E05D444A48937DB1131AB545E">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-68.5</X>
							<Y>16.5</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Part</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">2</token>
						<Vector3 name="size">
							<X>1</X>
							<Y>2.5</Y>
							<Z>2.5</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX32AA89116FDB4A4AB6550D8716A45C1A">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-64</X>
							<Y>16</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">RootPart</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>8</X>
							<Y>4</Y>
							<Z>5</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="WedgePart" referent="RBXDD280EB6032A4362A9D2240B92F1E43B">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-64</X>
							<Y>13.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Wedge</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>5</X>
							<Y>1</Y>
							<Z>8</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="WedgePart" referent="RBX8E267FE5F33C48B582CBCB64DB2B86B5">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-53.5</X>
							<Y>15.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Wedge</string>
						<float name="Reflectance">0.0500000007</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>5</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX2A7772199F99453A96639CFDA54B06A2">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-57</X>
							<Y>14.5</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Part</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>6</X>
							<Y>3</Y>
							<Z>5</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX03C38B3CA4114931B26BBA16B7D5F25F">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Model</string>
						<Ref name="PrimaryPart">null</Ref>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Part" referent="RBXE4DD8D9DB9EF497BBD5F76BC579FE193">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-67.5</X>
								<Y>14.6545467</Y>
								<Z>-7.16357422</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">2</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX30A42EC4CBB84545BE1C7467ABACCB1F">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-61.5</X>
								<Y>15.1754913</Y>
								<Z>-4.20913696</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>7</X>
								<Y>3</Y>
								<Z>4</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX5CFD0EEE4DEF4E21A270B25767D5E587">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-38</X>
								<Y>15.3491459</Y>
								<Z>-3.22433472</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>1</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX95CB102F1B9945C189511E50DB7ADAE9">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-62.5</X>
								<Y>14.6545467</Y>
								<Z>-7.16357422</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>9</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX94ABCB5FB25F45548505B8CC165D6D2E">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-62.5</X>
								<Y>13.5258369</Y>
								<Z>-13.5648193</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>-0.98480773</R10>
								<R11>0</R11>
								<R12>0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>9</Y>
								<Z>11</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX0A42C436A607429CA6B72918129FA80F">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65.5</X>
								<Y>15.1754913</Y>
								<Z>-4.20913696</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.984807491</R11>
								<R12>0.173648134</R12>
								<R20>0</R20>
								<R21>-0.173648134</R21>
								<R22>0.984807491</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">2</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2.5</Y>
								<Z>2.5</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX123F3100A6D441CD98521AB0D744BBF9">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-37.5</X>
								<Y>15.0018501</Y>
								<Z>-5.19395447</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>-0.98480773</R10>
								<R11>0</R11>
								<R12>0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX296F413FEEF74B6986DC1346C84F280D">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-68.5</X>
								<Y>13.5258369</Y>
								<Z>-13.5648193</Z>
								<R00>0</R00>
								<R01>-1</R01>
								<R02>0</R02>
								<R10>-0.98480773</R10>
								<R11>0</R11>
								<R12>-0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>11</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXBF09D8FFF99E44DBA5884AD42585D97A">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>14.1906776</Y>
								<Z>-4.03549194</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>-0.173648179</R10>
								<R11>-0.98480773</R11>
								<R12>0</R12>
								<R20>-0.98480773</R20>
								<R21>0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>4</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXD545E77C12F945C6BA3C183A54D29029">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>16.1603012</Y>
								<Z>-4.38279724</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>0.173648179</R10>
								<R11>0.98480773</R11>
								<R12>0</R12>
								<R20>0.98480773</R20>
								<R21>-0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>4</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX5DE0D7748707476BAF27C268B8037229">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>15.1754913</Y>
								<Z>-4.20913696</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>19</X>
								<Y>1</Y>
								<Z>4</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX1349AE5821D143CCAFA0DFAB9E4533E6">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-36.5</X>
								<Y>15.3491459</Y>
								<Z>-3.22433472</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>0.98480773</R10>
								<R11>0</R11>
								<R12>-0.173648179</R12>
								<R20>-0.173648179</R20>
								<R21>0</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="WedgePart" referent="RBX651FB7E76FAD4B26BE6F2ACF798C3147">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-55</X>
							<Y>16.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Wedge</string>
						<float name="Reflectance">0.0500000007</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>5</X>
							<Y>1</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="WedgePart" referent="RBX688D6C4A99F3442CA39E24053556ADA8">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-58</X>
							<Y>17.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">272</token>
						<string name="Name">Wedge</string>
						<float name="Reflectance">0.0500000007</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>5</X>
							<Y>1</Y>
							<Z>4</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX49634F83953143179C5B885D8D665484">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-58</X>
							<Y>16.5</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Part</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>4</X>
							<Y>1</Y>
							<Z>5</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Model" referent="RBX978B188828324DA087111DAD54BB7AC0">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Model</string>
						<Ref name="PrimaryPart">null</Ref>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="WedgePart" referent="RBXFED63660C4794599A72059DC432DF397">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>16.4207726</Y>
								<Z>2.90556335</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>-0.173648179</R10>
								<R11>0.98480773</R11>
								<R12>0</R12>
								<R20>0.98480773</R20>
								<R21>0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXA2BAC4EDCB974B84813EA7D78AB070BC">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-61.5</X>
								<Y>15.899826</Y>
								<Z>5.85999298</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>7</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXF23C5D34A5574D5DA6C279E52B9E7613">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-61.5</X>
								<Y>16.4207687</Y>
								<Z>2.90558624</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>7</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX958EFC56D46D43639BB81734890D4E59">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-61.5</X>
								<Y>16.1602974</Y>
								<Z>4.38278961</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>7</X>
								<Y>1</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX5CCBAD52AAD84CFAB0C3EEDD21361CA1">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>16.1603012</Y>
								<Z>4.38278961</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>-0.173648179</R10>
								<R11>0.98480773</R11>
								<R12>0</R12>
								<R20>0.98480773</R20>
								<R21>0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX0E3073B45E484563BB03D0A560AEC14F">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-37.5</X>
								<Y>14.9150238</Y>
								<Z>5.68635559</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>0.98480773</R10>
								<R11>0</R11>
								<R12>0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX0089DB2B286F47E7BF0B8F7FE3C9DE11">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-37.5</X>
								<Y>15.1754951</Y>
								<Z>4.20913696</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>-0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>3</X>
								<Y>1</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX9BD5F609533D447AA542831519E7B264">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-62.5</X>
								<Y>13.5258369</Y>
								<Z>13.5648193</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>0.98480773</R10>
								<R11>0</R11>
								<R12>0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>9</Y>
								<Z>11</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXF7ABC19A8F5A4499B41D2082B8E1DDD0">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-68.5</X>
								<Y>13.5258369</Y>
								<Z>13.5648193</Z>
								<R00>0</R00>
								<R01>-1</R01>
								<R02>0</R02>
								<R10>0.98480773</R10>
								<R11>0</R11>
								<R12>-0.173648179</R12>
								<R20>0.173648179</R20>
								<R21>0</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>11</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX6C81D0709A77427CB26C4F0C657C37F1">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65.5</X>
								<Y>15.1754913</Y>
								<Z>4.20913696</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480767</R11>
								<R12>-0.173648164</R12>
								<R20>0</R20>
								<R21>0.173648164</R21>
								<R22>0.98480767</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">2</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2.5</Y>
								<Z>2.5</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX92E5881646AB4B5D81F473CAD1FE9210">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>15.1754913</Y>
								<Z>4.20914459</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>19</X>
								<Y>1</Y>
								<Z>4</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXC5A9A3FF775A4381978510B5D9AB4441">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>15.899826</Y>
								<Z>5.85999298</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>-0.173648179</R10>
								<R11>0.98480773</R11>
								<R12>0</R12>
								<R20>0.98480773</R20>
								<R21>0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXB9BE0CCA91D54BCF90AB27E27C717CDE">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-48.5</X>
								<Y>14.1906891</Y>
								<Z>4.03549194</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>0.173648179</R10>
								<R11>-0.98480773</R11>
								<R12>0</R12>
								<R20>-0.98480773</R20>
								<R21>-0.173648179</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>4</X>
								<Y>1</Y>
								<Z>19</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXB7950935D4FF4B6AB68B62DB27819E0D">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-38</X>
								<Y>15.4359684</Y>
								<Z>2.73193359</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>-0.98480773</R11>
								<R12>0.173648179</R12>
								<R20>0</R20>
								<R21>-0.173648179</R21>
								<R22>-0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX6B3930144EA1465CBF48D979A61A2D87">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-61.5</X>
								<Y>14.6830883</Y>
								<Z>4.12232208</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>7</X>
								<Y>2</Y>
								<Z>4</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX2BD16B8BD7B44C2180401A5A61D4CB37">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-36.5</X>
								<Y>15.4359684</Y>
								<Z>2.73193359</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>-0.98480773</R10>
								<R11>0</R11>
								<R12>-0.173648179</R12>
								<R20>-0.173648179</R20>
								<R21>0</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX5CA210DA4A0F4B95B2E33600834E1F38">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-67.5</X>
								<Y>14.6545467</Y>
								<Z>7.16356659</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">2</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXCDFEBB8E01B6460A88478B8DE586D5FD">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-62.5</X>
								<Y>14.6545467</Y>
								<Z>7.16356659</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.98480773</R11>
								<R12>-0.173648179</R12>
								<R20>0</R20>
								<R21>0.173648179</R21>
								<R22>0.98480773</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>9</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="Model" referent="RBXBFEA79E83F8E493BA534D1C6A58FCC3C">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Model</string>
						<Ref name="PrimaryPart">null</Ref>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="WedgePart" referent="RBX290BCAACD2494C4BB4A603E756CE85D7">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-69.5</X>
								<Y>19</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>1</R02>
								<R10>0</R10>
								<R11>-1</R11>
								<R12>0</R12>
								<R20>1</R20>
								<R21>0</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>3</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX8004CA745B5549539951017203083596">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-69.5</X>
								<Y>21</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>-0.999999583</R01>
								<R02>-2.98023153e-08</R02>
								<R10>0</R10>
								<R11>2.98023153e-08</R11>
								<R12>-0.999999583</R12>
								<R20>0.999999285</R20>
								<R21>0</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX67DF49A4143C4C95B6E45E93186260FB">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65</X>
								<Y>20.5</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>1</R20>
								<R21>0</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>6</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX0776E38EFD3E4FD194DF38BF17D85FFC">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65</X>
								<Y>18.5</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>6</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="Model" referent="RBX8CF70694FB334B189E72B2F46BF2AF25">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">Model</string>
						<Ref name="PrimaryPart">null</Ref>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="WedgePart" referent="RBX408E7B9D166E48B78E09E28E44F8BE86">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-69.5</X>
								<Y>13</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>1</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>-1</R20>
								<R21>0</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>3</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBX425E7203B4084C0B8AA6755439CE5385">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-69.5</X>
								<Y>11.0000057</Y>
								<Z>-1.52587891e-05</Z>
								<R00>0</R00>
								<R01>-1</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0</R11>
								<R12>1</R12>
								<R20>-1</R20>
								<R21>0</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="WedgePart" referent="RBXCC84B78BFA00444DAA5A342BFA612E7D">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65</X>
								<Y>11.5</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>0</R01>
								<R02>-1</R02>
								<R10>0</R10>
								<R11>-1</R11>
								<R12>-0</R12>
								<R20>-1</R20>
								<R21>0</R21>
								<R22>-0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Wedge</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>3</Y>
								<Z>6</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX3182329D086043C19A68DA2839E26F78">
						<Properties>
							<bool name="Anchored">false</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-65</X>
								<Y>13.4999924</Y>
								<Z>2.28881836e-05</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>-1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288651692</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="Name">Part</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>6</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="WedgePart" referent="RBX835F0FAA4DD943C884E8B9698FAEF278">
					<Properties>
						<bool name="Anchored">false</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-53.5</X>
							<Y>14</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>1</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>1</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Wedge</string>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>5</X>
							<Y>1</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXB849285D4F1C4BFFA1AB9C0C22F762DE">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX295A77118C6A421CAE7EFA26D7F9203C">
		<Properties>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="BinaryStringValue" referent="RBX7AB49625BA434631B4556BED04F2EF7C">
			<Properties>
				<string name="Name">ChildData</string>
				<BinaryString name="Tags"></BinaryString>
				<BinaryString name="Value"><![CDATA[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
b2Jsb3g+]]></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXECF8DBF3FFF043A689AB26A81F4F0FB7">
		<Properties>
			<string name="Name">CSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="BinaryStringValue" referent="RBXFC749060617943CDA13F6D55EC047319">
			<Properties>
				<string name="Name">MeshData</string>
				<BinaryString name="Tags"></BinaryString>
				<BinaryString name="Value"><![CDATA[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
GmCPYR1SWQtPJClrUwQ=]]></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="Chat" referent="RBXE9FB0E70E47E40ACB78CD6ECE8863994">
		<Properties>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXEC97E3407E4A47DF9463FAF4A30E178A">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX78DCE3879B3840AE8DB0D544A32B432A">
		<Properties>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX7362E024DE3D478E99BAB2D33787CCCA">
		<Properties>
			<string name="Name">ReplicatedFirst</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBXCC6AD50C779242ECB17258682BFBE088">
		<Properties>
			<string name="Name">TweenService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="15">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="16">
			<Properties>
				<string name="Name">StarterPlayerScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="LocalScript" referent="17">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClientMain</string>
					<string name="ScriptGuid">{AAA3BDA4-BFAB-4466-A286-E6D0D8F563E0}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local src = script.Parent

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local module = common:WaitForChild("module")

local sidedmodule = src:WaitForChild("module")

local gameCore = PizzaAlpaca.GameCore.new()

gameCore:registerChildrenAsModules(module)
gameCore:registerChildrenAsModules(sidedmodule)

gameCore:load()]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX9EC87D43BEDB454481341A2692F3F73C">
				<Properties>
					<string name="Name">module</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD55C263523C3422C9A203BFD56FA5B53">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GuiContainer</string>
						<string name="ScriptGuid">{470E3115-2B4B-4667-9395-A7374FAB5367}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local src = LocalPlayer:WaitForChild("PlayerScripts")
local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))
local Roact = require(lib:WaitForChild("Roact"))
local RoactRodux = require(lib:WaitForChild("RoactRodux"))

local uiComponents = script:WaitForChild("uiComponents")
local App = require(uiComponents.App)

local GuiContainer = PizzaAlpaca.GameModule:extend("GuiContainer")

local function makeApp(store)
    local storeProvider = Roact.createElement(RoactRodux.StoreProvider, {
        store = store,
    }, {
        app = Roact.createElement(App, {})
    })

    return storeProvider
end

function GuiContainer:preInit()
end

function GuiContainer:init()

    Roact.setGlobalConfig({elementTracing = true})

    self.logger = self.core:getModule("Logger"):createLogger(self)

    local storeContainer = self.core:getModule("StoreContainer")
    storeContainer.storeInitialized:connect(function()
        local store = storeContainer:getStore()
        self.appHandle = Roact.mount(makeApp(store), PlayerGui)
        self.logger:log("UI Mounted")
    end)
end

function GuiContainer:postInit()
end

return GuiContainer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXB93045E4BACD44A886AC5FF19540C355">
						<Properties>
							<string name="Name">uiComponents</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXE1D7A44A75274AA0A9352A149D786610">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">App</string>
								<string name="ScriptGuid">{E6CE1D75-3531-468E-ADED-526D6EFA7065}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local uiComponents = script:FindFirstAncestor("uiComponents")

local Roact = require(lib:WaitForChild("Roact"))

local InteractableTarget = require(uiComponents.InteractableTarget)
local NotificationContainer = require(uiComponents.NotificationContainer)
local Clock = require(uiComponents.Clock)

local App = Roact.Component:extend("App")

function App:init(initialProps)
end

function App:render()
    local children = {}

    children.clock = Roact.createElement(Clock, {
        Position = UDim2.new(1,-32,1,-32),
        AnchorPoint = Vector2.new(1,1),
        Size = UDim2.new(0,64,0,64),
    })

    children.notificationContainer = Roact.createElement(NotificationContainer)

    children.interactableTarget = Roact.createElement(InteractableTarget)

    return Roact.createElement("ScreenGui", {
        Name = "gameGui",
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    }, children)
end

return App]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3B7ED69F8FB04081BF8035CE1467D278">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">AutoSizedTextElement</string>
								<string name="ScriptGuid">{33CE3162-6488-423F-8D0A-B7BECC6DD679}</string>
								<ProtectedString name="Source"><![CDATA[-- heavily borrows concepts and design from
-- https://github.com/LPGhatguy/rojo/blob/master/plugin/src/Components/FitText.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextService = game:GetService("TextService")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local util = common:WaitForChild("util")

local Dictionary = require(util.Dictionary)

local Roact = require(lib:WaitForChild("Roact"))

local AutoSizedTextElement = Roact.Component:extend("AutoSizedTextElement")

local INF_VEC2 = Vector2.new(math.huge, math.huge)

function AutoSizedTextElement:init(initialProps)
    self.textSize, self.updateTextSize = Roact.createBinding(UDim2.new(0,0,0,0))
end

function AutoSizedTextElement:render()
    local type = self.props.type or "TextLabel"

    self.props.Font = self.props.Font or Enum.Font.GothamBlack
    self.props.TextSize = self.props.TextSize or 16

    local joinedProps = Dictionary.join(self.props, {
        type = Dictionary.None,
        Size = self.textSize,

        [Roact.Event.Changed] = function(rbx, prop)
            if prop == "Text" then
                self:updateSizeBinding(rbx.Text or "   ")
            end
        end,
    })

    return Roact.createElement(type, joinedProps)
end

function AutoSizedTextElement:didMount()
    self:updateSizeBinding(self.props.Text)
end

function AutoSizedTextElement:didUpdate()
    self:updateSizeBinding(self.props.Text)
end

function AutoSizedTextElement:updateSizeBinding(text)
    text = text or ""

	local font = self.props.Font or Enum.Font.GothamBlack
	local textSize = self.props.TextSize or 16

	local textDimensions = TextService:GetTextSize(text, textSize, font, INF_VEC2)
	local totalSize = UDim2.new(
		0, textDimensions.X,
		0, textDimensions.Y)

	self.updateTextSize(totalSize)
end

return AutoSizedTextElement]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX57F3A965BD334E159344F00A49B635FE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RichTextMarkupFrame</string>
								<string name="ScriptGuid">{7BAD4B88-9A4C-4C7D-84D8-CAF320D9E0C2}</string>
								<ProtectedString name="Source"><![CDATA[-- break up a string into its words split by whitespace characters
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local util = common:WaitForChild("util")
local uiComponents = script:FindFirstAncestor("uiComponents")

local Dictionary = require(util.Dictionary)
local RichText = require(lib.RichText)

local Roact = require(lib:WaitForChild("Roact"))

local RichTextMarkupFrame = Roact.Component:extend("RichTextMarkupFrame")

function RichTextMarkupFrame:init(initialProps)
    self.frameRef = Roact.createRef()
end

function RichTextMarkupFrame:render()

    local joinedProps = Dictionary.join(self.props, {
        text = Dictionary.None,
        Text = Dictionary.None,
        Font = Dictionary.None,
        TextSize = Dictionary.None,
        TextXAlignment = Dictionary.None,
        TextYAlignment = Dictionary.None,
        ClearTextOnFocus = Dictionary.None,
        [Roact.Children] = Dictionary.None,
    })

    return Roact.createElement("Frame", joinedProps, Dictionary.join(self.props[Roact.Children], {
        textContainer = Roact.createElement("Frame", {
            BackgroundTransparency = 1,
            Size = UDim2.new(1,0,0,self.props.TextSize or 24),
            [Roact.Ref] = self.frameRef,
        })
    }))
end

function RichTextMarkupFrame:didMount()
    local mountedFrame = self.frameRef:getValue()

    if not mountedFrame then return end

    self.state.textObject = RichText:New(
        mountedFrame,
        self.props.text or "",
        {
            Font = self.props.Font or Enum.Font.GothamBlack,
            TextSize = 16
        }
    )

    coroutine.wrap(function()
        wait(0.5)
        self.state.textObject:Animate()
    end)()
end

function RichTextMarkupFrame:willUnmount()
    local textObject = self.state.textObject
    if not textObject then return end

    textObject:Hide()
end


return RichTextMarkupFrame]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX65CFA353C81E4F10A587BC4C0DC4057C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CodeLabLogo</string>
								<string name="ScriptGuid">{5B56A9B1-3C19-4433-B2AC-43C4AC25BC1B}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local Roact = require(lib:WaitForChild("Roact"))
local CodeLabLogo = Roact.Component:extend("CodeLabLogo")

local CODELAB_LOGO_IMAGE = "rbxassetid://3310888975"

local BINARY_STRING_1 = "101100101101101101001"
local BINARY_STRING_2 = "001011010111010101100"

local BINARY_FONT = Enum.Font.Code

local NUM_BINARY_ROWS = 10
local BINARY_LABEL_HEIGHT = 22
local BINARY_ROW_PADDING = 2

local BINARY_CYCLES_PER_SEC = (1/256)*60

local function alphaFromTime(t)
    return (t*BINARY_CYCLES_PER_SEC)%1
end

local function binaryLabel(string, offset, children)
    return Roact.createElement("TextLabel", {
        Size = UDim2.new(1,0,0,BINARY_LABEL_HEIGHT),
        BackgroundTransparency = 1,
        Position = offset,

        TextColor3 = Color3.fromRGB(255,255,255),
        Text = string or BINARY_STRING_1,
        TextSize = 24,
        Font = BINARY_FONT,
    }, children)
end

function CodeLabLogo:init(initialProps)
    self:updateBinary(tick())
end

function CodeLabLogo:render()

    local alpha = self.state.alpha

    local binaryFrameChildren = {}

    binaryFrameChildren.binaryLayout = Roact.createElement("UIListLayout", {
        HorizontalAlignment = Enum.HorizontalAlignment.Center,
        VerticalAlignment = Enum.VerticalAlignment.Center,
        Padding = UDim.new(0,BINARY_ROW_PADDING),
        SortOrder = Enum.SortOrder.LayoutOrder,
    })

    for i = 1, NUM_BINARY_ROWS do
        local isOdd = (i%2 ~= 0)
        -- offset alpha using some magic numbers to break up grid
        local offset = math.noise(i*1.3625123/NUM_BINARY_ROWS*1.737132)
        local ofsetAlpha = (alpha+offset)%1
        local binaryString = (isOdd and BINARY_STRING_1) or BINARY_STRING_2

        local binaryLabelFrame = Roact.createElement("Frame", {
            Size = UDim2.new(1,0,0,BINARY_LABEL_HEIGHT),
            BackgroundTransparency = 1,
            LayoutOrder = i,
        }, {
                binaryLabel(
                    binaryString,
                    UDim2.new((isOdd and 1-ofsetAlpha) or (ofsetAlpha),0,0,0), {
                        binaryLabel(
                            binaryString,
                            UDim2.new((isOdd and -1) or (-1),0,0,0)
                        )
                    }
                )
            }
        )
        binaryFrameChildren["binaryFrame_"..i] = binaryLabelFrame
    end

    return Roact.createElement("Frame", {
        AnchorPoint = Vector2.new(0.5,0.5),
        Position = UDim2.new(0.5,0,0.5,0),
        Size = UDim2.new(0,256,0,256),

        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(32, 34, 37),
        ClipsDescendants = true
    }, {
        logoLabel = Roact.createElement("ImageLabel", {
            Size = UDim2.new(1,0,1,0),

            BackgroundTransparency = 1,

            Image = CODELAB_LOGO_IMAGE,
        }),
        binaryFrame = Roact.createElement("Frame", {
            Size = UDim2.new(1,0,1,0),

            BackgroundTransparency = 1,
        }, binaryFrameChildren)
    })
end

function CodeLabLogo:updateBinary()
    self:setState({
        alpha = alphaFromTime(tick()),
    })
end

function CodeLabLogo:didMount()
    self.animationConnection = RunService.RenderStepped:connect(function()
        self:updateBinary(tick())
    end)
end

function CodeLabLogo:willUnmount()
    if self.animationConnection then self.animationConnection:disconnect() end
end

return CodeLabLogo]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF603289F4C0640008D718E5DFDCC3B46">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Clock</string>
								<string name="ScriptGuid">{47D853F4-B373-464E-A7C1-7EEBE1CC148B}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local util = common:WaitForChild("util")

local Dictionary = require(util.Dictionary)

local Roact = require(lib:WaitForChild("Roact"))

local Clock = Roact.Component:extend("Clock")

local SECS_IN_MIN = 60
local SECS_IN_HOUR = SECS_IN_MIN*60
local HOURS_ON_FACE = 12

local ARM_PADDING = 6
local HOUR_HAND_RATIO = 1/2

local function hourMarks(numHours,radius)
    local marks = {}
    for i = 1,numHours do
        local theta = (i/numHours)*math.pi*2
        local posX = math.sin(theta)*(radius)
        local posY = math.cos(theta)*(radius)
        marks["hour_"..i] = Roact.createElement("Frame", {
            AnchorPoint = Vector2.new(0.5,0.5),
            Position = UDim2.new(0.5,posX+1,0.5,posY+1),
            Size = UDim2.new(0,4,0,4),

            BackgroundColor3 = Color3.fromRGB(31,31,31),
            BorderSizePixel = 0,
        }, {
            Roact.createElement("Frame", {
                Position = UDim2.new(0,-1,0,-1),
                Size = UDim2.new(1,0,1,0),
                BackgroundColor3 = Color3.fromRGB(220,220,220),
                BorderSizePixel = 0,
            })
        })
    end
    return Roact.createElement("Frame", {
        Size = UDim2.new(1,0,1,0),
        BackgroundTransparency = 1,
    }, marks)
end

local function clockHand(theta,length,thickness,color)
    return Roact.createElement("Frame", {
        Size = UDim2.new(1,0,1,0),
        BackgroundTransparency = 1,

        Rotation = math.deg(theta)
    }, {
        secHandVis = Roact.createElement("Frame", {
            AnchorPoint = Vector2.new(0.5,1),
            Position = UDim2.new(0.5,0,0.5,0),
            Size = UDim2.new(0,thickness or 3,0,length),

            BackgroundColor3 = color or Color3.fromRGB(31,31,31),
            BorderSizePixel = 0,
        })
    })
end

local function hands(t,radius)
    local secOfMin = (t%(60))/(SECS_IN_MIN)
    local minOfHour = (t%(60*60))/(SECS_IN_HOUR)
    local hourOfDay = (t%(60*60*12))/(SECS_IN_HOUR*HOURS_ON_FACE)

    local secHandTheta = secOfMin * math.pi * 2
    local minHandTheta = minOfHour * math.pi * 2
    local hourHandTheta = hourOfDay * math.pi * 2

    local secHand = clockHand(secHandTheta,(radius)-ARM_PADDING, 2,Color3.fromRGB(180,40,40))
    local minHand = clockHand(minHandTheta,(radius)-ARM_PADDING)
    local hourHand = clockHand(hourHandTheta,((radius)-ARM_PADDING)*HOUR_HAND_RATIO)

    return Roact.createElement("Frame", {
        Size = UDim2.new(1,0,1,0),
        BackgroundTransparency = 1,
    }, {
        secHand = secHand,
        minHand = minHand,
        hourHand = hourHand,
    })
end

function Clock:updateTime(newTime)
    self:setState({
        time = newTime
    })
end

function Clock:init(initialProps)
    self:updateTime(tick())
end

function Clock:render()
    local clockFrameProps = Dictionary.join(self.props, {
        BorderSizePixel = 0,
        BackgroundTransparency = 1
    })

    local clockFrameChildren = {
        hourMarks = hourMarks(HOURS_ON_FACE,self.props.Size.Y.Offset/2),
        hands = hands(self.state.time,self.props.Size.Y.Offset/2),
    }

    return Roact.createElement("Frame", clockFrameProps, clockFrameChildren)
end

function Clock:didMount()
    self.animationConnection = RunService.RenderStepped:connect(function()
        self:updateTime(tick())
    end)
end

function Clock:willUnmount()
    if self.animationConnection then self.animationConnection:disconnect() end
end

return Clock]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX775BE358B9C743A0827729365F738BF3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InteractableTarget</string>
								<string name="ScriptGuid">{9A5DCBF9-07CE-470C-94C2-E79D11BD68E2}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local Roact = require(lib:WaitForChild("Roact"))
local RoactRodux = require(lib:WaitForChild("RoactRodux"))
local Selectors = require(common:WaitForChild("Selectors"))
local Otter = require(lib:WaitForChild("Otter"))

local InteractableTarget = Roact.Component:extend("InteractableTarget")

function InteractableTarget:init(initialProps)
    self:setState({
        fade = 1
    })
end

function InteractableTarget:doFade()
    if self.fadeMotor then
        self.fadeMotor:stop()
    end
    self.fadeMotor = Otter.createSingleMotor(1)
    self.fadeMotor:onStep(function(value)
        self:setState({
            fade = value
        })
    end)
    self.fadeMotor:setGoal(Otter.spring(0, {dampingRatio = 1, frequency = 5}))
    self.fadeMotor:start()
end

function InteractableTarget:didMount()
    self:doFade()
end

function InteractableTarget:didUpdate(prevProps,prevState)
    if self.props.targetInteractable ~= prevProps.targetInteractable then
        self:doFade()
    end
end

function InteractableTarget:render()
    if self.props.targetInteractable then

        local instanceRoot = self.props.targetInteractable
        if instanceRoot:IsA("Model") then
            instanceRoot = instanceRoot.PrimaryPart
            if not instanceRoot then return end
        end

        local interactableBillboard = Roact.createElement("BillboardGui", {
            Adornee = instanceRoot,
            AlwaysOnTop = true,
            ResetOnSpawn = false,
            Size = UDim2.new(0,48,0,48),
            MaxDistance = 64,
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        }, {
            Roact.createElement("ImageLabel", {
                Image = "rbxassetid://924320031",
                BackgroundTransparency = 1,
                ImageTransparency = math.clamp(self.state.fade,0,1),
                Size = UDim2.new(1,0,1,0),
                BorderSizePixel = 0,
            })
        })

        return Roact.createElement(Roact.Portal, {
            target = PlayerGui
        }, {
            interactableBillboard = interactableBillboard
        })
    end
end

local function mapStateToProps(state, props)
    return {
        targetInteractable = Selectors.getTargetInteractable(state)
    }
end

InteractableTarget = RoactRodux.connect(mapStateToProps,nil)(InteractableTarget)

return InteractableTarget]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4526638EAF0C4682BD4CDD64F7D255C5">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NotificationContainer</string>
								<string name="ScriptGuid">{62154D6F-40EE-477E-9ED4-DF57A69293D9}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local util = common:WaitForChild("util")
local lib = ReplicatedStorage:WaitForChild("lib")
local components = script:FindFirstAncestor("uiComponents")

local Roact = require(lib:WaitForChild("Roact"))
local RoactRodux = require(lib:WaitForChild("RoactRodux"))
local Selectors = require(common:WaitForChild("Selectors"))
local Dictionary = require(util:WaitForChild("Dictionary"))

local NotificationLabel = require(components:WaitForChild("NotificationLabel"))

local NotificationContainer = Roact.Component:extend("NotificationContainer")

function NotificationContainer:init(initialProps)
end

function NotificationContainer:render()
    local notifs = {}
    local children = {}

    -- loop thru each notification and create labels for each
    for idx, id in ipairs(self.props.notifications.all) do
        local notif = self.props.notifications.byId[id]
        notifs["notification_"..id] = Roact.createElement(NotificationLabel, {
            text = notif.text or "N/A",
            thumbnail = notif.thumbnail,
            statusColor = notif.status,
            layoutIndex = idx,
        })
    end

    children.listLayout = Roact.createElement("UIListLayout", {
        Padding = UDim.new(0,16),
        VerticalAlignment = Enum.VerticalAlignment.Bottom,
    })
    children.padding = Roact.createElement("UIPadding", {
        PaddingBottom = UDim.new(0,16),
        PaddingLeft = UDim.new(0,16),
        PaddingRight = UDim.new(0,16),
        PaddingTop = UDim.new(0,16),
    })

    local combined = Dictionary.join(children,notifs)

    return Roact.createElement("Frame", {
        Size = UDim2.new(1,0,1,0),
        BackgroundTransparency = 1,
    }, combined)
end

local function mapStateToProps(state,props)
    return {
        notifications = Selectors.getNotifications(state) or {byId = {}, all = {}}
    }
end

NotificationContainer = RoactRodux.connect(mapStateToProps,nil)(NotificationContainer)

return NotificationContainer]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA6D4D1890E8D428DB62F16D3579ED780">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NotificationLabel</string>
								<string name="ScriptGuid">{E5C31F11-B6AD-4EE5-B1F2-065DDE1E5ECB}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local Roact = require(lib:WaitForChild("Roact"))

local NotificationLabel = Roact.Component:extend("NotificationLabel")

function NotificationLabel:init(initialProps)
end

function NotificationLabel:render()

    local children = {}

    children.content = Roact.createElement("Frame", {
        Size = UDim2.new(1,0,1,-4),
        BackgroundTransparency = 1,
    }, {
        listlayout = Roact.createElement("UIListLayout", {
            Padding = UDim.new(0,16),
            FillDirection = Enum.FillDirection.Horizontal,
            HorizontalAlignment = Enum.HorizontalAlignment.Left,
            VerticalAlignment = Enum.VerticalAlignment.Center,
            SortOrder = Enum.SortOrder.LayoutOrder,
        }),
        uipadding = Roact.createElement("UIPadding", {
            PaddingBottom = UDim.new(0,8),
            PaddingLeft = UDim.new(0,8),
            PaddingRight = UDim.new(0,8),
            PaddingTop = UDim.new(0,8),
        }),
        thumbnail = Roact.createElement("ImageLabel", {
            Size = UDim2.new(1,0,1,0),
            BorderSizePixel = 0,
            BackgroundTransparency = 1,
            Image = self.props.thumbnail or "rbxasset://textures/ui/GuiImagePlaceholder.png",
            LayoutOrder = 1,
        }, {
            constraint = Roact.createElement("UIAspectRatioConstraint", {
                DominantAxis = Enum.DominantAxis.Width,
                AspectType = Enum.AspectType.FitWithinMaxSize,
                AspectRatio = 1,
            })
        }),
        textLabel = Roact.createElement("TextLabel", {
            Size = UDim2.new(1,-80,0,50),
            BackgroundTransparency = 1,
            Text = self.props.text or "/I SEE YOU/",
            Font = Enum.Font.GothamSemibold,
            TextSize = 18,
            TextWrapped = true,
            TextXAlignment = Enum.TextXAlignment.Left,
            LayoutOrder = 2,
        })
    })

    children.statusBar = Roact.createElement("Frame", {
        AnchorPoint = Vector2.new(0,1),
        Position = UDim2.new(0,0,1,0),
        Size = UDim2.new(1,0,0,4),

        BackgroundColor3 = self.props.statusColor or Color3.fromRGB(20,20,40),
        BorderSizePixel = 0,
    })

    return Roact.createElement("Frame", {
        Size = UDim2.new(0,300,0,80),
        BackgroundColor3 = Color3.fromRGB(255,255,255),
        BorderSizePixel = 0,
        LayoutOrder = self.props.layoutIndex or 0,
    }, children)
end

return NotificationLabel]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXA390627F38934502B989D83A768CA60A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClientApi</string>
						<string name="ScriptGuid">{11B64F74-39A1-4D4C-8919-8F941711BD85}</string>
						<ProtectedString name="Source"><![CDATA[-- wrapper for lpghatguy's common api implementation
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local ClientApi = require(script:WaitForChild("ClientApi"))

local ClientApiWrapper = PizzaAlpaca.GameModule:extend("ClientApi")

function ClientApiWrapper:getApi()
    return self.api
end

function ClientApiWrapper:preInit()
end

function ClientApiWrapper:init()
    local StoreContainer = self.core:getModule("StoreContainer")
    self.api = ClientApi.new({
        initialPlayerState = function(gameState)
            StoreContainer:initializeStore(gameState)
        end,

        storeAction = function(action)
            local store = StoreContainer:getStore()
            if not store then return end

            store:dispatch(action)
        end,
    })
end

function ClientApiWrapper:postInit()
    self.api:connect()
end


return ClientApiWrapper]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD9090B95C4B7470F8D6D63B72E294B58">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClientApi</string>
							<string name="ScriptGuid">{EFFE4D1C-9FFC-4C58-BB9D-F1E43BF4C3C5}</string>
							<ProtectedString name="Source"><![CDATA[-- Author: Lucien Greathouse (LPGhatguy)
-- https://github.com/LPGhatguy/rdc-project/blob/master/src/client/ClientApi.lua

-- Modifications by Austin Reuschle (Nimblz)

--[[
	This object's job is to read the common ApiSpec, which defines the protocol
	for communicating with the server and the types that each method accepts.
	On connecting to the server via `connect`, we generate an object that has
	a method for each RemoteEvent that attached validation on both ends.
	I've found that this is a super nice way to think about network
	communication in Roblox, since it lines up with other strongly-typed RPC
	systems.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ApiSpec = require(ReplicatedStorage.common.ApiSpec)

local ClientApi = {}
ClientApi.prototype = {}
ClientApi.__index = ClientApi.prototype

function ClientApi.new(handlers)
	local self = {handlers = handlers}

	setmetatable(self, ClientApi)

	return self
end

function ClientApi.prototype:connect()
	local handlers = self.handlers
	local remotes = ReplicatedStorage:WaitForChild("Events")

	for name, endpoint in pairs(ApiSpec.fromClient) do
		local remote = remotes:WaitForChild("fromClient-" .. name)

		self[name] = function(_, ...)
			endpoint.arguments(...)

			remote:FireServer(...)
		end
	end

	for name, endpoint in pairs(ApiSpec.fromServer) do
		local remote = remotes:WaitForChild("fromServer-" .. name)

		local handler = handlers[name]

		if handler == nil then
			error(("Need to implement client handler for %q"):format(name), 2)
		end

		remote.OnClientEvent:Connect(function(...)
			endpoint.arguments(...)

			handler(...)
		end)
	end

	for name in pairs(handlers) do
		if ApiSpec.fromServer[name] == nil then
			error(("Invalid handler %q specified!"):format(name), 2)
		end
	end
end

return ClientApi]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX846EB3FCED974C34BE97FF3F91BB87EC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StoreContainer</string>
						<string name="ScriptGuid">{B2DFCB12-70F7-4E27-8FBD-8F19F914FD1C}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local src = script.Parent.Parent
local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local Rodux = require(lib:WaitForChild("Rodux"))
local Signal = require(lib:WaitForChild("Signal"))

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local clientReducer = require(src:WaitForChild("clientReducer"))

local StoreContainer = PizzaAlpaca.GameModule:extend("StoreContainer")

function StoreContainer:create()
    self.storeInitialized = Signal.new()
end

function StoreContainer:getStore()
    return self.store
end

function StoreContainer:initializeStore(initialState)
    self.logger:log("Local store initialized.")
    self.store = Rodux.Store.new(clientReducer,initialState, {
        Rodux.thunkMiddleware,
    })
    self.storeInitialized:fire()
end

function StoreContainer:preInit()
end

function StoreContainer:init()
    self.logger = self.core:getModule("Logger"):createLogger(self)
end

function StoreContainer:postInit()
end

return StoreContainer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX34DFF723603C491B8289B79657D22590">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RecsContainer</string>
						<string name="ScriptGuid">{51EE55D6-3B34-40EA-AC0A-8C7840B21508}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local recsPlugins = common:WaitForChild("recsplugins")

local RECS = require(lib:WaitForChild("RECS"))
local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local RecsComponents = require(common:WaitForChild("RecsComponents"))
local Systems = require(script.Systems)
local Steppers = require(script.Steppers)

local createInjectorPlugin = require(recsPlugins:WaitForChild("createInjectorPlugin"))

local RecsContainer = PizzaAlpaca.GameModule:extend("RecsContainer")

function RecsContainer:preInit()
end

function RecsContainer:init()
    self.recsCore = RECS.Core.new({
        RECS.BuiltInPlugins.CollectionService(),
        RECS.BuiltInPlugins.ComponentChangedEvent,
        createInjectorPlugin("getClientModule", function(_, name)
            return self.core:getModule(name)
        end),
    })

    -- register all components
    for _, component in pairs(RecsComponents) do
        self.recsCore:registerComponent(component)
    end

    self.recsCore:registerSystems(Systems)
    self.recsCore:registerSteppers(Steppers)

    local storeContainer = self.core:getModule("StoreContainer")
    storeContainer.storeInitialized:connect(function()
        self.recsCore:start()
    end)
end

function RecsContainer:postInit()
end


return RecsContainer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX30FFB6ACD53A40EE861EEBCB7A754009">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Steppers</string>
							<string name="ScriptGuid">{6B4C4425-49C2-4C62-922F-0CB72C86458E}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local RECS = require(lib:WaitForChild("RECS"))
local Systems = require(script.Parent:WaitForChild("Systems"))

return {
    RECS.event(game:GetService("RunService").RenderStepped, {
        Systems.InteractableSystem,
        Systems.RigRendererSystem,
    }),
}]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3CFB784893AD4118AA6A0074C7E33827">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Systems</string>
							<string name="ScriptGuid">{8FC40030-7157-4E80-98E0-877F5DE80BA0}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local common = ReplicatedStorage:WaitForChild("common")

return require(common.util:WaitForChild("compileSubmodules"))(script)]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF397B1741AD84785B2860F734A489E79">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InteractableSystem</string>
								<string name="ScriptGuid">{BAC69899-10CB-4642-A253-5F38E6BD5280}</string>
								<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local lib = ReplicatedStorage:WaitForChild("lib")
local common = ReplicatedStorage:WaitForChild("common")
local util = common:WaitForChild("util")

local RECS = require(lib:WaitForChild("RECS"))
local RecsComponents = require(common:WaitForChild("RecsComponents"))
local Selectors = require(common:WaitForChild("Selectors"))
local Actions = require(common:WaitForChild("Actions"))

local InteractableSystem = RECS.System:extend("InteractableSystem")

function InteractableSystem:init()
    self.store = self:getClientModule("StoreContainer"):getStore()
end

function InteractableSystem:step()
    local targetInstance = nil
    local targetDist = math.huge

    local char = LocalPlayer.Character
    if not char then return end
    local root = char.PrimaryPart
    if not root then return end

    local charPos = root.Position

    for instance, component in self.core:components(RecsComponents.Interactable) do
        local instanceRoot = instance
        if instance:IsA("Model") then
            instanceRoot = instance.PrimaryPart
            if not instanceRoot then return end
        end

        local dist = (instanceRoot.Position - charPos).magnitude

        if dist < component.maxUseDistance and dist < targetDist then
            targetInstance = instance
            targetDist = dist
        end
    end

    -- check if closest valid interactable is diff to current target
    -- if it is dispatch an action to change target
    local state = self.store:getState()
    local targetInteractable = Selectors.getTargetInteractable(state)

    if targetInstance ~= targetInteractable then
        self.store:dispatch(Actions.TARGETINTERACTABLE_SET(targetInstance))
    end
end

return InteractableSystem]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX360939C9609E4340AC26BF64B9B0D63C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RigRendererSystem</string>
								<string name="ScriptGuid">{F9809C21-A191-4E79-AEC5-89EEB29E6FAC}</string>
								<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local lib = ReplicatedStorage:WaitForChild("lib")
local common = ReplicatedStorage:WaitForChild("common")
--local util = common:WaitForChild("util")

local RECS = require(lib:WaitForChild("RECS"))
local RecsComponents = require(common:WaitForChild("RecsComponents"))
--local Selectors = require(common:WaitForChild("Selectors"))
--local Actions = require(common:WaitForChild("Actions"))

local RigRenderer = require(script:WaitForChild("RigRenderer"))

local RigRendererSystem = RECS.System:extend("RigRendererSystem")

function RigRendererSystem:newRigRenderer(instance,component)
    print(("New RigRenderer created for %s"):format(instance:GetFullName()))

    -- model may not be replicated fully when component tag is processed
    -- wait a sec and check again

    if not instance.PrimaryPart then
        wait(0.5)
        if not instance then return end
        if not instance.PrimaryPart then return end
    end

    for _, child in pairs(instance:GetChildren()) do
        if child:IsA("BasePart") then
            child.Transparency = 1
        end
    end

    local newRenderer = RigRenderer.new(instance, component.equipped or {"fedora"})

    self.renderers[instance] = newRenderer
    newRenderer:created()
end

function RigRendererSystem:removeRigRenderer(instance,component)
    self.renderers[instance]:removing()
    self.renderers[instance] = nil
end

function RigRendererSystem:init()
    self.store = self:getClientModule("StoreContainer"):getStore()
    self.renderers = {}

    self.core:getComponentAddedSignal(RecsComponents.RigRenderer):connect(function(instance,component)
        self:newRigRenderer(instance,component)
    end)

    self.core:getComponentRemovingSignal(RecsComponents.RigRenderer):connect(function(instance,component)
        self:removeRigRenderer(instance,component)
    end)

    for instance,component in self.core:components(RecsComponents.RigRenderer) do
        self:newRigRenderer(instance,component)
    end
end

function RigRendererSystem:step()
    for _, renderer in pairs(self.renderers) do
        renderer:update()
    end
end

return RigRendererSystem]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXF062CDE40CDF4E308BB8C1B6FABCE6C7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RigRenderer</string>
									<string name="ScriptGuid">{C7710F75-B93E-49BF-A3F2-A67D8AFC042B}</string>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local util = common:WaitForChild("util")

local getDiffs = require(util:WaitForChild("getDiffs"))

local rigRenderer = {}

function rigRenderer:created()
    
end

function rigRenderer:removing()

end

function rigRenderer:refresh(newEquipped)
    local oldEquipped = self.equipped

    -- get diffs and create individual renderers for them, like in old system.
    local added, removed = getDiffs(oldEquipped,newEquipped)

    self.equipped = newEquipped
end

function rigRenderer:update() -- called every frame

end

return {
    new = function(rig, equipped)
        local self = setmetatable({
            rig = rig,
            equipped = {},
            assetRenderers = {},
        }, {__index = rigRenderer})

        self:refresh(equipped)

        return self
    end
}]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1B60EFA41DCA4DD99D741BEC12CCA12D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Notifications</string>
						<string name="ScriptGuid">{2FC50075-236E-487E-B845-B491E7A36D17}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))
local Actions = require(common:WaitForChild("Actions"))

local Notifications = PizzaAlpaca.GameModule:extend("Notifications")

Notifications.SEVERITY = {
    SUCCESS = Color3.fromRGB(26, 155, 24),
    INFO = Color3.fromRGB(66, 151, 255),
    WARNING = Color3.fromRGB(255, 221, 28),
    ERROR = Color3.fromRGB(220, 25, 25),
}

function Notifications:addNotification(id,props,timeout)
    assert(typeof(id) == "string", "Passed id must be a string")
    assert(typeof(props) == "table", "Passed props must be a table")
    if not self.storeContainer then
        warn("Store not initialized, cannot push notification "..tostring(id))
        return
    end

    local store = self.storeContainer:getStore()

    store:dispatch(Actions.NOTIFICATION_ADD(
        id,
        props.text,
        props.thumbnail,
        props.status
    ))

    if timeout then
        delay(timeout, function()
            store:dispatch(Actions.NOTIFICATION_REMOVE(id))
        end)
    end
end

function Notifications:preInit()
end

function Notifications:init()
    self.storeContainer = self.core:getModule("StoreContainer")

    self.storeContainer.storeInitialized:connect(function()
        self:addNotification("gamestart", {
            text = "Game started!",
            status = self.SEVERITY.SUCCESS,
            thumbnail = "rbxassetid://711219385",
        },2)
    end)
end

function Notifications:postInit()
end


return Notifications]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXE8743CB93F1747C19A83338C34A72E3C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">clientReducer</string>
					<string name="ScriptGuid">{079C642F-DA0D-4032-A2BB-05ED56D18E9B}</string>
					<ProtectedString name="Source"><![CDATA[local targetInteractable = require(script:WaitForChild("targetInteractable"))
local notifications = require(script:WaitForChild("notifications"))

return function(state,action)
    state = state or {}
    return {
        targetInteractable = targetInteractable(state.targetInteractable, action),
        notifications = notifications(state.notifications, action),
    }
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX19598CFB930E49ADBF6D9620638D1542">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">targetInteractable</string>
						<string name="ScriptGuid">{D2088525-581E-4AEA-A2F7-C9EEA6ED312C}</string>
						<ProtectedString name="Source"><![CDATA[return function(state, action)
    if action.type == "TARGETINTERACTABLE_SET" then
        return action.interactable
    end
    return state
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCB7121390442433EBF02B507C8323C9D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">notifications</string>
						<string name="ScriptGuid">{F7FBC36F-C442-44E1-B358-AFF7D825A966}</string>
						<ProtectedString name="Source"><![CDATA[--[[ Shape of this state
    notifications {
        byId {
            dataStatus {
                id = "dataStatus",
                text = "Loading data..",
                thumbnail = QUESTIONMARK,
                status = INFO
            },
            welcome {
                id = "welcome",
                text = "Welcome to eg!",
                thumbnail = EGSMILE
                status = SUCCESS
            }
        }
        all {
            "welcome",
            "dataStatus",
        }
    }
]]

-- Should prolly break this into more reducers, oh well.

local function notifAdd(state, action)
    local newNotifs = {byId = {}, all = {}}

    for id, notif in pairs(state.byId) do
        newNotifs.byId[id] = notif
    end

    for idx, id in ipairs(state.all) do
        newNotifs.all[idx] = id
    end

    newNotifs.byId[action.id] = {
        id = action.id,
        text = action.text,
        thumbnail = action.thumbnail,
        status = action.status,
    }

    table.insert(newNotifs.all, 1, action.id) -- push to front

    return newNotifs
end

local function notifRemove(state, action)
    local newNotifs = {byId = {}, all = {}}

    for id, notif in pairs(state.byId) do
        if id ~= action.id then
            newNotifs.byId[id] = notif
        end
    end

    for _,id in ipairs(state.all) do
        if id ~= action.id then
            table.insert(newNotifs.all,id)
        end
    end

    return newNotifs
end

return function(state, action)
    state = state or {byId = {}, all = {}}

    if action.type == "NOTIFICATION_ADD" then
        return notifAdd(state, action)
    elseif action.type == "NOTIFICATION_REMOVE" then
        return notifRemove(state, action)
    end
    return state
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXBD928EEC970A4006B1700CC359660FAE">
			<Properties>
				<string name="Name">StarterCharacterScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="LocalScript" referent="RBX30E9033A8B584CF1BD413B5268B15649">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animate</string>
					<string name="ScriptGuid">{8F748D62-82ED-41EF-846A-8DF7013B5CE5}</string>
					<ProtectedString name="Source"></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX3EED379555514F428D859110AC5A2837">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sound</string>
					<string name="ScriptGuid">{620D7C9D-71EB-41A4-8347-BB56DF036141}</string>
					<ProtectedString name="Source"></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX661F39A9D5EB4AFFA5F5022E1E623238">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Health</string>
					<string name="ScriptGuid">{815FF52E-98C7-4DBF-A057-F5A1990B4F89}</string>
					<ProtectedString name="Source"></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Model" referent="RBX9A21AA6C3FA94EBF86F6C61DE63507C6">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">StarterCharacter</string>
				<Ref name="PrimaryPart">RBX876A483A831543508DB723BA5F51C6FB</Ref>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Part" referent="RBX876A483A831543508DB723BA5F51C6FB">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-8</X>
						<Y>6</Y>
						<Z>9</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">HumanoidRootPart</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0.5</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX1A6E38779E3B4906A9DE2B0C736A7DD3">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RootRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX8BACC35438DA41699E107BDD1914E3A3">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-8</X>
						<Y>6</Y>
						<Z>9</Z>
						<R00>0</R00>
						<R01>1</R01>
						<R02>0</R02>
						<R10>-1</R10>
						<R11>0</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4279069100</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>true</CustomPhysics>
						<Density>0.699999988</Density>
						<Friction>0</Friction>
						<Elasticity>0.5</Elasticity>
						<FrictionWeight>1</FrictionWeight>
						<ElasticityWeight>1</ElasticityWeight>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">LowerTorso</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0.800000012</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX753BE6B73BFB413787457206E02EA2E1">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>-1</R01>
							<R02>0</R02>
							<R10>1</R10>
							<R11>0</R11>
							<R12>-0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">HeadRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXC9D1A1C8E551416FBF326CF097E99132">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>-1</R01>
							<R02>0</R02>
							<R10>1</R10>
							<R11>0</R11>
							<R12>-0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RootRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXDCBD17F89E754A428A767FC81B32F0C4">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-8</X>
						<Y>6</Y>
						<Z>9</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">Head</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX17EB37530FCF4E608740A2779E14CC79">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">HeadRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXD2665BB5E5244436AC5E19C446EA65BA">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">BlockRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Humanoid" referent="RBXBF1C5ED85B994C0B96DB3A063ADE1E5E">
				<Properties>
					<bool name="AutoJumpEnabled">false</bool>
					<bool name="AutoRotate">true</bool>
					<bool name="AutomaticScalingEnabled">false</bool>
					<bool name="BreakJointsOnDeath">true</bool>
					<token name="CollisionType">0</token>
					<token name="DisplayDistanceType">0</token>
					<float name="HealthDisplayDistance">100</float>
					<token name="HealthDisplayType">0</token>
					<float name="Health_XML">100</float>
					<float name="HipHeight">3</float>
					<Vector3 name="InternalBodyScale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<float name="InternalHeadScale">1</float>
					<float name="JumpHeight">10</float>
					<float name="JumpPower">60</float>
					<float name="MaxHealth">100</float>
					<float name="MaxSlopeAngle">89</float>
					<string name="Name">Humanoid</string>
					<float name="NameDisplayDistance">100</float>
					<token name="NameOcclusion">2</token>
					<token name="RigType">1</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="UseJumpPower">false</bool>
					<float name="WalkSpeed">16</float>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX05B9F800E509415DA220F35D737E2568">
		<Properties>
			<string name="Name">StarterPack</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX2F8A60B683F649CD8D9BEE94D8777E00">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX7DD286A0587B47FD99FF2435423D55EC">
		<Properties>
			<string name="Name">LocalizationService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX0BA99DF0133D49D1B0182B55D4F3729E">
		<Properties>
			<string name="Name">Teleport Service</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX22547CFADD96459998D10D67E5B938D9">
		<Properties>
			<string name="Name">CollectionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX3271FD5BC1AE4B5DB94263ABA5A90300">
		<Properties>
			<string name="Name">PhysicsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXC0E5463E079C45169D18DB445175500A">
		<Properties>
			<string name="Name">Geometry</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX820386CD277D4F2BB9058B9B63F7EF37">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<string name="Name">InsertService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBXC7444CBC37374718860852D40404C164">
		<Properties>
			<string name="Name">GamePassService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX75B933A5A08B4B3297318CDCA1936DD7">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXD8B63350D14C4F1CB596DDD904361D64">
		<Properties>
			<string name="Name">CookiesService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXCDA8AA67D4C348C5AD223618F146C76E">
		<Properties>
			<string name="Name">VRService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX3E06C37A4F9E4231B13D98A7242F0A99">
		<Properties>
			<string name="Name">ContextActionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXDA81725BD101462CB4E7F7FFA6E84C28">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXF65D4FD2FE6F4EEBA00E24DD545E13A0">
		<Properties>
			<string name="Name">AssetService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXE3BECE2CEA5D48078E671CAD178A06C8">
		<Properties>
			<string name="Name">TouchInputService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX6DFFD832A3F1477CAEC394FE4EF55450">
		<Properties>
			<string name="Name">Selection</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="13">
		<Properties>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="14">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ServerMain</string>
				<string name="ScriptGuid">{CAF2F596-6231-49CF-8392-D4C0B823B6D5}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local src = script.Parent

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local module = common:WaitForChild("module")

local sidedmodule = src:WaitForChild("module")

local gameCore = PizzaAlpaca.GameCore.new()

gameCore:registerChildrenAsModules(module)
gameCore:registerChildrenAsModules(sidedmodule)

gameCore:load()]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXD36DD188EA6E41CE934230F9B3FA5C08">
			<Properties>
				<string name="Name">module</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2BD1CEAC450A4967B4E24E2FCA4615CA">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerApi</string>
					<string name="ScriptGuid">{670B2E2B-79D7-4121-8B15-2DEDEF214FC3}</string>
					<ProtectedString name="Source"><![CDATA[-- wrapper for lpghatguy's common api implementation
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")
local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local ServerApi = require(script:WaitForChild("ServerApi"))

local ServerApiWrapper = PizzaAlpaca.GameModule:extend("ServerApi")

function ServerApiWrapper:getApi()
    return self.api
end

function ServerApiWrapper:preInit()
end

function ServerApiWrapper:init()
    self.api = ServerApi.create({

    })
end

function ServerApiWrapper:postInit()
    self.api:connect()
end


return ServerApiWrapper]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXBE9E0A588B20459D88AA24549EB687BE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ServerApi</string>
						<string name="ScriptGuid">{9BA3FEF5-BB40-4E3E-8B2C-3174F593CC07}</string>
						<ProtectedString name="Source"><![CDATA[-- Author: Lucien Greathouse
-- https://github.com/LPGhatguy/rdc-project/blob/master/src/server/ServerApi.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ApiSpec = require(ReplicatedStorage.common.ApiSpec)

local ServerApi = {}
ServerApi.prototype = {}
ServerApi.__index = ServerApi.prototype

ServerApi.AllPlayers = newproxy(true)

function ServerApi.create(handlers)
	assert(typeof(handlers) == "table")

	local self = {handlers = handlers}

	setmetatable(self, ServerApi)

	return self
end

function ServerApi.prototype:connect()
	local handlers = self.handlers
	local remotes = Instance.new("Folder")
	remotes.Name = "Events"

	for name, endpoint in pairs(ApiSpec.fromClient) do
		local remote = Instance.new("RemoteEvent")
		remote.Name = "fromClient-" .. name
		remote.Parent = remotes

		local handler = handlers[name]

		if handler == nil then
			error(("Need to implement server handler for %q"):format(name), 2)
		end

		remote.OnServerEvent:Connect(function(player, ...)
			assert(typeof(player) == "Instance" and player:IsA("Player"))

			endpoint.arguments(...)

			handler(player, ...)
		end)
	end

	for name, endpoint in pairs(ApiSpec.fromServer) do
		local remote = Instance.new("RemoteEvent")
		remote.Name = "fromServer-" .. name
		remote.Parent = remotes

		self[name] = function(_, player, ...)
			endpoint.arguments(...)

			if player == ServerApi.AllPlayers then
				remote:FireAllClients(...)
			else
				assert(typeof(player) == "Instance" and player:IsA("Player"))

				remote:FireClient(player, ...)
			end
		end
	end

	for name in pairs(handlers) do
		if ApiSpec.fromClient[name] == nil then
			error(("Invalid handler %q specified!"):format(name), 2)
		end
	end

	remotes.Parent = ReplicatedStorage
	self.remotes = remotes
end

function ServerApi.prototype:destroy()
	self.remotes:Destroy()
end

return ServerApi]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXBF4A15755FF64A56BBA7E949C712BA51">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerInitializer</string>
					<string name="ScriptGuid">{EEA6669A-0952-4FF5-8370-5397B49827DA}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local PlayerInitializer = PizzaAlpaca.GameModule:extend("PlayerInitializer")

function PlayerInitializer:preInit()
end

function PlayerInitializer:init()
    self.logger = self.core:getModule("Logger"):createLogger(self)
end

function PlayerInitializer:postInit()
    local api = self.core:getModule("ServerApi"):getApi()
    Players.PlayerAdded:connect(function(newPlayer)
        api:initialPlayerState(newPlayer,{})
        self.logger:log(("%s was initialized."):format(tostring(newPlayer)))
    end)
end


return PlayerInitializer]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX71E6EFC9628249939DFD9DDDD335EB5F">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CharacterBuilder</string>
					<string name="ScriptGuid">{1AFF0CDF-FEE1-4467-97D7-C462DE48D7C4}</string>
					<ProtectedString name="Source"><![CDATA[-- creates the abstract replicated versions of character rigs, adds RigRenderer tags for recs on the client side

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local CharacterBuilder = PizzaAlpaca.GameModule:extend("CharacterBuilder")

local function bindRigBuilder(player)
    player.CharacterAdded:connect(function(newChar)
        local humanoid = newChar:WaitForChild("Humanoid")
        newChar:WaitForChild("HumanoidRootPart")
        newChar:WaitForChild("LowerTorso")
        newChar:WaitForChild("Head")
        humanoid:BuildRigFromAttachments()

        CollectionService:AddTag(newChar, "RigRenderer")
    end)
end

function CharacterBuilder:preInit()
end

function CharacterBuilder:init()
    Players.PlayerAdded:connect(bindRigBuilder)

    for _,player in pairs(Players:GetPlayers()) do
        bindRigBuilder(player)
    end
end

function CharacterBuilder:postInit()
end


return CharacterBuilder]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX14F7D436025B46EC95F54A32ACEB01C6">
		<Properties>
			<string name="Name">ServerStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXD048901EEF404FD7B463A6C6C3BFFCBB">
			<Properties>
				<string name="Name">TagList</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX1CB1EA61A0A44A899950BA01542EA7FF">
				<Properties>
					<string name="Name">Interactable</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Color3Value" referent="RBX4C01F4F2F39940329D1E7701BCA2D3E6">
					<Properties>
						<string name="Name">Color</string>
						<BinaryString name="Tags"></BinaryString>
						<Color3 name="Value">
							<R>0.827716231</R>
							<G>0.972549021</G>
							<B>0.282311857</B>
						</Color3>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX23A078D4E78943B7AE6E208406322203">
					<Properties>
						<string name="Name">Icon</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">information</string>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBXFD881B247638488BBC68437764EC3BAB">
					<Properties>
						<string name="Name">DrawType</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">Icon</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBXBF8A19A1F2764F829146E7ED94BFE78B">
					<Properties>
						<string name="Name">AlwaysOnTop</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXEB50859852DF43B4AA93C027118FC880">
				<Properties>
					<string name="Name">RigRenderer</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Color3Value" referent="RBX04A3B2F5713146F99AB4E78A5614149D">
					<Properties>
						<string name="Name">Color</string>
						<BinaryString name="Tags"></BinaryString>
						<Color3 name="Value">
							<R>0.411777169</R>
							<G>0.832549036</G>
							<B>0.0346768051</B>
						</Color3>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX1D638616CB7E4F98AD63515902988DD5">
					<Properties>
						<string name="Name">Icon</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">user</string>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX65CC869E67F64783BF1D71C0C984652F">
					<Properties>
						<string name="Name">DrawType</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">Icon</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX608708D5BCFF4B039508CBD31F0A84B9">
					<Properties>
						<string name="Name">AlwaysOnTop</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXAE583BBBAFD244978ABF3D2F127F1244">
				<Properties>
					<string name="Name">BanOnInteract</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Color3Value" referent="RBX83A9137465344E9EAE9558C3903688A3">
					<Properties>
						<string name="Name">Color</string>
						<BinaryString name="Tags"></BinaryString>
						<Color3 name="Value">
							<R>0.411950916</R>
							<G>0.574509799</G>
							<B>0.116714902</B>
						</Color3>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX5BFB38055F73462B90C6585CD940605E">
					<Properties>
						<string name="Name">Icon</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">exclamation</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX0CD0A1808CC8499CAB580EB9815283CD">
					<Properties>
						<string name="Name">Visible</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX4E505328BF0744069DE500F8A568729F">
					<Properties>
						<string name="Name">DrawType</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">Icon</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBXDDC2C149387D4892B944D7B821F12EB5">
					<Properties>
						<string name="Name">AlwaysOnTop</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX49D61D6AFE9E428BAC65AA8876C2BCC6">
				<Properties>
					<string name="Name">DialogOnInteract</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Color3Value" referent="RBX399DC34FD17548A6A79E90EEE0BEBF22">
					<Properties>
						<string name="Name">Color</string>
						<BinaryString name="Tags"></BinaryString>
						<Color3 name="Value">
							<R>0.640392184</R>
							<G>0.0219938699</G>
							<B>0.517765045</B>
						</Color3>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX7EF9564750EE48AB8A5AEDFA7F892401">
					<Properties>
						<string name="Name">Icon</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">comments</string>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX6256D4BD4B7E4C958DE8FCF8F3114C27">
					<Properties>
						<string name="Name">DrawType</string>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">Icon</string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBXF038A54CFE1D418C9578D2FAF24AAB2E">
					<Properties>
						<string name="Name">AlwaysOnTop</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBXB0A4C1770CE34F78BEF60A3F71F6A409">
			<Properties>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">ScreenGui</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX22ECDE0507CC45B9985DBF75FBCF4DDA">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>1</Y>
					</Vector2>
					<bool name="AutoLocalize">true</bool>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">notifcontainer</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>300</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="UIListLayout" referent="RBX2AF435DDE4BA4341BF492D5C365D3705">
					<Properties>
						<token name="FillDirection">1</token>
						<token name="HorizontalAlignment">1</token>
						<string name="Name">UIListLayout</string>
						<UDim name="Padding">
							<S>0</S>
							<O>16</O>
						</UDim>
						<token name="SortOrder">2</token>
						<BinaryString name="Tags"></BinaryString>
						<token name="VerticalAlignment">2</token>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBXF1F97DCF9E8847C7876D067E422D18AC">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">notifFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>80</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX61F7199E902C40E9AD7D9E3FF99E0538">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>0.125490203</R>
								<G>0.729411781</G>
								<B>0.117647067</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">statusbar</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXA7D4E4E43C6240D7991902928814B1B6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBX70500CF3B0B94758B409993A7E84B9B2">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">1</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>16</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBXED2F4C04D941439DA54330C40238BE63">
							<Properties>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX7EF546D1D1874EDE8062D0E6859B3E9A">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">1</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBXBF6BB550DC1A4535992D92A669DB6B77">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXB9AD3644EB254C0A9846C7BE1ACACE42">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">18</token>
								<int name="LayoutOrder">2</int>
								<float name="LineHeight">1</float>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-80</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Data loaded!</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">20</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBXD09FCDCE799A4E6A83675C2D46E786DC">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">notifFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>80</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBXC3F067204F634DFF9569BB8107263C49">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>0.866666734</G>
								<B>0.10980393</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">statusbar</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX6365ADE178C24FB48D250FCA2B9E82F0">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBXB1B0D84B44054E79A046C90009C0D07C">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">1</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>16</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBXCD38857BF21447DDA57F3E8731A8C752">
							<Properties>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX9B2CCB5D92754AA3AB83A30618A6FA95">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">1</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBXE5B10EE4B8CA4B64A93F81C6382B59E1">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXB80BC4F02C66418586E91E293B5F0C6F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">18</token>
								<int name="LayoutOrder">2</int>
								<float name="LineHeight">1</float>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-80</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Your info is out of date!</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">20</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX91F75FDBCEB14577A1BC21226FD57CC8">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">notifFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>80</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX97BB9C8955514D5A85B5CB246DD685E6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>0.862745166</R>
								<G>0.0980392247</G>
								<B>0.0980392247</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">statusbar</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX31DFC0A4F7F740628C467B3765B17A7A">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBXB76FD714FAD742C7B7D99E4794D7F2AF">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">1</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>16</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX868760D793A644F3B8FAA196D9D43DEF">
							<Properties>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX075D0D3E7CCA4EBE9489DB22D76C5693">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">1</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBX5FF433BD8F6A444F831DF346B0075ABE">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXAD84FFB521A14DFCA4CF4A79A1F57BAA">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">18</token>
								<int name="LayoutOrder">2</int>
								<float name="LineHeight">1</float>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-80</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">There was an error starting the game!</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">20</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX2C10768B9F5D4C5B868A992AC956846E">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">notifFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>348</XO>
							<YS>0</YS>
							<YO>80</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX37796E965B4F4D60A2446052E25B81B4">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>0.258823544</R>
								<G>0.592156887</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">statusbar</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX326AFD2D1392445D96F60A7E06D9C60B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBX73D801A7128B413FB35335FEDAB69BA8">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">1</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>16</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX9B2C49F3C44747B298F86FC3974C93F1">
							<Properties>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBXF317407485BB469DAEA14BE2C7314E72">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">1</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBXD9D10A2014EE439587CD0B49569A6048">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXB702446DCC904120986850E754756DD5">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">18</token>
								<int name="LayoutOrder">2</int>
								<float name="LineHeight">1</float>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>248</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Hat awarded: Baseball Cap</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">20</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="UIPadding" referent="RBX3106A27FA8894DC8A81EFA35E3503C3C">
				<Properties>
					<string name="Name">UIPadding</string>
					<UDim name="PaddingBottom">
						<S>0</S>
						<O>16</O>
					</UDim>
					<UDim name="PaddingLeft">
						<S>0</S>
						<O>16</O>
					</UDim>
					<UDim name="PaddingRight">
						<S>0</S>
						<O>16</O>
					</UDim>
					<UDim name="PaddingTop">
						<S>0</S>
						<O>16</O>
					</UDim>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<string name="Name">ReplicatedStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="2">
			<Properties>
				<string name="Name">common</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="11">
				<Properties>
					<string name="Name">module</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3F7D0F7D7BDA47D992FEFF1D4304D2D9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Logger</string>
						<string name="ScriptGuid">{DF1F8CF5-7EFA-4BC6-8176-651AD0314AF4}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local PizzaAlpaca = require(lib:WaitForChild("PizzaAlpaca"))

local Logger = PizzaAlpaca.GameModule:extend("Logger")

local LOG_FORMAT_STRING = "[%s][%s]: %s"

local logtype = {
    OUTPUT = 1,
    WARNING = 2,
    SEVERE = 3,
}

local logtypeNames = {
    [logtype.OUTPUT] = "OUTPUT",
    [logtype.WARNING] = "WARNING",
    [logtype.SEVERE] = "SEVERE",
}

local printFuncs = {
    [logtype.OUTPUT] = print,
    [logtype.WARNING] = warn,
    [logtype.SEVERE] = function(msg)
        -- Todo: send this to a webserver so nim can review it
        error(msg,3) -- delicious red text.
    end
}

function Logger:create() -- constructor, fired on instantiation, core will be nil.
    self.logtype = logtype
end

function Logger:createLogger(module)
    local logger = {}
    logger.logtype = logtype

    function logger:log(msg,severity)
        severity = severity or logtype.OUTPUT
        printFuncs[severity or logtype.OUTPUT](LOG_FORMAT_STRING:format(
            tostring(module),
            tostring(logtypeNames[severity]),
            tostring(msg))
        )
    end

    return logger
end

return Logger]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX91DDE69F84DD4768A6FDF350B9AC5CEC">
				<Properties>
					<string name="Name">util</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXDF561E402F7A454BABF65AD37CFBE81D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compileSubmodulesToArray</string>
						<string name="ScriptGuid">{3D76AC3B-BABF-4489-9429-3BFEB59CCD8D}</string>
						<ProtectedString name="Source"><![CDATA[return function(parent, recursive)
    local compiled = {}
    local children = (recursive and parent:GetDescendants()) or parent:GetChildren()

    for _,moduleScript in pairs(children) do
        if moduleScript:IsA("ModuleScript") then
            local required = require(moduleScript)
            table.insert(compiled, required)
        end
    end

    return compiled
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX76F2866D8FA045DF93A2B11AA66D7C84">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compileSubmodules</string>
						<string name="ScriptGuid">{BF621D8E-669B-4CD2-9CC6-42A963828D13}</string>
						<ProtectedString name="Source"><![CDATA[local function indexByName(moduleScript)
    return moduleScript.Name
end

return function(parent, recursive, indexFunc)
    indexFunc = indexFunc or indexByName
    local compiled = {}
    local children = (recursive and parent:GetDescendants()) or parent:GetChildren()

    for _,moduleScript in pairs(children) do
        if moduleScript:IsA("ModuleScript") then
            compiled[indexFunc(moduleScript)] = require(moduleScript)
        end
    end

    return compiled
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9AD7FD76553D4227B1DE0CFE8955CE86">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">None</string>
						<string name="ScriptGuid">{9DB7F080-C797-45FD-9E49-C87E5B06CA89}</string>
						<ProtectedString name="Source"><![CDATA[-- Author: Lucien Greathouse
-- https://github.com/LPGhatguy/rdc-project/blob/master/src/common/None.lua
--[[
	Represents a value that is intentionally present, but should be interpreted
	as `nil`.
	None is used by included utilities to make removing values more ergonomic.
]]

local None = newproxy(true)

getmetatable(None).__tostring = function()
	return "None"
end

return None]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX197437816F6048D3B538D78A135431A6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Dictionary</string>
						<string name="ScriptGuid">{9FE910AE-5FB1-4278-8DCB-0A4A3D2E2C69}</string>
						<ProtectedString name="Source"><![CDATA[-- Author: Lucien Greathouse
-- https://github.com/LPGhatguy/rdc-project/blob/master/src/common/Dictionary.lua
--[[
	Defines utilities for working with 'dictionary-like' tables.
	This file, along with None.lua, come from a library we'll be releasing soon
	called Cryo. It has a set of utilities, like this one, to help make working
	with immutable data structures easier.
	Dictionaries can be indexed by any value, but don't have the ordering
	expectations that lists have.
]]

local None = require(script.Parent.None)

--[[
	Combine a number of dictionary-like tables into a new table.
	Keys specified in later tables will overwrite keys in previous tables.
	Use `None` as a value to remove a key. This is necessary because
	Lua does not distinguish between a value not being present in a table and a
	value being `nil`.
]]
local function join(...)
	local new = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					new[key] = nil
				else
					new[key] = value
				end
			end
		end
	end

	return new
end

return {
	None = None,
	merge = join,
	join = join,
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFCCD322D546949D480405941CA4A2D54">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getAlignableTextSize</string>
						<string name="ScriptGuid">{0C0A38A4-5A5B-43AD-9263-738A3AD0C692}</string>
						<ProtectedString name="Source"><![CDATA[-- Author: Tiffany Benett

local TextService = game:GetService("TextService")

local baselineTable = {
    [Enum.Font.Arial]            =  1.15,
    [Enum.Font.ArialBold]        =  1.15,
    [Enum.Font.SourceSans]       =  1.257,
    [Enum.Font.SourceSansBold]   =  1.257,
    [Enum.Font.SourceSansLight]  =  1.257,
    [Enum.Font.SourceSansItalic] =  1.257,
    [Enum.Font.Bodoni]           =  1.192,
    [Enum.Font.Garamond]         =  1.20,
    [Enum.Font.Cartoon]          =  1.209,
    [Enum.Font.Code]             =  1.049,
    [Enum.Font.Highway]          =  1.107,
    [Enum.Font.SciFi]            =  1.20,
    [Enum.Font.Arcade]           =  1.025,
    [Enum.Font.Fantasy]          =  1.018,
    [Enum.Font.Antique]          =  1.049,
    [Enum.Font.Gotham]           =  1.20,
    [Enum.Font.GothamBlack]      =  1.20,
    [Enum.Font.GothamBold]       =  1.20,
    [Enum.Font.GothamSemibold]   =  1.20,
}

local function getSize(props)
    local text = props.text
    if type(text) ~= "string" then
        text = text:getValue()
    end

    local bounds = TextService:GetTextSize(text, props.textSize, props.font, Vector2.new(100000, 100000))

    local width = math.min(props.maxWidth or math.huge, bounds.X)

    if props.useBaseline then
        local ratio = baselineTable[props.font]
        -- Fudge factors to make it look right
        local nominal = (props.textSize - 3.5) / ratio
        local height = math.floor(nominal + 3.5)

        return Vector2.new(width, height + props.baselineOffset)
    end

    return Vector2.new(width, bounds.Y)
end

return getSize]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4062C0AB5ED04DEB849D9B4B70548AC3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">by</string>
						<string name="ScriptGuid">{A4A8F32A-8B15-4DCC-8EC4-3054E1FAE563}</string>
						<ProtectedString name="Source"><![CDATA[return function(keyName, tbl)
    assert(typeof(keyName)=="string", "Arg 1 must be a string, got "..typeof(keyName))
    assert(typeof(tbl)=="table", "Arg 2 must be a table, got"..typeof(tbl))

    local new = {}

    for idx,v in ipairs(tbl) do
        if v[keyName] ~= nil then
            new[v[keyName]] = v
        else
            warn(("item %s at [%d] has no key %s"):format(tostring(v), idx, tostring(keyName)))
        end
    end

    return new
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3002ED24B004473CA293E198869589BA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getDiffs</string>
						<string name="ScriptGuid">{EE3818C3-C262-4B0C-ABDE-4A1FDA23CDF9}</string>
						<ProtectedString name="Source"><![CDATA[local function getDiffs(t1,t2)
    local added, removed = {}, {}
    local t1Set, t2Set = {}, {}

    -- create t1 hash set
    for _,v in pairs(t1) do
        t1Set[v] = true
    end
    -- create t2 hash set and check against t1 set to find new elements
    for _,v in pairs(t2) do
        t2Set[v] = true
        -- do this here to cut out an extra for loop
        if not t1Set[v] then
            table.insert(added,v)
        end
    end
    -- check t1 against t2 set to find removed
    for _,v in pairs(t1) do
        if not t2Set[v] then
            table.insert(removed,v)
        end
    end

    return added,removed
end

return getDiffs]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX6E83ABAB81E740C99F1C1002EF909C26">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ApiSpec</string>
					<string name="ScriptGuid">{6DC16C20-4AC1-4FE2-A44F-E3700FCA3544}</string>
					<ProtectedString name="Source"><![CDATA[-- Author: Lucien Greathouse
-- https://github.com/LPGhatguy/rdc-project/blob/master/src/common/ApiSpec.lua

--[[
	This file specifies the protocol for communication between the client and
	server.
	It uses 't' as a way to encode type signatures into the remotes, which
	are checked on both ends. This should be enough to verify that well-behaved
	clients are obeying the API contract, and acts as a first-pass guard against
	malicious clients.
	Both the client and server must implement the correct points of this API.
	Each remote is only one-way to prevent low-hanging fruit exploits related to
	causing a server to yield forever when using RemoteFunction objects.
	The server will automatically generate a RemoteEvent object for every object
	in this table.
	The client will automatically wait for every event to exist and connect to
	each of them.
]]
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local t = require(lib:WaitForChild("t"))

return {
	fromClient = {
		-- methodName = {
        --     arguments = t.tuple(
        --         t.Instance
        --     )
		-- },
	},
	fromServer = {
		initialPlayerState = {
			arguments = t.tuple(
				t.any
			)
		},
		storeAction = {
			arguments = t.tuple(
				t.any
			)
		},
	},
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX955E228EEEEE4BD9B15A3E511466F2FD">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">dialogNode</string>
					<string name="ScriptGuid">{284072EA-2014-45F9-BBDA-EAB7FF8CACC0}</string>
					<ProtectedString name="Source"><![CDATA[local dialogNode_prototype = {
    text = "NODE TEXT UNIMPLEMENTED, NOTIFY NIMBLZ PLEASE",
    responseOptions = {},
}

local function dialogNode(props)
    return setmetatable(props,{__index = dialogNode_prototype})
end

return dialogNode]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC6739569E4114CFBA886C1226E0E146A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">dialogResponse</string>
					<string name="ScriptGuid">{557A29EA-8C8F-415A-B7BF-AAE4D01E4BA9}</string>
					<ProtectedString name="Source"><![CDATA[local dialogResponse_prototype = {
    text = "RESPONSE UNIMPLEMENTED, NOTIFY NIMBLZ",
    onSelect = function(player, server) end,
    nextNode = nil, -- if nil this is the end of conversation.
}

local function dialogResponse(props)
    return setmetatable(props,{__index = dialogResponse_prototype})
end

return dialogResponse]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXED976F07E370474A8DC43A7C407892FF">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RecsComponents</string>
					<string name="ScriptGuid">{04B91D9A-1096-4C98-B42F-AC11B806BAE3}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local common = ReplicatedStorage:WaitForChild("common")

return require(common.util:WaitForChild("compileSubmodules"))(script)]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5A13C1A5DBAA41F8890E529E45CDF776">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Interactable</string>
						<string name="ScriptGuid">{603AB53B-4493-47A5-85DD-3E8F0AF081B5}</string>
						<ProtectedString name="Source"><![CDATA[-- increments score on touch, use in combination with spinner! :D entity composition!!
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local RECS = require(lib:WaitForChild("RECS"))

return RECS.defineComponent({
    name = "Interactable",
    generator = function()
        return {
            maxUseDistance = 10
        }
    end,
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX91E274EBC5744E90824FDF01D5F6C701">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RigRenderer</string>
						<string name="ScriptGuid">{3A32F789-FA68-4B51-B5EF-2CA9B41AAF93}</string>
						<ProtectedString name="Source"><![CDATA[-- increments score on touch, use in combination with spinner! :D entity composition!!
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local RECS = require(lib:WaitForChild("RECS"))

return RECS.defineComponent({
    name = "RigRenderer",
    generator = function()
        return {
            equipped = {
				"piratehat",
				"eyepatch",
				"beard",
			},
			scale = 1,
        }
    end,
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3C0AE46418484972BE4DD04B57FE116C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DialogOnInteract</string>
						<string name="ScriptGuid">{ECA24C90-FD02-4D83-84FC-0BCA2E549972}</string>
						<ProtectedString name="Source"><![CDATA[-- increments score on touch, use in combination with spinner! :D entity composition!!
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local RECS = require(lib:WaitForChild("RECS"))

return RECS.defineComponent({
    name = "DialogOnInteract",
    generator = function()
        return {
            id = "testDialog"
        }
    end,
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX618214A13B854EAEB5E2861CC3EDF38A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BanOnInteract</string>
						<string name="ScriptGuid">{F927B8C6-CA0B-44E7-9F9B-7D137869C5B9}</string>
						<ProtectedString name="Source"><![CDATA[-- increments score on touch, use in combination with spinner! :D entity composition!!
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lib = ReplicatedStorage:WaitForChild("lib")

local RECS = require(lib:WaitForChild("RECS"))

return RECS.defineComponent({
    name = "BanOnInteract",
    generator = function()
        return {
        }
    end,
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXD6291FF4179044BBB2F1D398E70796FD">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Actions</string>
					<string name="ScriptGuid">{260BDC07-F6DB-43D9-8B6C-BA3F691C06FF}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local common = ReplicatedStorage:WaitForChild("common")

return require(common.util:WaitForChild("compileSubmodules"))(script)]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2D50C26FC032483B898982A44532F80F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TARGETINTERACTABLE_SET</string>
						<string name="ScriptGuid">{E62805AE-E07D-4E78-9D5B-17338A003C20}</string>
						<ProtectedString name="Source"><![CDATA[return function(interactable)
    return {
        type = script.Name,
        interactable = interactable,
    }
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFBAD26B91763476DAC42298D496D6DB6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NOTIFICATION_ADD</string>
						<string name="ScriptGuid">{ED78640B-C28F-4276-B5E3-97D146D15F83}</string>
						<ProtectedString name="Source"><![CDATA[return function(id,text,thumbnail,status)
    return {
        type = script.Name,
        id = id,
        text = text,
        thumbnail = thumbnail,
        status = status,
    }
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4F8FC6528A9648259DDC9E0C9F2EF855">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NOTIFICATION_REMOVE</string>
						<string name="ScriptGuid">{0B69AE89-EEEF-4545-94ED-9B7B3A065796}</string>
						<ProtectedString name="Source"><![CDATA[return function(id)
    return {
        type = script.Name,
        id = id,
    }
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX0C035DFA329649ABB22291B84B76DAA4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">commonReducer</string>
					<string name="ScriptGuid">{9BA52486-240F-4A51-BA8F-9CB0C602CE57}</string>
					<ProtectedString name="Source"><![CDATA[return function(state,action)
    state = state or {}
    return {
    }
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX68C55CACAD034023A4CB792DB448D029">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Selectors</string>
					<string name="ScriptGuid">{D71114A5-B7C0-4B11-B48F-421A24C22022}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local common = ReplicatedStorage:WaitForChild("common")

return require(common.util:WaitForChild("compileSubmodules"))(script)]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2AE5BEA165CF4BE9B26F33DE399052DF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getTargetInteractable</string>
						<string name="ScriptGuid">{73D204E4-58A1-485D-950C-C75AD9B1EAC0}</string>
						<ProtectedString name="Source"><![CDATA[return function(state)
    return state.targetInteractable
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB3F0AE9E1F9B4654814A52E813509FE5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getNotifications</string>
						<string name="ScriptGuid">{D63004A2-FE08-4246-8FFF-D1777277A029}</string>
						<ProtectedString name="Source"><![CDATA[return function(state)
    return state.notifications
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX7FB53F54CF9B439F9AB2CDDFF9248146">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Dialogs</string>
					<string name="ScriptGuid">{E40D9A44-E227-481D-A553-19FFC2C7302A}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local common = ReplicatedStorage:WaitForChild("common")

local by = require(common.util:WaitForChild("by"))
local compileSubmodulesToArray = require(common.util:WaitForChild("compileSubmodulesToArray"))
local all = compileSubmodulesToArray(script, true)

return {
    all = all,
    byId = by("id", all),
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX30401D75EA464EDFBE55451758E17496">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TestDialog</string>
						<string name="ScriptGuid">{4EDE5EBE-DC37-4C72-A42F-70F84FE4ED87}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local common = ReplicatedStorage:WaitForChild("common")
local lib = ReplicatedStorage:WaitForChild("lib")

local dialogNode = require(common.dialogNode)
local dialogResponse = require(common.dialogResponse)

-- test for onSelect
local explosionResponse = dialogResponse({
    text = "please explode me!",
    onSelect = function(player, server)
        local character = player.Character
        if not character then return end
        local root = character.PrimaryPart
        if not root then return end

        local explosion = Instance.new("Explosion")
        explosion.Position = root.Position
        explosion.BlastRadius = 4
        explosion.Parent = character
    end,
})

local foobarResponse = dialogResponse({
    text = "foobar",
    nextNode = dialogNode({
        text = "baz!",
        responseOptions = {
            explosionResponse, -- nested option test
        }
    })
})

local dialogRoot = dialogNode({
    text = "Hello world!~",
    responseOptions = {
        foobarResponse, -- 1
        explosionResponse, -- 2
    }
})

return {
    id = "testDialog",
    root = dialogRoot,
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1C7CC4B88B2C4E78AE553CF2DEFEE126">
				<Properties>
					<string name="Name">object</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX74EC071765AC48649A2A74B93FF98118">
				<Properties>
					<string name="Name">recsplugins</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX41475D550CBF40A59FBDA7A6A3AFF2CB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createInjectorPlugin</string>
						<string name="ScriptGuid">{825A0D64-01DE-4B5D-90D4-04495C925A98}</string>
						<ProtectedString name="Source"><![CDATA[local function createInjectorPlugin(key,value)
    local injectorPlugin = {}

    function injectorPlugin:beforeSystemStart(core)
        for _, system in pairs(core._systems) do
            system[key] = value
        end
    end

    return injectorPlugin
end

return createInjectorPlugin]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6DADF00B7BC742A1A23D8D84DFF38E60">
			<Properties>
				<string name="Name">lib</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE40876658A0F4E16ADB815D7CE517E6E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PizzaAlpaca</string>
					<string name="ScriptGuid">{D8E7350E-02C0-4486-9335-486ED3F74AAC}</string>
					<ProtectedString name="Source"><![CDATA[return {
    GameModule = require(script.GameModule),
    GameCore = require(script.GameCore),
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXAE57482F17D14A70BB77AB1BDAA86A63">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameCore</string>
						<string name="ScriptGuid">{8ACB28E2-DC36-4BF5-80CA-72CF4704EE8B}</string>
						<ProtectedString name="Source"><![CDATA[local src = script.Parent

local compileSubmodules = require(src:WaitForChild("compileSubmodules"))
local callOnAll = require(src:WaitForChild("callOnAll"))

local GameCore = {}

local errors = {
    invalidArgument = "Invalid argument: [%s]. expected: [%s]."
}

local function instanceModule(class, core)
    return setmetatable({
        core = core
    },{__index = class, __tostring = getmetatable(class).__tostring})
end

function GameCore.new()
    local core = setmetatable({
        _moduleClasses = {},
        _modules = {},
    }, {__index = GameCore})

    return core
end

function GameCore:registerModule(moduleClass)
    local moduleClassType = typeof(moduleClass)

    if moduleClassType == "table" then
        assert(moduleClass.__gamemodule, 
            errors.invalidArgument:format(
                tostring(moduleClass),
                "GameModule class"
            ),
            2
        )
        self._moduleClasses[moduleClass.name] = moduleClass
    elseif moduleClassType == "Instance" then
        assert(moduleClass:IsA("ModuleScript"),
            errors.invalidArgument:format(
                moduleClass:GetFullName(),
                "ModuleScript"
            ),
            2
        )

        local requiredModuleClass = require(moduleClass)
        self:registerModule(requiredModuleClass) -- register the class
    else
        error(errors.invalidArgument:format(
            tostring(moduleClass),
            "GameModule class or ModuleScipt of GameModule class"),
            2
        )
    end
end

function GameCore:registerChildrenAsModules(root)
    for _, module in pairs(compileSubmodules(root,true)) do
        self:registerModule(module)
    end
end

function GameCore:instanceAllModules()
    -- instance modules
    for name, class in pairs(self._moduleClasses) do
        self._modules[name] = instanceModule(class, self)
        self._modules[name]:create()
    end
end

function GameCore:getModule(name)
    if not self._modules[name] then
        warn(("No such module %s"):format(tostring(name)))
    end
    return self._modules[name]
end

function GameCore:callOnModules(methodName)
    callOnAll(self._modules, methodName)
end

function GameCore:load()
    self:instanceAllModules()
    self:callOnModules("preInit")
    self:callOnModules("init")
    self:callOnModules("postInit")
end

return GameCore]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX90D160A7EE09448D8620F12FC1C41A0C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameModule</string>
						<string name="ScriptGuid">{43BB0536-351B-49AC-94A5-093756243F67}</string>
						<ProtectedString name="Source"><![CDATA[-- this type of class extension thing is inspired by Roact's component class, check it out:
-- https://github.com/Roblox/roact/blob/master/src/Component.lua

local GameModule = {}
local gameModuleMetatable = {}

function gameModuleMetatable:__tostring()
    return self.name
end

function GameModule:extend(name)
    local newModule = {name = name, __gamemodule = true}

    for k,v in pairs(self) do
        if k ~= "extend" then -- modules shouldnt extend other modules that's evil please do not do that.
            newModule[k] = v
        end
    end

    setmetatable(newModule, gameModuleMetatable)

    return newModule
end

-- constructor, fired on instantiation, core will be nil.
function GameModule:create()
    return
end

-- This is where you setup this module and make it ready for other modules to interact with.
-- It is not safe to interact with other modules at this step, but you can create references to them
function GameModule:preInit()
    return
end

-- This is where you should do this module's work, setup the behavior
-- this module is responsible for.
-- it is safe to interact with other modules at this stage but their behaviors
-- may not yet be setup. If your module is contingent on another module being
-- finished setting up its behavior, do that in postInit.
function GameModule:init()
    return
end

-- This is where you should interact with other modules.
function GameModule:postInit()
    return
end

return GameModule]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD30991F340504773981144282B19CE50">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">callOnAll</string>
						<string name="ScriptGuid">{5FA388DF-37E3-4643-A528-C2646A5E500F}</string>
						<ProtectedString name="Source"><![CDATA[return function(table, methodname, ...)
    for _, v in pairs(table) do
        v[methodname](v, ...)
    end
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5EC96F9EA2A848078BB017500BF7C857">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compileSubmodules</string>
						<string name="ScriptGuid">{FFA7DA22-4FD0-435D-9B3E-6C00DC9FC134}</string>
						<ProtectedString name="Source"><![CDATA[local errors = {
    IllegalArgument = "Argument 1 must be an instance, got %s",
}

return function(root, recurseThroughFolders)
    assert(root, errors.IllegalArgument:format(typeof(root)))
    assert(typeof(root) == "Instance", errors.IllegalArgument:format(typeof(root)))

    local modules = {}

    local function compileSubmodules(instance)
        for _, child in pairs(instance:GetChildren()) do
            if child:IsA("ModuleScript") then
                local requiredModule = require(child)

                modules[child] = requiredModule
            elseif child:IsA("Folder") and recurseThroughFolders then
                compileSubmodules(child)
            end
        end
    end

    compileSubmodules(root)

    return modules
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX149BEBC3108C44409A21A8144B32DB17">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Roact</string>
					<string name="ScriptGuid">{49244895-8822-49EA-ADE3-99C109F51D85}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXDE49238B9A054AA780C0E488DCDBC82F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Binding</string>
						<string name="ScriptGuid">{2AC81FCE-87EC-49FD-B974-9C0B260D57F8}</string>
						<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDFCC1637CC6044D1832E922C147DC29D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Binding.spec</string>
						<string name="ScriptGuid">{A4E33507-9182-466F-B614-AEFA865146FF}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createSpy = require(script.Parent.createSpy)
	local Type = require(script.Parent.Type)

	local Binding = require(script.Parent.Binding)

	describe("Binding.create", function()
		it("should return a Binding object and an update function", function()
			local binding, update = Binding.create(1)

			expect(Type.of(binding)).to.equal(Type.Binding)
			expect(typeof(update)).to.equal("function")
		end)

		it("should support tostring on bindings", function()
			local binding, update = Binding.create(1)
			expect(tostring(binding)).to.equal("RoactBinding(1)")

			update("foo")
			expect(tostring(binding)).to.equal("RoactBinding(foo)")
		end)
	end)

	describe("Binding object", function()
		it("should provide a getter and setter", function()
			local binding, update = Binding.create(1)

			expect(binding:getValue()).to.equal(1)

			update(3)

			expect(binding:getValue()).to.equal(3)
		end)

		it("should let users subscribe and unsubscribe to its updates", function()
			local binding, update = Binding.create(1)

			local spy = createSpy()
			local disconnect = Binding.subscribe(binding, spy.value)

			expect(spy.callCount).to.equal(0)

			update(2)

			expect(spy.callCount).to.equal(1)
			spy:assertCalledWith(2)

			disconnect()
			update(3)

			expect(spy.callCount).to.equal(1)
		end)
	end)

	describe("Mapped bindings", function()
		it("should be composable", function()
			local word, updateWord = Binding.create("hi")

			local wordLength = word:map(string.len)
			local isEvenLength = wordLength:map(function(value)
				return value % 2 == 0
			end)

			expect(word:getValue()).to.equal("hi")
			expect(wordLength:getValue()).to.equal(2)
			expect(isEvenLength:getValue()).to.equal(true)

			updateWord("sup")

			expect(word:getValue()).to.equal("sup")
			expect(wordLength:getValue()).to.equal(3)
			expect(isEvenLength:getValue()).to.equal(false)
		end)

		it("should cascade updates when subscribed", function()
			-- base binding
			local word, updateWord = Binding.create("hi")

			local wordSpy = createSpy()
			local disconnectWord = Binding.subscribe(word, wordSpy.value)

			-- binding -> base binding
			local length = word:map(string.len)

			local lengthSpy = createSpy()
			local disconnectLength = Binding.subscribe(length, lengthSpy.value)

			-- binding -> binding -> base binding
			local isEvenLength = length:map(function(value)
				return value % 2 == 0
			end)

			local isEvenLengthSpy = createSpy()
			local disconnectIsEvenLength = Binding.subscribe(isEvenLength, isEvenLengthSpy.value)

			expect(wordSpy.callCount).to.equal(0)
			expect(lengthSpy.callCount).to.equal(0)
			expect(isEvenLengthSpy.callCount).to.equal(0)

			updateWord("nice")

			expect(wordSpy.callCount).to.equal(1)
			wordSpy:assertCalledWith("nice")

			expect(lengthSpy.callCount).to.equal(1)
			lengthSpy:assertCalledWith(4)

			expect(isEvenLengthSpy.callCount).to.equal(1)
			isEvenLengthSpy:assertCalledWith(true)

			disconnectWord()
			disconnectLength()
			disconnectIsEvenLength()

			updateWord("goodbye")

			expect(wordSpy.callCount).to.equal(1)
			expect(isEvenLengthSpy.callCount).to.equal(1)
			expect(lengthSpy.callCount).to.equal(1)
		end)

		it("should throw when updated directly", function()
			local source = Binding.create(1)
			local mapped = source:map(function(v)
				return v
			end)

			expect(function()
				Binding.update(mapped, 5)
			end).to.throw()
		end)
	end)

	describe("Binding.join", function()
		it("should have getValue", function()
			local binding1 = Binding.create(1)
			local binding2 = Binding.create(2)
			local binding3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local bindingValue = joinedBinding:getValue()
			expect(bindingValue).to.be.a("table")
			expect(bindingValue[1]).to.equal(1)
			expect(bindingValue[2]).to.equal(2)
			expect(bindingValue.foo).to.equal(3)
		end)

		it("should update when any one of the subscribed bindings updates", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)
			local binding3, update3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local spy = createSpy()
			Binding.subscribe(joinedBinding, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			local args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(2)
			expect(args.value["foo"]).to.equal(3)

			update2(4)
			expect(spy.callCount).to.equal(2)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(3)

			update3(8)
			expect(spy.callCount).to.equal(3)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(8)
		end)

		it("should disconnect from all upstream bindings", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)

			local joined = Binding.join({binding1, binding2})

			local spy = createSpy()
			local disconnect = Binding.subscribe(joined, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			update2(3)
			expect(spy.callCount).to.equal(2)

			disconnect()
			update1(4)
			expect(spy.callCount).to.equal(2)

			update2(2)
			expect(spy.callCount).to.equal(2)

			local value = joined:getValue()
			expect(value[1]).to.equal(4)
			expect(value[2]).to.equal(2)
		end)

		it("should be okay with calling disconnect multiple times", function()
			local joined = Binding.join({})

			local disconnect = Binding.subscribe(joined, function() end)

			disconnect()
			disconnect()
		end)

		it("should throw if updated directly", function()
			local joined = Binding.join({})

			expect(function()
				Binding.update(joined, 0)
			end)
		end)

		it("should throw when a non-table value is passed", function()
			expect(function()
				Binding.join("hi")
			end).to.throw()
		end)

		it("should throw when a non-binding value is passed via table", function()
			expect(function()
				local binding = Binding.create(123)

				Binding.join({
					binding,
					"abcde",
				})
			end).to.throw()
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6487E9C7E8F44541A1AA2D09A87609B7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Component</string>
						<string name="ScriptGuid">{AC7C33C5-78C3-4F1E-943D-49E5F7111AA3}</string>
						<ProtectedString name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(("Property validation failed: %s\n\n%s"):format(
			tostring(failureReason),
			self:getElementTraceback() or "<enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.context)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
	end

	-- It's possible for init() to redefine _context!
	virtualNode.context = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEECE0823A3D8471580028C218AD0EB46">
					<Properties>
						<string name="Name">Component.spec</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX642A6993290C4637AE794CF4681B35BA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">context.spec</string>
							<string name="ScriptGuid">{70C532DF-1186-4A04-BED7-EFE02D371C2D}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be provided as a mutable self._context in Component:init", function()
		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.foo = "bar"
		end

		function Provider:render()
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Provider"
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			foo = "bar",
		}

		assertDeepEqual(node.context, expectedContext)
	end)

	it("should be inherited from parent stateful nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Parent = Component:extend("Parent")

		function Parent:render()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should be inherited from parent function nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local function Parent()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should contain values put into the tree by parent nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			return createElement(Consumer)
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Consumer"
		local context = {
			dont = "try it",
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		local initialContext = {
			dont = "try it",
		}

		local expectedContext = {
			dont = "try it",
			frob = "ulator",
		}

		-- Because components mutate context, we're careful with equality
		expect(node.context).never.to.equal(context)
		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)

		assertDeepEqual(context, initialContext)
		assertDeepEqual(node.context, expectedContext)
		assertDeepEqual(capturedContext, expectedContext)
	end)

	it("should transfer context to children that are replaced", function()
		local ConsumerA = Component:extend("ConsumerA")

		local capturedContextA
		function ConsumerA:init()
			self._context.A = "hello"

			capturedContextA = self._context
		end

		function ConsumerA:render()
		end

		local ConsumerB = Component:extend("ConsumerB")

		local capturedContextB
		function ConsumerB:init()
			self._context.B = "hello"

			capturedContextB = self._context
		end

		function ConsumerB:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			local useConsumerB = self.props.useConsumerB

			if useConsumerB then
				return createElement(ConsumerB)
			else
				return createElement(ConsumerA)
			end
		end

		local hostParent = nil
		local hostKey = "Consumer"

		local element = createElement(Provider)
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContextA = {
			frob = "ulator",
			A = "hello",
		}

		assertDeepEqual(capturedContextA, expectedContextA)

		local expectedContextB = {
			frob = "ulator",
			B = "hello",
		}

		local replacedElement = createElement(Provider, {
			useConsumerB = true,
		})
		noopReconciler.updateVirtualNode(node, replacedElement)

		assertDeepEqual(capturedContextB, expectedContextB)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX95983D1244D7482A953E7F495117137E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">defaultProps.spec</string>
							<string name="ScriptGuid">{4A7DA0E7-4F98-4CFC-8529-E33B58E03B02}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should fill in when mounting before init", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:init()
			capturedProps = self.props
		end

		function Foo:render()
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = initialProps.b,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should fill in when updating via props", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		local updatedProps = {
			c = 5,
		}
		local updatedElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, updatedElement)

		local expectedProps = {
			a = defaultProps.a,
			b = defaultProps.b,
			c = updatedProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should respect None to override a default prop with nil", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = None,
			c = 4,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = nil,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4686AA4F85814AE7882D2C7AF4C75634">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">didMount.spec</string>
							<string name="ScriptGuid">{931EB954-9F95-448C-BBAC-F01FC08A8C92}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local didMountSpy = createSpy()

		MyComponent.didMount = didMountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didMountSpy.callCount).to.equal(1)

		local values = didMountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX32D9E1A077394EE88CDAC12FC5A7EACD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">didUpdate.spec</string>
							<string name="ScriptGuid">{D359F8F7-B891-4230-8343-B664A054CD0D}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local virtualNode = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(virtualNode, newElement)

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, initialProps)
		assertDeepEqual(values.oldState, {})
	end)

	it("should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		local initialState = {
			a = 4,
		}

		local setState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)
		end

		function MyComponent:render()
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		setState({
			a = 5,
		})

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, {})
		assertDeepEqual(values.oldState, initialState)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2D64B08EFAB24226A6B852DEEAE6AC30">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">extend.spec</string>
							<string name="ScriptGuid">{0FB5C64D-29FE-4610-AA58-DCBDC3C2ABBB}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	it("should be extendable", function()
		local MyComponent = Component:extend("The Senate")

		expect(MyComponent).to.be.ok()
		expect(Type.of(MyComponent)).to.equal(Type.StatefulComponentClass)
	end)

	it("should prevent extending a user component", function()
		local MyComponent = Component:extend("Sheev")

		expect(function()
			MyComponent:extend("Frank")
		end).to.throw()
	end)

	it("should use a given name", function()
		local MyComponent = Component:extend("FooBar")

		local name = tostring(MyComponent)

		expect(name).to.be.a("string")
		expect(name:find("FooBar")).to.be.ok()
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX14E90AC4AD984A189DA81F1025586F54">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">getDerivedStateFromProps.spec</string>
							<string name="ScriptGuid">{3317F2A2-41BA-44E8-A1D6-3A03456C86EC}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.Parent.createSpy)
	local createElement = require(script.Parent.Parent.createElement)
	local createFragment = require(script.Parent.Parent.createFragment)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked on initial mount", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 1 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via props", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(createElement(WithDerivedState, {
			someProp = 1,
		}), hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, createElement(WithDerivedState, {
			someProp = 2,
		}))

		expect(getDerivedSpy.callCount).to.equal(2)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 2 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via state", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				someState = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState)
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, element, {
			someState = 2,
		})

		expect(getDerivedSpy.callCount).to.equal(3)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {})
		assertDeepEqual(values.state, { someState = 2 })
	end)

	it("should be invoked when updating via state in init (which skips reconciliation)", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				stateFromInit = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(2)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someProp = 1,
		})
		assertDeepEqual(values.state, {
			stateFromInit = 1,
		})
	end)

	it("should receive defaultProps", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.defaultProps = {
			someDefaultProp = "foo",
		}

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 1,
		})

		-- Update via props, confirm that defaultProp is still present
		element = createElement(WithDerivedState, {
			someProp = 2,
		})

		noopReconciler.updateVirtualNode(node, element)

		expect(getDerivedSpy.callCount).to.equal(2)

		values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 2,
		})
	end)

	it("should derive state for all setState updates, even when deferred", function()
		local Child = Component:extend("Child")
		local stateUpdaterSpy = createSpy(function()
			return {}
		end)
		local stateDerivedSpy = createSpy()

		function Child:render()
			return nil
		end

		function Child:didMount()
			self.props.callback()
		end

		local Parent = Component:extend("Parent")

		Parent.getDerivedStateFromProps = stateDerivedSpy.value

		function Parent:render()
			local callback = function()
				self:setState(stateUpdaterSpy.value)
			end

			return createFragment({
				ChildA = createElement(Child, {
					callback = callback,
				}),
				ChildB = createElement(Child, {
					callback = callback,
				}),
			})
		end

		local element = createElement(Parent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(stateUpdaterSpy.callCount).to.equal(2)

		-- getDerivedStateFromProps is always called on initial state
		expect(stateDerivedSpy.callCount).to.equal(3)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6D3B8E98D221480A8E43A2C5AC370EC4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">getElementTraceback.spec</string>
							<string name="ScriptGuid">{D4DE8CF8-CFD5-4BC4-932B-AC696B919545}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should return stack traces in initial renders", function()
		local TestComponent = Component:extend("TestComponent")

		local stackTrace
		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.be.a("string")
	end)

	itSKIP("it should return an updated stack trace after an update", function() end)

	it("should return nil when elementTracing is off", function()
		local stackTrace = nil

		local config = {
			elementTracing = false,
		}

		local TestComponent = Component:extend("TestComponent")

		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.equal(nil)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2832C056DED74FD5BBBC9234ACC0F0B9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init.spec</string>
							<string name="ScriptGuid">{45DCDA2F-2060-4751-A682-E4EDB38D17F5}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked with props when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local initSpy = createSpy()

		MyComponent.init = initSpy.value

		function MyComponent:render()
			return nil
		end

		local props = {
			a = 5,
		}
		local element = createElement(MyComponent, props)
		local hostParent = nil
		local key = "Some Component Key"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(initSpy.callCount).to.equal(1)

		local values = initSpy:captureValues("self", "props")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		expect(typeof(values.props)).to.equal("table")
		assertDeepEqual(values.props, props)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF1CA257A3CBF4FD28927D8CD16BBC1A0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">render.spec</string>
							<string name="ScriptGuid">{6FE7ED23-D7E1-46F2-8732-5473E95D9A0D}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should throw on mount if not overridden", function()
		local MyComponent = Component:extend("MyComponent")

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local success, result = pcall(function()
			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(success).to.equal(false)
		expect(result:match("MyComponent")).to.be.ok()
		expect(result:match("render")).to.be.ok()
	end)

	it("should be invoked when a component is mounted", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(capturedProps, {})
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when a component is updated via props", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local initialProps = {
			a = 2,
		}
		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Foo Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(firstProps, initialProps)
		assertDeepEqual(firstState, {})

		local updatedProps = {
			a = 3,
		}
		local newElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)

		local secondRenderArguments = renderSpy:captureValues("self")
		local secondProps = capturedProps
		local secondState = capturedState

		expect(Type.of(secondRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(secondProps).never.to.equal(firstProps)
		assertDeepEqual(secondProps, updatedProps)
		expect(secondState).to.equal(firstState)
	end)

	it("should be invoked when a component is updated via state", function()
		local Foo = Component:extend("Foo")

		local setState
		function Foo:init()
			setState = function(...)
				return self:setState(...)
			end
		end

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)

		setState({})

		expect(renderSpy.callCount).to.equal(2)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(capturedProps).to.equal(firstProps)
		expect(capturedState).never.to.equal(firstState)
	end)

	itSKIP("Test defaultProps on initial render", function() end)
	itSKIP("Test defaultProps on prop update", function() end)
	itSKIP("Test defaultProps on state update", function() end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX48AB55DB78C64897B9643584C6B7D980">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">setState.spec</string>
							<string name="ScriptGuid">{5CC71E5B-5B54-407E-90B7-727CE83111F6}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("setState", function()
		it("should not trigger an extra update when called in init", function()
			local renderCount = 0
			local updateCount = 0
			local capturedState

			local InitComponent = Component:extend("InitComponent")

			function InitComponent:init()
				self:setState({
					a = 1
				})
			end

			function InitComponent:willUpdate()
				updateCount = updateCount + 1
			end

			function InitComponent:render()
				renderCount = renderCount + 1
				capturedState = self.state
				return nil
			end

			local initElement = createElement(InitComponent)

			noopReconciler.mountVirtualTree(initElement)

			expect(renderCount).to.equal(1)
			expect(updateCount).to.equal(0)
			expect(capturedState.a).to.equal(1)
		end)

		it("should throw when called in render", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				self:setState({
					a = 1
				})
			end

			local renderElement = createElement(TestComponent)

			local success, result = pcall(noopReconciler.mountVirtualTree, renderElement)

			expect(success).to.equal(false)
			expect(result:match("render")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in shouldUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:shouldUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)

			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("shouldUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("willUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUnmount", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUnmount()
				self:setState({
					a = 1
				})
			end

			local element = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(element)

			local success, result = pcall(noopReconciler.unmountVirtualTree, tree)

			expect(success).to.equal(false)
			expect(result:match("willUnmount")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should remove values from state when the value is None", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback({
				value = None
			})

			expect(getStateCallback().value).to.equal(nil)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should invoke functions to compute a partial state", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback, getPropsCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				getPropsCallback = function()
					return self.props
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback(function(state, props)
				expect(state).to.equal(getStateCallback())
				expect(props).to.equal(getPropsCallback())

				return {
					value = state.value + 1
				}
			end)

			expect(getStateCallback().value).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should cancel rendering if the function returns nil", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback
			local renderCount = 0

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")
			expect(renderCount).to.equal(1)

			setStateCallback(function(state, props)
				return nil
			end)

			expect(renderCount).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)
	end)

	describe("setState suspension", function()
		it("should defer setState triggered while reconciling", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						self:setState({
							foo = "bar"
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")
		end)

		it("should defer setState triggered while reconciling during an update", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didUpdate()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						-- This guards against a stack overflow that would be OUR fault
						if not self.state.foo then
							self:setState({
								foo = "bar"
							})
						end
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(nil)

			result = noopReconciler.updateVirtualNode(result, createElement(Parent))

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should combine pending state changes properly", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback("foo", 1)
				self.props.callback("bar", 3)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(key, value)
						self:setState({
							[key] = value,
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)
			expect(getParentStateCallback().bar).to.equal(3)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should abort properly when functional setState returns nil while deferred", function()
			local Child = Component:extend("Child")

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			local renderSpy = createSpy(function(self)
				return createElement(Child, {
					callback = function()
						self:setState(function()
							-- abort the setState
							return nil
						end)
					end,
				})
			end)

			Parent.render = renderSpy.value

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(renderSpy.callCount).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should still apply pending state if a subsequent state update was aborted", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback(function()
					return {
						foo = 1,
					}
				end)
				self.props.callback(function()
					return nil
				end)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(stateUpdater)
						self:setState(stateUpdater)
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should not re-process new state when pending state is present after update", function()
			local setComponentState
			local getComponentState

			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					hasUpdatedOnce = false,
					counter = 0,
				})

				setComponentState = function(mapState)
					self:setState(mapState)
				end

				getComponentState = function()
					return self.state
				end
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didUpdate()
				if self.state.hasUpdatedOnce == false then
					self:setState({
						hasUpdatedOnce = true,
					})
				end
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(getComponentState().hasUpdatedOnce).to.equal(false)
			expect(getComponentState().counter).to.equal(0)

			setComponentState(function(state)
				return {
					counter = state.counter + 1
				}
			end)

			expect(getComponentState().hasUpdatedOnce).to.equal(true)
			expect(getComponentState().counter).to.equal(1)
		end)

		it("should throw when an infinite update is triggered", function()
			local InfiniteUpdater = Component:extend("InfiniteUpdater")

			function InfiniteUpdater:render()
				return nil
			end

			function InfiniteUpdater:didMount()
				self:setState({})
			end

			function InfiniteUpdater:didUpdate()
				self:setState({})
			end

			local element = createElement(InfiniteUpdater)
			local hostParent = nil
			local key = "Test"

			local success, result = pcall(noopReconciler.mountVirtualNode, element, hostParent, key)

			expect(success).to.equal(false)
			expect(result:find("InfiniteUpdater")).to.be.ok()
			expect(result:find("reached the setState update recursion limit")).to.be.ok()
		end)

		itSKIP("should process single updates with both new and pending state", function()
			--[[
				This situation shouldn't be possible currently, but the implementation
				should support it for future update de-duplication
			]]
		end)

		it("should call trigger update after didMount when setting state in didMount", function()
			--[[
				Before setState suspension, it was possible to call setState in didMount but it would
				not actually finish resolving didMount until after the entire update.

				This is theoretically problematic, as it means that lifecycle methods like didUpdate
				could be called before didMount is finished. setState suspension resolves this by
				suspending state updates made in didMount and didUpdate as well as reconciliation
			]]
			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					status = "initial mount"
				})

				self.isMounted = false
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didMount()
				self:setState({
					status = "mounted"
				})

				self.isMounted = true
			end

			function MyComponent:didUpdate(oldProps, oldState)
				expect(oldState.status).to.equal("initial mount")
				expect(self.state.status).to.equal("mounted")

				expect(self.isMounted).to.equal(true)
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
		end)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD12598E1653C470B9ABD3C2A021C5038">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">shouldUpdate.spec</string>
							<string name="ScriptGuid">{764697DE-09AE-453C-B724-FC064B5119D2}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when props update", function()
		local MyComponent = Component:extend("MyComponent")

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		assertDeepEqual(values.newProps, newProps)

		assertDeepEqual(capturedProps, initialProps)

		expect(values.newState).to.equal(capturedState)
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when state is updated", function()
		local MyComponent = Component:extend("MyComponent")

		local initialState = {
			a = 1,
		}

		local setState
		local initState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)

			initState = self.state
		end

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newState = {
			a = 2,
			b = 3,
		}

		setState(newState)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		expect(values.newProps).to.equal(capturedProps)
		assertDeepEqual(capturedProps, {})

		assertDeepEqual(capturedState, initialState)
		expect(capturedState).to.equal(initState)
		assertDeepEqual(values.newState, newState)
	end)

	it("should not abort an update when returning true", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return true
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)
	end)

	it("should abort an update when retuning false", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return false
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(1)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0CA894A85CEC4827BD1C4030433282A7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">validateProps.spec</string>
							<string name="ScriptGuid">{67CE3E6D-D6BC-4758-B061-1CB58BC29273}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should be invoked when props change", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
			})
		end)
	end)

	it("should not be invoked when state changes", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local setStateCallback = nil
			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1
			})

			setStateCallback({
				b = 1
			})

			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should throw if validateProps is not a function", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = 1

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should throw if validateProps returns false", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = function()
				return false
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should be invoked after defaultProps are applied", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			MyComponent.defaultProps = {
				b = 2,
			}

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
				b = 2,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
				b = 2,
			})
		end)
	end)

	it("should not be invoked if the flag is off", function()
		local config = {
			propValidation = false,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(0)

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(0)
		end)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX756671F8B6EE40DB96B0461CDB3B7B92">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">willUnmount.spec</string>
							<string name="ScriptGuid">{9A44D5BC-4DFB-4541-992F-372ABC6728EF}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when unmounted", function()
		local MyComponent = Component:extend("MyComponent")

		local willUnmountSpy = createSpy()

		MyComponent.willUnmount = willUnmountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)
		noopReconciler.unmountVirtualNode(node)

		expect(willUnmountSpy.callCount).to.equal(1)

		local values = willUnmountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3E14AE0AEE6C4BBCA50DD180CAE1B729">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">willUpdate.spec</string>
							<string name="ScriptGuid">{24563967-84A4-4B82-A1AF-7BFE55A39C3D}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, newProps)
		assertDeepEqual(values.newState, {})
	end)

	it("it should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")
		local setComponentState

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:init()
			setComponentState = function(state)
				self:setState(state)
			end

			self:setState({
				foo = 1
			})
		end

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(willUpdateSpy.callCount).to.equal(0)

		setComponentState({
			foo = 2
		})

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, {})
		assertDeepEqual(values.newState, {
			foo = 2
		})
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX3BB2D52BAF7C49B78E920473E7552438">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ComponentLifecyclePhase</string>
						<string name="ScriptGuid">{CB3D74CD-3863-4EB6-8F5D-49C30FDBC07E}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE50D43079F4447C4951C3B6970087306">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Config</string>
						<string name="ScriptGuid">{4EB4CBA3-E867-4E7B-AB2D-E63AF3DF0984}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX83F7CCC516A844A0A36E2CF2705B858D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Config.spec</string>
						<string name="ScriptGuid">{18CA4956-5A71-4BE9-B63B-2DBB0F9C8BDB}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Config = require(script.Parent.Config)

	it("should accept valid configuration", function()
		local config = Config.new()
		local values = config.get()

		expect(values.elementTracing).to.equal(false)

		config.set({
			elementTracing = true,
		})

		expect(values.elementTracing).to.equal(true)
	end)

	it("should reject invalid configuration keys", function()
		local config = Config.new()

		local badKey = "garblegoop"

		local ok, err = pcall(function()
			config.set({
				[badKey] = true,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention our bad key somewhere.
		expect(err:find(badKey)).to.be.ok()
	end)

	it("should reject invalid configuration values", function()
		local config = Config.new()

		local goodKey = "elementTracing"
		local badValue = "Hello there!"

		local ok, err = pcall(function()
			config.set({
				[goodKey] = badValue,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention both our key and value
		expect(err:find(goodKey)).to.be.ok()
		expect(err:find(badValue)).to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX63C05BF270474FD78113BE94251FCB22">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ElementKind</string>
						<string name="ScriptGuid">{96A5CB8D-279F-4669-934B-D493BEEA5839}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF12B5FAC52874AC286D9AD69047D9B6C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ElementKind.spec</string>
						<string name="ScriptGuid">{080D5DC4-7373-4BEC-973B-A2EBF484D2A0}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Portal = require(script.Parent.Portal)
	local Component = require(script.Parent.Component)

	local ElementKind = require(script.Parent.ElementKind)

	describe("of", function()
		it("should return nil for non-table values", function()
			expect(ElementKind.of(nil)).to.equal(nil)
			expect(ElementKind.of(5)).to.equal(nil)
			expect(ElementKind.of(newproxy(true))).to.equal(nil)
		end)

		it("should return nil for table values without an ElementKind key", function()
			expect(ElementKind.of({})).to.equal(nil)
		end)

		it("should return the ElementKind from a table", function()
			local value = {
				[ElementKind] = ElementKind.Stateful,
			}

			expect(ElementKind.of(value)).to.equal(ElementKind.Stateful)
		end)
	end)

	describe("fromComponent", function()
		it("should handle host components", function()
			expect(ElementKind.fromComponent("foo")).to.equal(ElementKind.Host)
		end)

		it("should handle function components", function()
			local function foo()
			end

			expect(ElementKind.fromComponent(foo)).to.equal(ElementKind.Function)
		end)

		it("should handle stateful components", function()
			local Foo = Component:extend("Foo")

			expect(ElementKind.fromComponent(Foo)).to.equal(ElementKind.Stateful)
		end)

		it("should handle portals", function()
			expect(ElementKind.fromComponent(Portal)).to.equal(ElementKind.Portal)
		end)

		it("should return nil for invalid inputs", function()
			expect(ElementKind.fromComponent(5)).to.equal(nil)
			expect(ElementKind.fromComponent(newproxy(true))).to.equal(nil)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX98CA57043C86453EAB52BDC0B2FB7B52">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ElementUtils</string>
						<string name="ScriptGuid">{43ABE2AB-34E9-416F-98D4-F46260DF1F2C}</string>
						<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX587A945BE0694D99907A0FCD008BB546">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ElementUtils.spec</string>
						<string name="ScriptGuid">{3614CD96-2742-447F-8728-91E34DE9125B}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local ElementUtils = require(script.Parent.ElementUtils)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local Type = require(script.Parent.Type)

	describe("iterateElements", function()
		it("should iterate once for a single child", function()
			local child = createElement("TextLabel")
			local iterator = ElementUtils.iterateElements(child)
			local iteratedKey, iteratedChild = iterator()
			-- For single elements, the key should be UseParentKey
			expect(iteratedKey).to.equal(ElementUtils.UseParentKey)
			expect(iteratedChild).to.equal(child)

			iteratedKey = iterator()
			expect(iteratedKey).to.equal(nil)
		end)

		it("should iterate over tables", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			local seenChildren = {}
			local count = 0

			for key, child in ElementUtils.iterateElements(children) do
				expect(typeof(key)).to.equal("string")
				expect(Type.of(child)).to.equal(Type.Element)
				seenChildren[child] = key
				count = count + 1
			end

			expect(count).to.equal(2)
			expect(seenChildren[children.a]).to.equal("a")
			expect(seenChildren[children.b]).to.equal("b")
		end)

		it("should return a zero-element iterator for booleans", function()
			local booleanIterator = ElementUtils.iterateElements(false)
			expect(booleanIterator()).to.equal(nil)
		end)

		it("should return a zero-element iterator for nil", function()
			local nilIterator = ElementUtils.iterateElements(nil)
			expect(nilIterator()).to.equal(nil)
		end)

		it("should throw if given an illegal value", function()
			expect(function()
				ElementUtils.iterateElements(1)
			end).to.throw()
		end)
	end)

	describe("getElementByKey", function()
		it("should return nil for booleans", function()
			expect(ElementUtils.getElementByKey(true, "test")).to.equal(nil)
		end)

		it("should return nil for nil", function()
			expect(ElementUtils.getElementByKey(nil, "test")).to.equal(nil)
		end)

		describe("single elements", function()
			local element = createElement("TextLabel")

			it("should return the element if the key is UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, ElementUtils.UseParentKey)).to.equal(element)
			end)

			it("should return nil if the key is not UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, "test")).to.equal(nil)
			end)
		end)

		it("should return the corresponding element from a table", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(children.a)
			expect(ElementUtils.getElementByKey(children, "b")).to.equal(children.b)
		end)

		it("should return nil if the key does not exist", function()
			local children = createFragment({})

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(nil)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7D5A815B83744B1CA0776E8886721EF4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GlobalConfig</string>
						<string name="ScriptGuid">{0A96B3F0-B17A-4D55-A6DB-CB499213C665}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3E834A15342F41EBBC812E029413500F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GlobalConfig.spec</string>
						<string name="ScriptGuid">{471861DF-DFA8-460A-B067-9DBEDD1DDC00}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local GlobalConfig = require(script.Parent.GlobalConfig)

	it("should have the correct methods", function()
		expect(GlobalConfig).to.be.ok()
		expect(GlobalConfig.set).to.be.ok()
		expect(GlobalConfig.get).to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFC1BB7455F36420EAA411DD619D05632">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Logging</string>
						<string name="ScriptGuid">{C798BB51-D657-4FEB-AFA5-B52DACBD4063}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX73A4B011EA1B436FA195BDBF95EB348D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">None</string>
						<string name="ScriptGuid">{30226F99-C64D-4B14-AF4A-28C65C2A84FF}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX282CF6FC41E74EE5B9B592340C0B7080">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NoopRenderer</string>
						<string name="ScriptGuid">{C61AB178-03D8-4630-BB72-F8F6017D5210}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC4153DA883E74BCFB775B9B40A9551FE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Portal</string>
						<string name="ScriptGuid">{FDCF23AE-197A-42F4-AE67-4661EDF9A500}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXA9EA5BB844F142BAB9D3465C4B3C2230">
					<Properties>
						<string name="Name">PropMarkers</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3D0269306E1B4696ABA96597F228EE70">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Change</string>
							<string name="ScriptGuid">{F51F1F71-CC38-4B30-A045-685D13FD4DF3}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEA0F57B9E1E040428262915B8593C0E5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Change.spec</string>
							<string name="ScriptGuid">{4775534D-3041-42E0-AB48-972B821585DC}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Change = require(script.Parent.Change)

	it("should yield change listener objects when indexed", function()
		expect(Type.of(Change.Text)).to.equal(Type.HostChangeEvent)
		expect(Type.of(Change.Selected)).to.equal(Type.HostChangeEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Change.Text
		local b = Change.Text
		local c = Change.Selected

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX03A625DB2357445CA79658AB65DC27DD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Children</string>
							<string name="ScriptGuid">{365A3E7F-F66C-4946-8B86-114152DD221B}</string>
							<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE9E278E48B864A3D91F59D05A1AECB22">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Event</string>
							<string name="ScriptGuid">{7A0EFE34-5EC6-4A52-8E0D-82CB2C7846A1}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end
})

return Event]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3FED2BE2AA2A41A1829EDABACD9436DE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Event.spec</string>
							<string name="ScriptGuid">{BFCDB859-4C36-4D50-9A14-A15EBA1A0154}</string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Event = require(script.Parent.Event)

	it("should yield event objects when indexed", function()
		expect(Type.of(Event.MouseButton1Click)).to.equal(Type.HostEvent)
		expect(Type.of(Event.Touched)).to.equal(Type.HostEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Event.MouseButton1Click
		local b = Event.MouseButton1Click
		local c = Event.Touched

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2549F9490B9A4A8183F774DC663BA53F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Ref</string>
							<string name="ScriptGuid">{C2EDA07C-8ACC-4647-BE29-A1D183507E2F}</string>
							<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX92C80B42492446C8AEBC2232181A7658">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PureComponent</string>
						<string name="ScriptGuid">{F9572383-B4D5-4935-BAFF-53C1DEAD8805}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD986EC262A464BABB9599D19F46F8BF5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PureComponent.spec</string>
						<string name="ScriptGuid">{E7790C3E-BA35-4A2B-A42A-7B47061B83C0}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local createReconciler = require(script.Parent.createReconciler)

	local PureComponent = require(script.Parent.PureComponent)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be extendable", function()
		local MyComponent = PureComponent:extend("MyComponent")

		expect(MyComponent).to.be.ok()
	end)

	it("should skip updates for shallow-equal props", function()
		local updateCount = 0
		local setValue

		local PureChild = PureComponent:extend("PureChild")

		function PureChild:willUpdate()
			updateCount = updateCount + 1
		end

		function PureChild:render()
			return nil
		end

		local PureContainer = PureComponent:extend("PureContainer")

		function PureContainer:init()
			self.state = {
				value = 0,
			}
		end

		function PureContainer:didMount()
			setValue = function(value)
				self:setState({
					value = value,
				})
			end
		end

		function PureContainer:render()
			return createElement(PureChild, {
				value = self.state.value,
			})
		end

		local element = createElement(PureContainer)
		local tree = noopReconciler.mountVirtualTree(element, nil, "PureComponent Tree")

		expect(updateCount).to.equal(0)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(2)

		expect(updateCount).to.equal(2)

		setValue(1)

		expect(updateCount).to.equal(3)

		noopReconciler.unmountVirtualTree(tree)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7F81A6A99ADC4727851582F348BE4022">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RobloxRenderer</string>
						<string name="ScriptGuid">{B1D1F2B2-74B6-4C0E-99FB-316551E15E88}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9796F5AA0DAA487A812820B01F95694A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RobloxRenderer.spec</string>
						<string name="ScriptGuid">{C0FDECC6-4579-4F7D-B003-E9A3F2EFB2DF}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local Binding = require(script.Parent.Binding)
	local Children = require(script.Parent.PropMarkers.Children)
	local Component = require(script.Parent.Component)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createReconciler = require(script.Parent.createReconciler)
	local createRef = require(script.Parent.createRef)
	local createSpy = require(script.Parent.createSpy)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Portal = require(script.Parent.Portal)
	local Ref = require(script.Parent.PropMarkers.Ref)

	local RobloxRenderer = require(script.Parent.RobloxRenderer)

	local reconciler = createReconciler(RobloxRenderer)

	describe("mountHostNode", function()
		it("should create instances with correct props", function()
			local parent = Instance.new("Folder")
			local value = "Hello!"
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(value)
			expect(root.Name).to.equal(key)
		end)

		it("should create children with correct names and props", function()
			local parent = Instance.new("Folder")
			local rootValue = "Hey there!"
			local childValue = 173
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = rootValue,
			}, {
				ChildA = createElement("IntValue", {
					Value = childValue,
				}),

				ChildB = createElement("Folder"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(rootValue)
			expect(root.Name).to.equal(key)

			expect(#root:GetChildren()).to.equal(2)

			local childA = root.ChildA
			local childB = root.ChildB

			expect(childA).to.be.ok()
			expect(childB).to.be.ok()

			expect(childA.ClassName).to.equal("IntValue")
			expect(childA.Value).to.equal(childValue)

			expect(childB.ClassName).to.equal("Folder")
		end)

		it("should attach Bindings to Roblox properties", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(instance.ClassName).to.equal("IntValue")
			expect(instance.Value).to.equal(10)

			update(20)

			expect(instance.Value).to.equal(20)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should connect Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(ref.current).to.be.ok()
			expect(ref.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call function refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local element = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(element, parent, key)

				local success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)
	end)

	describe("updateHostNode", function()
		it("should update node props and children", function()
			-- TODO: Break up test

			local parent = Instance.new("Folder")
			local key = "updateHostNodeTest"
			local firstValue = "foo"
			local newValue = "bar"

			local defaultStringValue = Instance.new("StringValue").Value

			local element = createElement("StringValue", {
				Value = firstValue
			}, {
				ChildA = createElement("IntValue", {
					Value = 1
				}),
				ChildB = createElement("BoolValue", {
					Value = true,
				}),
				ChildC = createElement("StringValue", {
					Value = "test",
				}),
				ChildD = createElement("StringValue", {
					Value = "test",
				})
			})

			local node = reconciler.createVirtualNode(element, parent, key)
			RobloxRenderer.mountHostNode(reconciler, node)

			-- Not testing mountHostNode's work here, only testing that the
			-- node is properly updated.

			local newElement = createElement("StringValue", {
				Value = newValue,
			}, {
				-- ChildA changes element type.
				ChildA = createElement("StringValue", {
					Value = "test"
				}),
				-- ChildB changes child properties.
				ChildB = createElement("BoolValue", {
					Value = false,
				}),
				-- ChildC should reset its Value property back to the default.
				ChildC = createElement("StringValue", {}),
				-- ChildD is deleted.
				-- ChildE is added.
				ChildE = createElement("Folder", {}),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			local root = parent[key]
			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(newValue)
			expect(#root:GetChildren()).to.equal(4)

			local childA = root.ChildA
			expect(childA.ClassName).to.equal("StringValue")
			expect(childA.Value).to.equal("test")

			local childB = root.ChildB
			expect(childB.ClassName).to.equal("BoolValue")
			expect(childB.Value).to.equal(false)

			local childC = root.ChildC
			expect(childC.ClassName).to.equal("StringValue")
			expect(childC.Value).to.equal(defaultStringValue)

			local childE = root.ChildE
			expect(childE.ClassName).to.equal("Folder")
		end)

		it("should update Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local bindingA, updateA = Binding.create(10)
			local element = createElement("IntValue", {
				Value = bindingA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			local bindingB, updateB = Binding.create(99)
			local newElement = createElement("IntValue", {
				Value = bindingB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(instance.Value).to.equal(99)

			updateA(123)

			expect(instance.Value).to.equal(99)

			updateB(123)

			expect(instance.Value).to.equal(123)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should update Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local refA = createRef()
			local refB = createRef()

			local element = createElement("Frame", {
				[Ref] = refA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(refA.current).to.equal(instance)
			expect(refB.current).never.to.be.ok()

			local newElement = createElement("Frame", {
				[Ref] = refB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(refA.current).never.to.be.ok()
			expect(refB.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call old function refs with nil and new function refs with a valid rbx", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRefA = createSpy()
			local spyRefB = createSpy()

			local element = createElement("Frame", {
				[Ref] = spyRefA.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRefA.callCount).to.equal(1)
			spyRefA:assertCalledWith(instance)
			expect(spyRefB.callCount).to.equal(0)

			local newElement = createElement("Frame", {
				[Ref] = spyRefB.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(spyRefA.callCount).to.equal(2)
			spyRefA:assertCalledWith(nil)
			expect(spyRefB.callCount).to.equal(1)
			spyRefB:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should not call function refs again if they didn't change", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
				[Ref] = spyRef.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			-- Not called again
			expect(spyRef.callCount).to.equal(1)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local firstElement = createElement("Frame")
				local secondElement = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(firstElement, parent, key)
				RobloxRenderer.mountHostNode(reconciler, node)

				local success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)

		it("should delete instances when reconciling to nil children", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
			}, {
				child = createElement("Frame"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]
			expect(#instance:GetChildren()).to.equal(1)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)
			expect(#instance:GetChildren()).to.equal(0)
		end)
	end)

	describe("unmountHostNode", function()
		it("should delete instances from the inside-out", function()
			local parent = Instance.new("Folder")
			local key = "Root"
			local element = createElement("Folder", nil, {
				Child = createElement("Folder", nil, {
					Grandchild = createElement("Folder"),
				}),
			})

			local node = reconciler.mountVirtualNode(element, parent, key)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]
			expect(#root:GetChildren()).to.equal(1)

			local child = root:GetChildren()[1]
			expect(#child:GetChildren()).to.equal(1)

			local grandchild = child:GetChildren()[1]

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(grandchild.Parent).to.equal(nil)
			expect(child.Parent).to.equal(nil)
			expect(root.Parent).to.equal(nil)
		end)

		it("should unsubscribe from any Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			RobloxRenderer.unmountHostNode(reconciler, node)
			update(56)

			expect(instance.Value).to.equal(10)
		end)

		it("should clear Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(ref.current).to.be.ok()

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(ref.current).never.to.be.ok()
		end)

		it("should call function refs with nil", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(1)

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(2)
			spyRef:assertCalledWith(nil)
		end)
	end)

	describe("Portals", function()
		it("should create and destroy instances as children of `target`", function()
			local target = Instance.new("Folder")

			local function FunctionComponent(props)
				return createElement("IntValue", {
					Value = props.value,
				})
			end

			local element = createElement(Portal, {
				target = target,
			}, {
				folderOne = createElement("Folder"),
				folderTwo = createElement("Folder"),
				intValueOne = createElement(FunctionComponent, {
					value = 42,
				}),
			})
			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(3)

			expect(target:FindFirstChild("folderOne")).to.be.ok()
			expect(target:FindFirstChild("folderTwo")).to.be.ok()
			expect(target:FindFirstChild("intValueOne")).to.be.ok()
			expect(target:FindFirstChild("intValueOne").Value).to.equal(42)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should pass prop updates through to children", function()
			local target = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "A Host Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(1)

			local firstValue = target.ChildValue
			expect(firstValue.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#target:GetChildren()).to.equal(1)

			local secondValue = target.ChildValue
			expect(firstValue).to.equal(secondValue)
			expect(secondValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should throw if `target` is nil", function()
			-- TODO: Relax this restriction?
			local element = createElement(Portal)
			local hostParent = nil
			local hostKey = "Keys for Everyone"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should throw if `target` is not a Roblox instance", function()
			local element = createElement(Portal, {
				target = {},
			})
			local hostParent = nil
			local hostKey = "Unleash the keys!"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should recreate instances if `target` changes in an update", function()
			local firstTarget = Instance.new("Folder")
			local secondTarget = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = firstTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = secondTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#firstTarget:GetChildren()).to.equal(1)
			expect(#secondTarget:GetChildren()).to.equal(0)

			local firstChild = firstTarget.ChildValue
			expect(firstChild.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(1)

			local secondChild = secondTarget.ChildValue
			expect(secondChild.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(0)
		end)
	end)

	describe("Fragments", function()
		it("should parent the fragment's elements into the fragment's parent", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createElement("IntValue", {
					Value = 1,
				}),
				key2 = createElement("IntValue", {
					Value = 2,
				}),
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "test")

			expect(hostParent:FindFirstChild("key")).to.be.ok()
			expect(hostParent.key.ClassName).to.equal("IntValue")
			expect(hostParent.key.Value).to.equal(1)

			expect(hostParent:FindFirstChild("key2")).to.be.ok()
			expect(hostParent.key2.ClassName).to.equal("IntValue")
			expect(hostParent.key2.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should allow sibling fragment to have common keys", function()
			local hostParent = Instance.new("Folder")
			local hostKey = "Test"

			local function parent(props)
				return createElement("IntValue", {}, {
					fragmentA = createFragment({
						key = createElement("StringValue", {
							Value = "A",
						}),
						key2 = createElement("StringValue", {
							Value = "B",
						}),
					}),
					fragmentB = createFragment({
						key = createElement("StringValue", {
							Value = "C",
						}),
						key2 = createElement("StringValue", {
							Value = "D",
						}),
					}),
				})
			end

			local node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)
			local parentChildren = hostParent[hostKey]:GetChildren()

			expect(#parentChildren).to.equal(4)

			local childValues = {}

			for _, child in pairs(parentChildren) do
				expect(child.ClassName).to.equal("StringValue")
				childValues[child.Value] = 1 + (childValues[child.Value] or 0)
			end

			-- check if the StringValues have not collided
			expect(childValues.A).to.equal(1)
			expect(childValues.B).to.equal(1)
			expect(childValues.C).to.equal(1)
			expect(childValues.D).to.equal(1)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should render nested fragments", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createFragment({
					TheValue = createElement("IntValue", {
						Value = 1,
					}),
					TheOtherValue = createElement("IntValue", {
						Value = 2,
					})
				})
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "Test")

			expect(hostParent:FindFirstChild("TheValue")).to.be.ok()
			expect(hostParent.TheValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheValue.Value).to.equal(1)

			expect(hostParent:FindFirstChild("TheOtherValue")).to.be.ok()
			expect(hostParent.TheOtherValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheOtherValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should not add any instances if the fragment is empty", function()
			local hostParent = Instance.new("Folder")

			local node = reconciler.mountVirtualNode(createFragment({}), hostParent, "test")

			expect(#hostParent:GetChildren()).to.equal(0)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)
	end)

	describe("Context", function()
		it("should pass context values through Roblox host nodes", function()
			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
			end

			local element = createElement("Folder", nil, {
				Consumer = createElement(Consumer)
			})
			local hostParent = nil
			local hostKey = "Context Test"
			local context = {
				hello = "world",
			}
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)

			expect(capturedContext).never.to.equal(context)
			assertDeepEqual(capturedContext, context)

			reconciler.unmountVirtualNode(node)
		end)

		it("should pass context values through portal nodes", function()
			local target = Instance.new("Folder")

			local Provider = Component:extend("Provider")

			function Provider:init()
				self._context.foo = "bar"
			end

			function Provider:render()
				return createElement("Folder", nil, self.props[Children])
			end

			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
				return nil
			end

			local element = createElement(Provider, nil, {
				Portal = createElement(Portal, {
					target = target,
				}, {
					Consumer = createElement(Consumer),
				})
			})
			local hostParent = nil
			local hostKey = "Some Key"
			reconciler.mountVirtualNode(element, hostParent, hostKey)

			assertDeepEqual(capturedContext, {
				foo = "bar"
			})
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE4BE3F780275436186C56F89C9008273">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SingleEventManager</string>
						<string name="ScriptGuid">{C36D4828-598C-485A-9ACF-21A84D09DA56}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local event = self._instance:GetPropertyChangedSignal(key)
	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFA5D19D1EA654465BC21A395853E9F18">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SingleEventManager.spec</string>
						<string name="ScriptGuid">{ED3FBEF9-019F-4930-A6FF-0CABB6CE542D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.createSpy)
	local Logging = require(script.Parent.Logging)

	local SingleEventManager = require(script.Parent.SingleEventManager)

	describe("new", function()
		it("should create a SingleEventManager", function()
			local manager = SingleEventManager.new()

			expect(manager).to.be.ok()
		end)
	end)

	describe("connectEvent", function()
		it("should connect to events", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")

			manager:connectEvent("Event", nil)

			instance:Fire("baz")
			expect(eventSpy.callCount).to.equal(2)
		end)

		it("should drop events until resumed initially", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(0)

			manager:resume()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke suspended events when resumed", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			manager:suspend()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)

			manager:resume()
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke events triggered during resumption in the correct order", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			local recordedValues = {}
			local eventSpy = createSpy(function(_, value)
				table.insert(recordedValues, value)

				if value == 2 then
					instance:Fire(3)
				elseif value == 3 then
					instance:Fire(4)
				end
			end)

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)
			instance:Fire(2)

			manager:resume()
			expect(eventSpy.callCount).to.equal(4)
			assertDeepEqual(recordedValues, {1, 2, 3, 4})
		end)

		it("should not invoke events fired during suspension but disconnected before resumption", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)

			manager:connectEvent("Event", nil)

			manager:resume()
			expect(eventSpy.callCount).to.equal(0)
		end)

		it("should not yield events through the SingleEventManager when resuming", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				coroutine.yield()
			end)

			manager:resume()

			local co = coroutine.create(function()
				instance:Fire(5)
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")

			manager:suspend()
			instance:Fire(5)

			co = coroutine.create(function()
				manager:resume()
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")
		end)

		it("should not throw errors through SingleEventManager when resuming", function()
			local errorText = "Error from SingleEventManager test"

			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				error(errorText)
			end)

			manager:resume()

			-- If we call instance:Fire() here, the error message will leak to
			-- the console since the thread's resumption will be handled by
			-- Roblox's scheduler.

			manager:suspend()
			instance:Fire(5)

			local logInfo = Logging.capture(function()
				manager:resume()
			end)

			expect(#logInfo.errors).to.equal(0)
			expect(#logInfo.warnings).to.equal(1)
			expect(#logInfo.infos).to.equal(0)

			expect(logInfo.warnings[1]:find(errorText)).to.be.ok()
		end)

		it("should not overflow with events if manager:resume() is invoked when resuming a suspended event", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			-- This connection emulates what happens if reconciliation is
			-- triggered again in response to reconciliation. Without
			-- appropriate guards, the inner resume() call will process the
			-- Fire(1) event again, causing a nasty stack overflow.
			local eventSpy = createSpy(function(_, value)
				if value == 1 then
					manager:suspend()
					instance:Fire(2)
					manager:resume()
				end
			end)

			manager:connectEvent("Event", eventSpy.value)

			manager:suspend()
			instance:Fire(1)
			manager:resume()

			expect(eventSpy.callCount).to.equal(2)
		end)
	end)

	describe("connectPropertyChange", function()
		-- Since property changes utilize the same mechanisms as other events,
		-- the tests here are slimmed down to reduce redundancy.

		it("should connect to property changes", function()
			local instance = Instance.new("Folder")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectPropertyChange("Name", eventSpy.value)
			manager:resume()

			instance.Name = "foo"
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance)

			instance.Name = "bar"
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance)

			manager:connectPropertyChange("Name")

			instance.Name = "baz"
			expect(eventSpy.callCount).to.equal(2)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX080480238E834838A60BEF6A64D3BB96">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Symbol</string>
						<string name="ScriptGuid">{93F2E8DE-3D6A-4A79-A7B9-AFBE7CF4A430}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX395D772D6FCE41D8B256686B83075659">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Symbol.spec</string>
						<string name="ScriptGuid">{39B56792-10B4-46D1-A130-DE67EA2BB5D0}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBBA7224A714C477FB9172B327903DBDE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Type</string>
						<string name="ScriptGuid">{D058D68D-5093-4787-959F-A308C939F594}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7290DA6D1A584711B912598EBC38BC8E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Type.spec</string>
						<string name="ScriptGuid">{F908E85B-364F-4621-B03C-360EF07B9C0F}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Type)

	describe("of", function()
		it("should return nil if the value is not a table", function()
			expect(Type.of(1)).to.equal(nil)
			expect(Type.of(true)).to.equal(nil)
			expect(Type.of("test")).to.equal(nil)
			expect(Type.of(print)).to.equal(nil)
		end)

		it("should return nil if the table has no type", function()
			expect(Type.of({})).to.equal(nil)
		end)

		it("should return the assigned type", function()
			local test = {
				[Type] = Type.Element
			}

			expect(Type.of(test)).to.equal(Type.Element)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF874A71ECAFE4D17A41DA2988940D916">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">assertDeepEqual</string>
						<string name="ScriptGuid">{132598B3-D3A3-4CCA-8FF5-CAAF303AD5C3}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0B3AEED83FBC4A6ABAFC50B72042F8D3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">assertDeepEqual.spec</string>
						<string name="ScriptGuid">{5C1C15F7-B03B-4D7C-835B-F4AD318504B6}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)

	it("should fail with a message when args are not equal", function()
		local success, message = pcall(assertDeepEqual, 1, 2)

		expect(success).to.equal(false)
		expect(message:find("first ~= second")).to.be.ok()

		success, message = pcall(assertDeepEqual, {
			foo = 1,
		}, {
			foo = 2,
		})

		expect(success).to.equal(false)
		expect(message:find("first%[foo%] ~= second%[foo%]")).to.be.ok()
	end)

	it("should compare non-table values using standard '==' equality", function()
		assertDeepEqual(1, 1)
		assertDeepEqual("hello", "hello")
		assertDeepEqual(nil, nil)

		local someFunction = function() end
		local theSameFunction = someFunction

		assertDeepEqual(someFunction, theSameFunction)

		local A = {
			foo = someFunction
		}
		local B = {
			foo = theSameFunction
		}

		assertDeepEqual(A, B)
	end)

	it("should fail when types differ", function()
		local success, message = pcall(assertDeepEqual, 1, "1")

		expect(success).to.equal(false)
		expect(message:find("first is of type number, but second is of type string")).to.be.ok()
	end)

	it("should compare (and report about) nested tables", function()
		local A = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}
		local B = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}

		assertDeepEqual(A, B)

		local C = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 3,
			}
		}

		local success, message = pcall(assertDeepEqual, A, C)

		expect(success).to.equal(false)
		expect(message:find("first%[nested%]%[bar%] ~= second%[nested%]%[bar%]")).to.be.ok()
	end)

	it("should be commutative", function()
		local equalArgsA = {
			foo = "bar",
			hello = "world",
		}
		local equalArgsB = {
			foo = "bar",
			hello = "world",
		}

		assertDeepEqual(equalArgsA, equalArgsB)
		assertDeepEqual(equalArgsB, equalArgsA)

		local nonEqualArgs = {
			foo = "bar",
		}

		expect(function() assertDeepEqual(equalArgsA, nonEqualArgs) end).to.throw()
		expect(function() assertDeepEqual(nonEqualArgs, equalArgsA) end).to.throw()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD1016C65B77D4389AF5E32C37D25B925">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">assign</string>
						<string name="ScriptGuid">{9908A5C4-D80D-452D-9D64-CA8EF293CA15}</string>
						<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8547752C78EA4B57AA326C3DEF875785">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">assign.spec</string>
						<string name="ScriptGuid">{CEA9BC31-E3CF-41BC-A384-C52EBE6DFD55}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local None = require(script.Parent.None)

	local assign = require(script.Parent.assign)

	it("should accept zero additional tables", function()
		local input = {}
		local result = assign(input)

		expect(input).to.equal(result)
	end)

	it("should merge multiple tables onto the given target table", function()
		local target = {
			a = 5,
			b = 6,
		}

		local source1 = {
			b = 7,
			c = 8,
		}

		local source2 = {
			b = 8,
		}

		assign(target, source1, source2)

		expect(target.a).to.equal(5)
		expect(target.b).to.equal(source2.b)
		expect(target.c).to.equal(source1.c)
	end)

	it("should remove keys if specified as None", function()
		local target = {
			foo = 2,
			bar = 3,
		}

		local source = {
			foo = None,
		}

		assign(target, source)

		expect(target.foo).to.equal(nil)
		expect(target.bar).to.equal(3)
	end)

	it("should re-add keys if specified after None", function()
		local target = {
			foo = 2,
		}

		local source1 = {
			foo = None,
		}

		local source2 = {
			foo = 3,
		}

		assign(target, source1, source2)

		expect(target.foo).to.equal(source2.foo)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAA2FDB6E411E44A7A8ED71B2A337D6D6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createElement</string>
						<string name="ScriptGuid">{E1F2C540-36F4-4B74-A349-15A84ECF442F}</string>
						<ProtectedString name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9C5663F999B749239CB31FF551B286CA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createElement.spec</string>
						<string name="ScriptGuid">{3DE390C9-FDA2-4F2C-A676-0D0D84FD122D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Component = require(script.Parent.Component)
	local ElementKind = require(script.Parent.ElementKind)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Logging = require(script.Parent.Logging)
	local Type = require(script.Parent.Type)
	local Portal = require(script.Parent.Portal)
	local Children = require(script.Parent.PropMarkers.Children)

	local createElement = require(script.Parent.createElement)

	it("should create new primitive elements", function()
		local element = createElement("Frame")

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Host)
	end)

	it("should create new functional elements", function()
		local element = createElement(function()
		end)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Function)
	end)

	it("should create new stateful components", function()
		local Foo = Component:extend("Foo")

		local element = createElement(Foo)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Stateful)
	end)

	it("should create new portal elements", function()
		local element = createElement(Portal)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Portal)
	end)

	it("should accept props", function()
		local element = createElement("StringValue", {
			Value = "Foo",
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
	end)

	it("should accept props and children", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", {
			Value = "Foo",
		}, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should accept children with without props", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", nil, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should warn once if children is specified in two different ways", function()
		local logInfo = Logging.capture(function()
			-- Using a loop here to ensure that multiple occurences of the same
			-- warning only cause output once.
			for _ = 1, 2 do
				createElement("Frame", {
					[Children] = {},
				}, {})
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("createElement")).to.be.ok()
		expect(logInfo.warnings[1]:find("Children")).to.be.ok()
	end)

	it("should have a `source` member if elementTracing is set", function()
		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement("StringValue")

			expect(element.source).to.be.a("string")
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7C90A205D1A24CBA967E7720E2F68A88">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createFragment</string>
						<string name="ScriptGuid">{FB186607-54AD-406D-872F-89E59157FFC6}</string>
						<ProtectedString name="Source"><![CDATA[local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX702DAE6EFF044DAD9C41D2AC03D271DA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReconciler</string>
						<string name="ScriptGuid">{92EA856D-3279-4AA9-8798-73FCCB941F9B}</string>
						<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and context from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth
		local parentContext = virtualNode.parentContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, parentContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(newElement, hostParent, concreteKey, virtualNode.context)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,
			context = context,
			-- This copy of context is useful if the element gets replaced
			-- with an element of a different component type
			parentContext = context,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2E4579EFFE3840E2ACD2605FCA1E5E40">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReconciler.spec</string>
						<string name="ScriptGuid">{EF9DF208-EDD4-4C01-AC38-40A64CBBAD5D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assign = require(script.Parent.assign)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createSpy = require(script.Parent.createSpy)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local Type = require(script.Parent.Type)
	local ElementKind = require(script.Parent.ElementKind)

	local createReconciler = require(script.Parent.createReconciler)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("tree operations", function()
		it("should mount and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.unmountVirtualTree(tree)
		end)

		it("should mount, update, and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.updateVirtualTree(tree, createElement("StringValue"))

			noopReconciler.unmountVirtualTree(tree)
		end)
	end)

	describe("booleans", function()
		it("should mount booleans as nil", function()
			local node = noopReconciler.mountVirtualNode(false, nil, "test")
			expect(node).to.equal(nil)
		end)

		it("should unmount nodes if they are updated to a boolean value", function()
			local node = noopReconciler.mountVirtualNode(createElement("StringValue"), nil, "test")

			expect(node).to.be.ok()

			node = noopReconciler.updateVirtualNode(node, true)

			expect(node).to.equal(nil)
		end)
	end)

	describe("invalid elements", function()
		it("should throw errors when attempting to mount invalid elements", function()
			-- These function components return values with incorrect types
			local returnsString = function()
				return "Hello"
			end
			local returnsNumber = function()
				return 1
			end
			local returnsFunction = function()
				return function() end
			end
			local returnsTable = function()
				return {}
			end

			local hostParent = nil
			local key = "Some Key"

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsString), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsNumber), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsFunction), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsTable), hostParent, key)
			end).to.throw()
		end)
	end)

	describe("Host components", function()
		it("should invoke the renderer to mount host nodes", function()
			local mountHostNode = createSpy(NoopRenderer.mountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = mountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(mountHostNode.callCount).to.equal(1)

			local values = mountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)

		it("should invoke the renderer to update host nodes", function()
			local updateHostNode = createSpy(NoopRenderer.updateHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				updateHostNode = updateHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			local newElement = createElement("StringValue")
			local newNode = reconciler.updateVirtualNode(node, newElement)

			expect(newNode).to.equal(node)

			expect(updateHostNode.callCount).to.equal(1)

			local values = updateHostNode:captureValues("reconciler", "node", "newElement")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
			expect(values.newElement).to.equal(newElement)
		end)

		it("should invoke the renderer to unmount host nodes", function()
			local unmountHostNode = createSpy(NoopRenderer.unmountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				unmountHostNode = unmountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			reconciler.unmountVirtualNode(node)

			expect(unmountHostNode.callCount).to.equal(1)

			local values = unmountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)
	end)

	describe("Function components", function()
		it("should mount and unmount function components", function()
			local componentSpy = createSpy(function(props)
				return nil
			end)

			local element = createElement(componentSpy.value, {
				someValue = 5,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(componentSpy.callCount).to.equal(1)

			local calledWith = componentSpy:captureValues("props")

			expect(calledWith.props).to.be.a("table")
			expect(calledWith.props.someValue).to.equal(5)

			noopReconciler.unmountVirtualNode(node)

			expect(componentSpy.callCount).to.equal(1)
		end)

		it("should mount single children of function components", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createElement(childComponentSpy.value, {
					value = props.value + 1,
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 13,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childCalledWith = childComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(13)

			expect(childCalledWith.props).to.be.a("table")
			expect(childCalledWith.props.value).to.equal(14)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)
		end)

		it("should mount fragments returned by function components", function()
			local childAComponentSpy = createSpy(function(props)
				return nil
			end)

			local childBComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createFragment({
					A = createElement(childAComponentSpy.value, {
						value = props.value + 1,
					}),
					B = createElement(childBComponentSpy.value, {
						value = props.value + 5,
					}),
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 17,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childACalledWith = childAComponentSpy:captureValues("props")
			local childBCalledWith = childBComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(17)

			expect(childACalledWith.props).to.be.a("table")
			expect(childACalledWith.props.value).to.equal(18)

			expect(childBCalledWith.props).to.be.a("table")
			expect(childBCalledWith.props.value).to.equal(22)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)
		end)
	end)

	describe("Fragments", function()
		it("should mount fragments", function()
			local fragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(fragment, nil, "test")

			expect(node).to.be.ok()
			expect(ElementKind.of(node.currentElement)).to.equal(ElementKind.Fragment)
		end)

		it("should mount an empty fragment", function()
			local emptyFragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(emptyFragment, nil, "test")

			expect(node).to.be.ok()
			expect(next(node.children)).to.never.be.ok()
		end)

		it("should mount all fragment's children", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)
			local elements = {}
			local totalElements = 5

			for i=1, totalElements do
				elements["key"..tostring(i)] = createElement(childComponentSpy.value, {})
			end

			local fragments = createFragment(elements)
			local node = noopReconciler.mountVirtualNode(fragments, nil, "test")

			expect(node).to.be.ok()
			expect(childComponentSpy.callCount).to.equal(totalElements)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX36C933E959874C4C93C536B90BD4A13A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReconcilerCompat</string>
						<string name="ScriptGuid">{A2EBA038-4F38-471D-A8D3-9085F7EEF32D}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7E9FE0EA50A444EA8F96552052C01646">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReconcilerCompat.spec</string>
						<string name="ScriptGuid">{99311807-15A6-4ADE-8A94-D70E7ECD657A}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)
	local createReconciler = require(script.Parent.createReconciler)
	local Logging = require(script.Parent.Logging)
	local NoopRenderer = require(script.Parent.NoopRenderer)

	local createReconcilerCompat = require(script.Parent.createReconcilerCompat)

	local noopReconciler = createReconciler(NoopRenderer)
	local compatReconciler = createReconcilerCompat(noopReconciler)

	it("reify should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = compatReconciler.reify(createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = compatReconciler.reify(createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()
	end)

	it("teardown should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.teardown(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.teardown(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()
	end)

	it("update should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.reconcile(handle, createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.reconcile(handle, createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX379009FC8DFE4A6B81EC33E7C26D88C3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createRef</string>
						<string name="ScriptGuid">{D8478D26-F2C9-419E-B67B-B3BCBBBC6338}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF679C218C9134A439E72B00CFC66360F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createRef.spec</string>
						<string name="ScriptGuid">{65F0A659-5CF3-45E4-B82F-12FE0FC6A4C9}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Binding = require(script.Parent.Binding)
	local Type = require(script.Parent.Type)

	local createRef = require(script.Parent.createRef)

	it("should create refs, which are specialized bindings", function()
		local ref = createRef()

		expect(Type.of(ref)).to.equal(Type.Binding)
		expect(ref.current).to.equal(nil)
	end)

	it("should have a 'current' field that is the same as the internal binding's value", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 10)
		expect(ref.current).to.equal(10)
	end)

	it("should support tostring on refs", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)
		expect(tostring(ref)).to.equal("RoactRef(nil)")

		Binding.update(ref, 10)
		expect(tostring(ref)).to.equal("RoactRef(10)")
	end)

	it("should not allow assignments to the 'current' field", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 99)
		expect(ref.current).to.equal(99)

		expect(function()
			ref.current = 77
		end).to.throw()

		expect(ref.current).to.equal(99)
	end)

	it("should return the same thing from getValue as its current field", function()
		local ref = createRef()
		Binding.update(ref, 10)

		expect(ref:getValue()).to.equal(10)
		expect(ref:getValue()).to.equal(ref.current)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC044A84150DA4F9394BC8855ED3B2940">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal</string>
						<string name="ScriptGuid">{4AEBD89E-ABCA-4F1E-B086-D9389C7785C5}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4C600F4B627141769B3164C658E66C68">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal.spec</string>
						<string name="ScriptGuid">{934C19CE-3EFE-464E-BCB2-89414AB829F0}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createSignal = require(script.Parent.createSignal)

	local createSpy = require(script.Parent.createSpy)

	it("should fire subscribers and disconnect them", function()
		local signal = createSignal()

		local spy = createSpy()
		local disconnect = signal:subscribe(spy.value)

		expect(spy.callCount).to.equal(0)

		local a = 1
		local b = {}
		local c = "hello"
		signal:fire(a, b, c)

		expect(spy.callCount).to.equal(1)
		spy:assertCalledWith(a, b, c)

		disconnect()

		signal:fire()

		expect(spy.callCount).to.equal(1)
	end)

	it("should handle multiple subscribers", function()
		local signal = createSignal()

		local spyA = createSpy()
		local spyB = createSpy()

		local disconnectA = signal:subscribe(spyA.value)
		local disconnectB = signal:subscribe(spyB.value)

		expect(spyA.callCount).to.equal(0)
		expect(spyB.callCount).to.equal(0)

		local a = {}
		local b = 67
		signal:fire(a, b)

		expect(spyA.callCount).to.equal(1)
		spyA:assertCalledWith(a, b)

		expect(spyB.callCount).to.equal(1)
		spyB:assertCalledWith(a, b)

		disconnectA()

		signal:fire(b, a)

		expect(spyA.callCount).to.equal(1)

		expect(spyB.callCount).to.equal(2)
		spyB:assertCalledWith(b, a)

		disconnectB()
	end)

	it("should stop firing a connection if disconnected mid-fire", function()
		local signal = createSignal()

		-- In this test, we'll connect two listeners that each try to disconnect
		-- the other. Because the order of listeners firing isn't defined, we
		-- have to be careful to handle either case.

		local disconnectA
		local disconnectB

		local spyA = createSpy(function()
			disconnectB()
		end)

		local spyB = createSpy(function()
			disconnectA()
		end)

		disconnectA = signal:subscribe(spyA.value)
		disconnectB = signal:subscribe(spyB.value)

		signal:fire()

		-- Exactly once listener should have been called.
		expect(spyA.callCount + spyB.callCount).to.equal(1)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX97FBCF6DE50A44F99AD7C9FFB7D67A25">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSpy</string>
						<string name="ScriptGuid">{0F7014DA-5F75-4A92-8AC3-15702CA3BA4F}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA317DD5FF6EE45069EBB2C95DBA7AEC3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSpy.spec</string>
						<string name="ScriptGuid">{62E9051A-A4ED-4736-B1CD-4AAF8FC273DE}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createSpy = require(script.Parent.createSpy)

	describe("createSpy", function()
		it("should create spies", function()
			local spy = createSpy(function() end)

			expect(spy).to.be.ok()
		end)

		it("should throw if spies are indexed by an invalid key", function()
			local spy = createSpy(function() end)

			expect(function()
				return spy.test
			end).to.throw()
		end)
	end)

	describe("value", function()
		it("should increment callCount when called", function()
			local spy = createSpy(function() end)
			spy.value()

			expect(spy.callCount).to.equal(1)
		end)

		it("should store all values passed", function()
			local spy = createSpy(function() end)
			spy.value(1, true, "3")

			expect(spy.valuesLength).to.equal(3)
			expect(spy.values[1]).to.equal(1)
			expect(spy.values[2]).to.equal(true)
			expect(spy.values[3]).to.equal("3")
		end)

		it("should return the value of the inner function", function()
			local spy = createSpy(function()
				return true
			end)

			expect(spy.value()).to.equal(true)
		end)
	end)

	describe("assertCalledWith", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1)
			end).to.throw()
		end)

		it("should throw if any value differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1, 3)
			end).to.throw()

			expect(function()
				spy:assertCalledWith(2, 3)
			end).to.throw()
		end)
	end)

	describe("captureValues", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:captureValues("a")
			end).to.throw()
		end)

		it("should capture all values in a table", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			local captured = spy:captureValues("a", "b")
			expect(captured.a).to.equal(1)
			expect(captured.b).to.equal(2)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9180C0EB4D94465B9618E45D130D76EC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getDefaultInstanceProperty</string>
						<string name="ScriptGuid">{196B2EBC-1727-4BB6-BD52-611B883CF464}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD7EED9F54AAA4EF8A0BDCFCEE53662D6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getDefaultInstanceProperty.spec</string>
						<string name="ScriptGuid">{092512F7-7207-4565-9FC6-982E122FE03C}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)

	it("should get default name string values", function()
		local _, defaultName = getDefaultInstanceProperty("StringValue", "Name")

		expect(defaultName).to.equal("Value")
	end)

	it("should get default empty string values", function()
		local _, defaultValue = getDefaultInstanceProperty("StringValue", "Value")

		expect(defaultValue).to.equal("")
	end)

	it("should get default number values", function()
		local _, defaultValue = getDefaultInstanceProperty("IntValue", "Value")

		expect(defaultValue).to.equal(0)
	end)

	it("should get nil default values", function()
		local _, defaultValue = getDefaultInstanceProperty("ObjectValue", "Value")

		expect(defaultValue).to.equal(nil)
	end)

	it("should get bool default values", function()
		local _, defaultValue = getDefaultInstanceProperty("BoolValue", "Value")

		expect(defaultValue).to.equal(false)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB36B34015A8B44F0A217806C8057FFE8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid">{EE3C6CC1-01A5-4F57-9432-35CB1B2F46EE}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent)

	it("should load with all public APIs", function()
		local publicApi = {
			createElement = "function",
			createFragment = "function",
			createRef = "function",
			createBinding = "function",
			joinBindings = "function",
			mount = "function",
			unmount = "function",
			update = "function",
			oneChild = "function",
			setGlobalConfig = "function",

			-- These functions are deprecated and throw warnings!
			reify = "function",
			teardown = "function",
			reconcile = "function",

			Component = true,
			PureComponent = true,
			Portal = true,
			Children = true,
			Event = true,
			Change = true,
			Ref = true,
			None = true,
			UNSTABLE = true,
		}

		expect(Roact).to.be.ok()

		for key, valueType in pairs(publicApi) do
			local success
			if typeof(valueType) == "string" then
				success = typeof(Roact[key]) == valueType
			else
				success = Roact[key] ~= nil
			end

			if not success then
				local existence = typeof(valueType) == "boolean" and "present" or "of type " .. valueType
				local message = (
					"Expected public API member %q to be %s, but instead it was of type %s"
				):format(tostring(key), existence, typeof(Roact[key]))

				error(message)
			end
		end

		for key in pairs(Roact) do
			if publicApi[key] == nil then
				local message = (
					"Found unknown public API key %q!"
				):format(tostring(key))

				error(message)
			end
		end
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX432D67CB6CDE40CA89FFB2EE32F5235F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">internalAssert</string>
						<string name="ScriptGuid">{9FC369D1-1FCA-48B7-B528-0E89F9C4DFC4}</string>
						<ProtectedString name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBAFF5ACF43D24CCA96969CB043E6B438">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">invalidSetStateMessages</string>
						<string name="ScriptGuid">{16F2F9B9-9FA3-4CB2-81CB-22C20BE9807B}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA1F583A9C8434A1AA133BEDD940500E2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">oneChild</string>
						<string name="ScriptGuid">{A9F3571E-3723-43CB-B6C6-8690DB02D653}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF4322BE00552457691E2394C8189F3B4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">oneChild.spec</string>
						<string name="ScriptGuid">{4F675995-8EB0-43A4-B5F8-F4B79787D8F0}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)

	local oneChild = require(script.Parent.oneChild)

	it("should get zero children from a table", function()
		local children = {}

		expect(oneChild(children)).to.equal(nil)
	end)

	it("should get exactly one child", function()
		local child = createElement("Frame")
		local children = {
			foo = child,
		}

		expect(oneChild(children)).to.equal(child)
	end)

	it("should error with more than one child", function()
		local children = {
			a = createElement("Frame"),
			b = createElement("Frame"),
		}

		expect(function()
			oneChild(children)
		end).to.throw()
	end)

	it("should handle being passed nil", function()
		expect(oneChild(nil)).to.equal(nil)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC13F138187EE4BA19E9AEDF8DD39D133">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">strict</string>
						<string name="ScriptGuid">{382A2FBA-C753-4281-94A5-681D4290028F}</string>
						<ProtectedString name="Source"><![CDATA[local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX031444047B994901BE8A77C6FBBF3901">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">strict.spec</string>
						<string name="ScriptGuid">{23994686-1BDA-457E-B1AB-FA293D1BAE22}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local strict = require(script.Parent.strict)

	it("should error when getting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			return t.c
		end).to.throw()
	end)

	it("should error when setting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			t.c = 3
		end).to.throw()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80BF9D1C5F2F43BE99E2F08A8EAB12FD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createFragment.spec</string>
						<string name="ScriptGuid">{5B96F91E-3A6F-47A0-A095-55AA02F676D1}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local ElementKind = require(script.Parent.ElementKind)
	local Type = require(script.Parent.Type)

	local createFragment = require(script.Parent.createFragment)

	it("should create new primitive elements", function()
		local fragment = createFragment({})

		expect(fragment).to.be.ok()
		expect(Type.of(fragment)).to.equal(Type.Element)
		expect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)
	end)

	it("should accept children", function()
		local subFragment = createFragment({})
		local fragment = createFragment({key = subFragment})

		expect(fragment.elements.key).to.equal(subFragment)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXE3514AA893C8433D9DF5F00757375A07">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RoactRodux</string>
					<string name="ScriptGuid">{378FA6D5-1A66-47A2-9B1E-637791DD333F}</string>
					<ProtectedString name="Source"><![CDATA[local StoreProvider = require(script.StoreProvider)
local connect = require(script.connect)
local getStore = require(script.getStore)

return {
	StoreProvider = StoreProvider,
	connect = connect,
	UNSTABLE_getStore = getStore,
	UNSTABLE_connect2 = connect,
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX46D82ECD173E4DD6950E0E4CBD674DEE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StoreProvider</string>
						<string name="ScriptGuid">{5CF15A1E-4C4F-4021-95B4-A955F4ABA2C1}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local storeKey = require(script.Parent.storeKey)

local StoreProvider = Roact.Component:extend("StoreProvider")

function StoreProvider:init(props)
	local store = props.store

	if store == nil then
		error("Error initializing StoreProvider. Expected a `store` prop to be a Rodux store.")
	end

	self._context[storeKey] = store
end

function StoreProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return StoreProvider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4A213D870A6E474A9F4C22268B4A25F7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StoreProvider.spec</string>
						<string name="ScriptGuid">{17EFBACB-B7C5-4117-8C94-6F1BF3B70842}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	it("should be instantiable as a component", function()
		local store = Rodux.Store.new(function()
			return 0
		end)
		local element = Roact.createElement(StoreProvider, {
			store = store
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element, nil, "StoreProvider-test")

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(StoreProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX83FACA1CAD524B2DB74999641F31FCD2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Symbol</string>
						<string name="ScriptGuid">{07C896D1-E503-4306-88C1-BA7BB4E02CAD}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type that can be used to signify unique
	statuses. Symbols have the type 'userdata', but when printed to the console,
	the name of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF06B8371407E45849C8667C70EAD71F5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Symbol.spec</string>
						<string name="ScriptGuid">{37916B3E-339B-448D-9143-B430215CC08F}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX13A9299153644890A4F89C958EF96496">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">connect</string>
						<string name="ScriptGuid">{59B2E426-4D48-4979-9DA0-4375EF7E0E93}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local getStore = require(script.Parent.getStore)
local shallowEqual = require(script.Parent.shallowEqual)
local join = require(script.Parent.join)

--[[
	Formats a multi-line message with printf-style placeholders.
]]
local function formatMessage(lines, parameters)
	return table.concat(lines, "\n"):format(unpack(parameters or {}))
end

local function noop()
	return nil
end

--[[
	The stateUpdater accepts props when they update and computes the
	complete set of props that should be passed to the wrapped component.

	Each connected component will have a stateUpdater created for it.

	stateUpdater is put into the component's state in order for
	getDerivedStateFromProps to be able to access it. It is not mutated.
]]
local function makeStateUpdater(store)
	return function(nextProps, prevState, mappedStoreState)
		-- The caller can optionally provide mappedStoreState if it needed that
		-- value beforehand. Doing so is purely an optimization.
		if mappedStoreState == nil then
			mappedStoreState = prevState.mapStateToProps(store:getState(), nextProps)
		end

		local propsForChild = join(nextProps, mappedStoreState, prevState.mappedStoreDispatch)

		return {
			mappedStoreState = mappedStoreState,
			propsForChild = propsForChild,
		}
	end
end

--[[
	mapStateToProps:
		(storeState, props) -> partialProps
		OR
		() -> (storeState, props) -> partialProps
	mapDispatchToProps: (dispatch) -> partialProps
]]
local function connect(mapStateToPropsOrThunk, mapDispatchToProps)
	local connectTrace = debug.traceback()

	if mapStateToPropsOrThunk ~= nil then
		assert(typeof(mapStateToPropsOrThunk) == "function", "mapStateToProps must be a function or nil!")
	else
		mapStateToPropsOrThunk = noop
	end

	if mapDispatchToProps ~= nil then
		assert(typeof(mapDispatchToProps) == "function", "mapDispatchToProps must be a function or nil!")
	else
		mapDispatchToProps = noop
	end

	return function(innerComponent)
		if innerComponent == nil then
			local message = formatMessage({
				"connect returns a function that must be passed a component.",
				"Check the connection at:",
				"%s",
			}, {
				connectTrace,
			})

			error(message, 2)
		end

		local componentName = ("RoduxConnection(%s)"):format(tostring(innerComponent))

		local Connection = Roact.Component:extend(componentName)

		function Connection.getDerivedStateFromProps(nextProps, prevState)
			if prevState.stateUpdater ~= nil then
				return prevState.stateUpdater(nextProps, prevState)
			end
		end

		function Connection:init()
			self.store = getStore(self)

			if self.store == nil then
				local message = formatMessage({
					"Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!",
					"Tried to wrap component %q",
					"Make sure there is a StoreProvider above this component in the tree.",
				}, {
					tostring(innerComponent),
				})

				error(message)
			end

			local storeState = self.store:getState()

			local mapStateToProps = mapStateToPropsOrThunk
			local mappedStoreState = mapStateToProps(storeState, self.props)

			-- mapStateToPropsOrThunk can return a function instead of a state
			-- value. In this variant, we keep that value as mapStateToProps
			-- instead of the original mapStateToProps. This matches react-redux
			-- and enables connectors to keep instance-level state.
			if typeof(mappedStoreState) == "function" then
				mapStateToProps = mappedStoreState
				mappedStoreState = mapStateToProps(storeState, self.props)
			end

			if mappedStoreState ~= nil and typeof(mappedStoreState) ~= "table" then
				local message = formatMessage({
					"mapStateToProps must either return a table, or return another function that returns a table.",
					"Instead, it returned %q, which is of type %s.",
				}, {
					tostring(mappedStoreState),
					typeof(mappedStoreState),
				})

				error(message)
			end

			local mappedStoreDispatch = mapDispatchToProps(function(...)
				return self.store:dispatch(...)
			end)

			local stateUpdater = makeStateUpdater(self.store)

			self.state = {
				-- Combines props, mappedStoreDispatch, and the result of
				-- mapStateToProps into propsForChild. Stored in state so that
				-- getDerivedStateFromProps can access it.
				stateUpdater = stateUpdater,

				-- Used by the store changed connection and stateUpdater to
				-- construct propsForChild.
				mapStateToProps = mapStateToProps,

				-- Used by stateUpdater to construct propsForChild.
				mappedStoreDispatch = mappedStoreDispatch,

				-- Passed directly into the component that Connection is
				-- wrapping.
				propsForChild = nil,
			}

			local extraState = stateUpdater(self.props, self.state, mappedStoreState)

			for key, value in pairs(extraState) do
				self.state[key] = value
			end
		end

		function Connection:didMount()
			self.storeChangedConnection = self.store.changed:connect(function(storeState)
				self:setState(function(prevState, props)
					local mappedStoreState = prevState.mapStateToProps(storeState, props)

					-- We run this check here so that we only check shallow
					-- equality with the result of mapStateToProps, and not the
					-- other props that could be passed through the connector.
					if shallowEqual(mappedStoreState, prevState.mappedStoreState) then
						return nil
					end

					return prevState.stateUpdater(props, prevState, mappedStoreState)
				end)
			end)
		end

		function Connection:willUnmount()
			self.storeChangedConnection:disconnect()
		end

		function Connection:render()
			return Roact.createElement(innerComponent, self.state.propsForChild)
		end

		return Connection
	end
end

return connect]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0D29AF01D88147A08B504259BA1C1A26">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">connect.spec</string>
						<string name="ScriptGuid">{9BB76415-3D1A-439F-9BC1-8951BE734006}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local connect = require(script.Parent.connect)

	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local function noop()
		return nil
	end

	local function NoopComponent()
		return nil
	end

	local function countReducer(state, action)
		state = state or 0

		if action.type == "increment" then
			return state + 1
		end

		return state
	end

	local reducer = Rodux.combineReducers({
		count = countReducer,
	})

	describe("Argument validation", function()
		it("should accept no arguments", function()
			connect()
		end)

		it("should accept one function", function()
			connect(noop)
		end)

		it("should accept two functions", function()
			connect(noop, noop)
		end)

		it("should accept only the second function", function()
			connect(nil, function() end)
		end)

		it("should throw if not passed a component", function()
			local selector = function(store)
				return {}
			end

			expect(function()
				connect(selector)(nil)
			end).to.throw()
		end)
	end)

	it("should throw if not mounted under a StoreProvider", function()
		local ConnectedSomeComponent = connect()(NoopComponent)

		expect(function()
			Roact.mount(Roact.createElement(ConnectedSomeComponent))
		end).to.throw()
	end)

	it("should accept a higher-order function mapStateToProps", function()
		local function mapStateToProps()
			return function(state)
				return {
					count = state.count,
				}
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		Roact.unmount(handle)
	end)

	it("should not accept a higher-order mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return function(state)
				return "nope"
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should not accept a mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return "nah"
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should abort renders when mapStateToProps returns the same data", function()
		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(renderCount).to.equal(2)

		Roact.unmount(handle)
	end)

	it("should only call mapDispatchToProps once and never re-render if no mapStateToProps was passed", function()
		local dispatchCount = 0
		local mapDispatchToProps = function(dispatch)
			dispatchCount = dispatchCount + 1

			return {
				increment = function()
					return dispatch({ type = "increment" })
				end,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		Roact.unmount(handle)
	end)

	it("should return result values from the dispatch passed to mapDispatchToProps", function()
		local function reducer()
			return 0
		end

		local function fiveThunk()
			return 5
		end

		local dispatch
		local function SomeComponent(props)
			dispatch = props.dispatch
		end

		local function mapDispatchToProps(dispatch)
			return {
				dispatch = dispatch
			}
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		-- We'll use the thunk middleware, as it should always return its result
		local store = Rodux.Store.new(reducer, nil, { Rodux.thunkMiddleware })
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent)
		})

		local handle = Roact.mount(tree)

		expect(dispatch).to.be.a("function")
		expect(dispatch(fiveThunk)).to.equal(5)

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1FC343545E3843DB88E08FE935F34E2A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getStore</string>
						<string name="ScriptGuid">{717411F6-EEA7-4799-AA09-E1939996FF60}</string>
						<ProtectedString name="Source"><![CDATA[local storeKey = require(script.Parent.storeKey)

local function getStore(componentInstance)
	return componentInstance._context[storeKey]
end

return getStore]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEA944A6A19E847F5A06660CB5CC41076">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getStore.spec</string>
						<string name="ScriptGuid">{02D5E89F-34A0-40B3-8E6D-235C7FFB2F4A}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local StoreProvider = require(script.Parent.StoreProvider)

	local getStore = require(script.Parent.getStore)

	it("should return the store when present", function()
		local function reducer()
			return 0
		end

		local store = Rodux.Store.new(reducer)
		local consumedStore = nil

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			Consumer = Roact.createElement(StoreConsumer),
		})

		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(store)

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should return nil when the store is not present", function()
		-- Use a non-nil value to know for sure if StoreConsumer:init was called
		local consumedStore = 6

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreConsumer)
		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(nil)

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2A816195FA294ECDB235409DBEB06C66">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">join</string>
						<string name="ScriptGuid">{2D4AF52F-AF51-4F70-936A-A4403BD25D40}</string>
						<ProtectedString name="Source"><![CDATA[local function join(...)
	local result = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				result[key] = value
			end
		end
	end

	return result
end

return join]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFEF0E59BC9724A52AC61D839ABF6F882">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">shallowEqual</string>
						<string name="ScriptGuid">{A656D8F5-B508-4B8C-952E-360008F52664}</string>
						<ProtectedString name="Source"><![CDATA[local function shallowEqual(a, b)
	if a == nil then
		return b == nil
	elseif b == nil then
		return a == nil
	end

	for key, value in pairs(a) do
		if value ~= b[key] then
			return false
		end
	end

	for key, value in pairs(b) do
		if value ~= a[key] then
			return false
		end
	end

	return true
end

return shallowEqual]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE0303D4210254B8288F49A43927F1B84">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">shallowEqual.spec</string>
						<string name="ScriptGuid">{41AAF533-5A26-466A-AB69-502BD6C0C55B}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should compare dictionaries", function()
		local a = {
			a = "a",
			b = {},
			c = 6,
		}

		local b = {
			b = a.b,
			c = a.c,
			a = a.a,
		}

		local c = {
			b = {},
			a = a.a,
			c = a.c,
		}

		local d = {
			a = a.a,
			b = a.b,
			c = a.c,
			d = "hello",
		}

		expect(shallowEqual(a, a)).to.equal(true)
		expect(shallowEqual(a, b)).to.equal(true)
		expect(shallowEqual(a, c)).to.equal(false)
		expect(shallowEqual(b, c)).to.equal(false)
		expect(shallowEqual(a, d)).to.equal(false)
		expect(shallowEqual(b, d)).to.equal(false)
	end)

	it("should handle nil for either argument", function()
		local a = {}

		expect(shallowEqual(nil, nil)).to.equal(true)
		expect(shallowEqual(a, nil)).to.equal(false)
		expect(shallowEqual(nil, a)).to.equal(false)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEAE5A9A8729D4CEA9E183AC26549D10B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">storeKey</string>
						<string name="ScriptGuid">{5F714FA7-B160-4802-A445-796A6E3CDC42}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

return Symbol.named("RoduxStore")]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXAC3686C09FBC433FB6F6F900B5D62DD2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Rodux</string>
					<string name="ScriptGuid">{A5047D74-318B-4798-8181-EC0117DE5A28}</string>
					<ProtectedString name="Source"><![CDATA[local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX4B7B777C3B7D4CC8B6692449AF6B8792">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NoYield</string>
						<string name="ScriptGuid">{83F1BBE5-67C9-4DBD-AF15-E54DC348ABB2}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC2095AB214BB4B7AA6FD6E9F65B8F30A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NoYield.spec</string>
						<string name="ScriptGuid">{D45C39A2-33D3-46F6-98CA-F7EECCA79CFC}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local NoYield = require(script.Parent.NoYield)

	it("should call functions normally", function()
		local callCount = 0

		local function test(a, b)
			expect(a).to.equal(5)
			expect(b).to.equal(6)

			callCount = callCount + 1

			return 11, "hello"
		end

		local a, b = NoYield(test, 5, 6)

		expect(a).to.equal(11)
		expect(b).to.equal("hello")
	end)

	it("should throw on yield", function()
		local preCount = 0
		local postCount = 0

		local function testMethod()
			preCount = preCount + 1
			wait()
			postCount = postCount + 1
		end

		local ok, err = pcall(NoYield, testMethod)

		expect(preCount).to.equal(1)
		expect(postCount).to.equal(0)

		expect(ok).to.equal(false)
		expect(err:find("Attempted to yield inside changed event!")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)

	it("should propagate error messages", function()
		local count = 0

		local function test()
			count = count + 1
			error("foo")
		end

		local ok, err = pcall(NoYield, test)

		expect(ok).to.equal(false)
		expect(err:find("foo")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX87D39F5479814129B1750F6AB8A6714B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Signal</string>
						<string name="ScriptGuid">{D0417B5B-7728-44C4-920E-6F77DD079CD6}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]

local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new()
	local self = {
		_listeners = {}
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	local listener = {
		callback = callback,
		disconnected = false,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		listener.disconnected = true
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX287E815549C943AB8E53546AC6A0F271">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Signal.spec</string>
						<string name="ScriptGuid">{FA9B9AF5-9E31-41AE-84A0-15B32A3788D8}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Signal = require(script.Parent.Signal)

	it("should construct from nothing", function()
		local signal = Signal.new()

		expect(signal).to.be.ok()
	end)

	it("should fire connected callbacks", function()
		local callCount = 0
		local value1 = "Hello World"
		local value2 = 7

		local callback = function(arg1, arg2)
			expect(arg1).to.equal(value1)
			expect(arg2).to.equal(value2)
			callCount = callCount + 1
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)

		connection:disconnect()
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)
	end)

	it("should disconnect handlers", function()
		local callback = function()
			error("Callback was called after disconnect!")
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		connection:disconnect()

		signal:fire()
	end)

	it("should fire handlers in order", function()
		local signal = Signal.new()
		local x = 0
		local y = 0

		local callback1 = function()
			expect(x).to.equal(0)
			expect(y).to.equal(0)
			x = x + 1
		end

		local callback2 = function()
			expect(x).to.equal(1)
			expect(y).to.equal(0)
			y = y + 1
		end

		signal:connect(callback1)
		signal:connect(callback2)
		signal:fire()

		expect(x).to.equal(1)
		expect(y).to.equal(1)
	end)

	it("should continue firing despite mid-event disconnection", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionA
		connectionA = signal:connect(function()
			connectionA:disconnect()
			countA = countA + 1
		end)

		signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(1)
	end)

	it("should skip listeners that were disconnected during event evaluation", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionB

		signal:connect(function()
			countA = countA + 1
			connectionB:disconnect()
		end)

		connectionB = signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(0)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFB0BC24F8F8A499A9A39F73C38A191CB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Store</string>
						<string name="ScriptGuid">{34BCD709-D03A-45C3-82F4-4274292B3EC2}</string>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")

	local self = {}

	self._reducer = reducer
	self._state = reducer(initialState, {
		type = "@@INIT",
	})
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new()

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) == "table" then
		if action.type == nil then
			error("action does not have a type field", 2)
		end

		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	else
		error(("actions of type %q are not permitted"):format(typeof(action)), 2)
	end
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	-- If a changed listener yields, *very* surprising bugs can ensue.
	-- Because of that, changed listeners cannot yield.
	NoYield(function()
		self.changed:fire(state, self._lastState)
	end)

	self._lastState = state
end

return Store
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX928FE92CE2E54334B453D74CF4F56F8F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Store.spec</string>
						<string name="ScriptGuid">{E4BAAD73-75DD-4454-927E-CCB3DC5F22D5}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)

	describe("new", function()
		it("should instantiate with a reducer", function()
			local store = Store.new(function(state, action)
				return "hello, world"
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("hello, world")

			store:destruct()
		end)

		it("should instantiate with a reducer and an initial state", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state")

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should instantiate with a reducer, initial state, and middlewares", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state", {})

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should modify the dispatch method when middlewares are passed", function()
			local middlewareInstantiateCount = 0
			local middlewareInvokeCount = 0
			local passedDispatch
			local passedStore
			local passedAction

			local function reducer(state, action)
				if action.type == "test" then
					return "test state"
				end

				return state
			end

			local function testMiddleware(nextDispatch, store)
				middlewareInstantiateCount = middlewareInstantiateCount + 1
				passedDispatch = nextDispatch
				passedStore = store

				return function(action)
					middlewareInvokeCount = middlewareInvokeCount + 1
					passedAction = action

					nextDispatch(action)
				end
			end

			local store = Store.new(reducer, "initial state", { testMiddleware })

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(0)
			expect(passedDispatch).to.be.a("function")
			expect(passedStore).to.equal(store)

			store:dispatch({
				type = "test",
			})

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(1)
			expect(passedAction.type).to.equal("test")

			store:flush()

			expect(store:getState()).to.equal("test state")

			store:destruct()
		end)

		it("should execute middleware left-to-right", function()
			local events = {}

			local function reducer(state)
				return state
			end

			local function middlewareA(nextDispatch, store)
				table.insert(events, "instantiate a")
				return function(action)
					table.insert(events, "execute a")
					return nextDispatch(action)
				end
			end

			local function middlewareB(nextDispatch, store)
				table.insert(events, "instantiate b")
				return function(action)
					table.insert(events, "execute b")
					return nextDispatch(action)
				end
			end

			local store = Store.new(reducer, 5, { middlewareA, middlewareB })

			expect(#events).to.equal(2)
			expect(events[1]).to.equal("instantiate b")
			expect(events[2]).to.equal("instantiate a")

			store:dispatch({
				type = "test",
			})

			expect(#events).to.equal(4)
			expect(events[3]).to.equal("execute a")
			expect(events[4]).to.equal("execute b")
		end)

		it("should send an initial action with a 'type' field", function()
			local lastAction
			local callCount = 0

			local store = Store.new(function(state, action)
				lastAction = action
				callCount = callCount + 1

				return state
			end)

			expect(callCount).to.equal(1)
			expect(lastAction).to.be.a("table")
			expect(lastAction.type).to.be.ok()

			store:destruct()
		end)
	end)

	describe("getState", function()
		it("should get the current state", function()
			local store = Store.new(function(state, action)
				return "foo"
			end)

			local state = store:getState()

			expect(state).to.equal("foo")

			store:destruct()
		end)
	end)

	describe("dispatch", function()
		it("should be sent through the reducer", function()
			local store = Store.new(function(state, action)
				state = state or "foo"

				if action.type == "act" then
					return "bar"
				end

				return state
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("foo")

			store:dispatch({
				type = "act",
			})

			store:flush()

			expect(store:getState()).to.equal("bar")

			store:destruct()
		end)

		it("should trigger the changed event after a flush", function()
			local store = Store.new(function(state, action)
				state = state or 0

				if action.type == "increment" then
					return state + 1
				end

				return state
			end)

			local callCount = 0

			store.changed:connect(function(state, oldState)
				expect(oldState).to.equal(0)
				expect(state).to.equal(1)

				callCount = callCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			store:flush()

			expect(callCount).to.equal(1)

			store:destruct()
		end)

		it("should handle actions dispatched within the changed event", function()
			local store = Store.new(function(state, action)
				state = state or {
					value = 0,
				}

				if action.type == "increment" then
					return {
						value = state.value + 1,
					}
				elseif action.type == "decrement" then
					return {
						value = state.value - 1,
					}
				end

				return state
			end)

			local changeCount = 0

			store.changed:connect(function(state, oldState)
				expect(state).never.to.equal(oldState)

				if state.value > 0 then
					store:dispatch({
						type = "decrement",
					})
				end

				changeCount = changeCount + 1
			end)

			store:dispatch({
				type = "increment",
			})
			store:flush()
			store:flush()

			expect(changeCount).to.equal(2)

			store:destruct()
		end)

		it("should prevent yielding from changed handler", function()
			local preCount = 0
			local postCount = 0

			local store = Store.new(function(state, action)
				state = state or 0
				return state + 1
			end)

			store.changed:connect(function(state, oldState)
				preCount = preCount + 1
				wait()
				postCount = postCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			expect(function()
				store:flush()
			end).to.throw()

			expect(preCount).to.equal(1)
			expect(postCount).to.equal(0)

			store:destruct()
		end)

		it("should throw if an action is dispatched without a type field", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch({})
			end).to.throw()

			store:destruct()
		end)

		it("should throw if the action is not a function or table", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch(1)
			end).to.throw()

			store:destruct()
		end)
	end)

	describe("flush", function()
		it("should not fire a changed event if there were no dispatches", function()
			local store = Store.new(function()
			end)

			local count = 0
			store.changed:connect(function()
				count = count + 1
			end)

			store:flush()

			expect(count).to.equal(0)

			store:dispatch({
				type = "increment",
			})
			store:flush()

			expect(count).to.equal(1)

			store:flush()

			expect(count).to.equal(1)

			store:destruct()
		end)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBC8C0330B5944201BF0BE004DE19FD7C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">combineReducers</string>
						<string name="ScriptGuid">{6C526C5D-598D-4A8B-A5F4-8B7E12F7EBB5}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF5CEA15D0BC841648B7B27F33C1FFE51">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">combineReducers.spec</string>
						<string name="ScriptGuid">{3AF1E7FB-14CC-404F-A2DB-60E7D69A95EC}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local combineReducers = require(script.Parent.combineReducers)

	it("should invoke each sub-reducer for every action", function()
		local aCount = 0
		local bCount = 0

		local reducer = combineReducers({
			a = function(state, action)
				aCount = aCount + 1
			end,
			b = function(state, action)
				bCount = bCount + 1
			end,
		})

		-- Mock reducer invocation
		reducer({}, {})
		expect(aCount).to.equal(1)
		expect(bCount).to.equal(1)
	end)

	it("should assign each sub-reducer's value to the new state", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		local newState = reducer({}, {})
		expect(newState.a).to.equal(1)
		expect(newState.b).to.equal(3)
	end)

	it("should not throw when state is nil", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		expect(function()
			reducer(nil, {})
		end).to.never.throw()
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD8AEEBE6612E4069B7AE36720BF6566A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReducer</string>
						<string name="ScriptGuid">{6C6E897D-02FC-4EC8-A434-22244ACD8A3B}</string>
						<ProtectedString name="Source"><![CDATA[return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEFBC7DDC2994406BB093CE523448C71A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createReducer.spec</string>
						<string name="ScriptGuid">{B83F1F14-E049-486E-A7D4-5036D9472A28}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createReducer = require(script.Parent.createReducer)

	it("should handle actions", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		}, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer({
			a = 0,
			b = 0,
		}, {
			type = "a",
		})

		expect(newState.a).to.equal(1)

		newState = reducer(newState, {
			type = "b",
		})

		expect(newState.b).to.equal(2)
	end)

	it("should return the initial state if the state is nil", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		-- We don't care about the actions here
		}, {})

		local newState = reducer(nil, {})
		expect(newState).to.be.ok()
		expect(newState.a).to.equal(0)
		expect(newState.b).to.equal(0)
	end)

	it("should still run action handlers if the state is nil", function()
		local callCount = 0

		local reducer = createReducer(0, {
			foo = function(state, action)
				callCount = callCount + 1
				return nil
			end
		})

		expect(callCount).to.equal(0)

		local newState = reducer(nil, {
			type = "foo",
		})

		expect(callCount).to.equal(1)
		expect(newState).to.equal(nil)

		newState = reducer(newState, {
			type = "foo",
		})

		expect(callCount).to.equal(2)
		expect(newState).to.equal(nil)
	end)

	it("should return the same state if the action is not handled", function()
		local initialState = {
			a = 0,
			b = 0,
		}

		local reducer = createReducer(initialState, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer(initialState, {
			type = "c",
		})

		expect(newState).to.equal(initialState)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF983CDFB0E6D44C3984E7E6ED34AD7F6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid">{4CE8FC88-F4BD-4E7E-BE29-E1172C50C7EF}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	describe("Rodux", function()
		it("should load", function()
			local Rodux = require(script.Parent)

			expect(Rodux.Store).to.be.ok()
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX15C441B0D245485D9EC90F4EC22E0AFB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">loggerMiddleware</string>
						<string name="ScriptGuid">{E98EE678-7E3A-47D2-81D6-DFAAABC1AA51}</string>
						<ProtectedString name="Source"><![CDATA[local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for key, value in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(key))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(value, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9B6F14802A8B4BF8AD22CF374495A616">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">loggerMiddleware.spec</string>
						<string name="ScriptGuid">{6A6B887C-A2BB-458F-891A-BAE07A7AE117}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local loggerMiddleware = require(script.Parent.loggerMiddleware)

	it("should print whenever an action is dispatched", function()
		local outputCount = 0
		local outputMessage

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			fooValue = 12345,
			barValue = {
				bazValue = "hiBaz",
			},
		}, { loggerMiddleware.middleware })

		loggerMiddleware.outputFunction = function(message)
			outputCount = outputCount + 1
			outputMessage = message
		end

		store:dispatch({
			type = "testActionType",
		})

		expect(outputCount).to.equal(1)
		expect(outputMessage:find("testActionType")).to.be.ok()
		expect(outputMessage:find("fooValue")).to.be.ok()
		expect(outputMessage:find("12345")).to.be.ok()
		expect(outputMessage:find("barValue")).to.be.ok()
		expect(outputMessage:find("bazValue")).to.be.ok()
		expect(outputMessage:find("hiBaz")).to.be.ok()

		loggerMiddleware.outputFunction = print
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5331C47195CC4248A3B516E215CE8ADC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">thunkMiddleware</string>
						<string name="ScriptGuid">{73A44DF7-C48F-42DF-8AD1-D69F71DD62AD}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			return action(store)
		else
			return nextDispatch(action)
		end
	end
end

return thunkMiddleware
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX53CB33F7C2E94D6B967281F94C183F6A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">thunkMiddleware.spec</string>
						<string name="ScriptGuid">{3DDFB726-7D6A-40A8-B22D-D68C70109033}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local thunkMiddleware = require(script.Parent.thunkMiddleware)

	it("should dispatch thunks", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkCount = 0

		local function thunk(store)
			thunkCount = thunkCount + 1
		end

		store:dispatch(thunk)

		expect(thunkCount).to.equal(1)
	end)

	it("should allow normal actions to pass through", function()
		local reducerCount = 0

		local function reducer(state, action)
			reducerCount = reducerCount + 1
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })

		store:dispatch({
			type = "test",
		})

		-- Reducer will be invoked twice:
		-- Once when creating the store (@@INIT action)
		-- Once when the test action is dispatched
		expect(reducerCount).to.equal(2)
	end)

	it("should return the value from the thunk", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkValue = "test"

		local function thunk(store)
			return thunkValue
		end

		local result = store:dispatch(thunk)

		expect(result).to.equal(thunkValue)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB0D39E6638DE44078EBEA993D9BF16AB">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RichText</string>
					<string name="ScriptGuid">{8C3E83C3-8B41-4BAB-9443-94FE89FC5C54}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	
Rich text markup with support for modifying any TextLabel property per character + inline images + entrance animations

Written by Defaultio ~ August 30 2017

Changes:	
	October 21 2017 - Unicode support added thanks to Tiffany Bennett - https://gist.github.com/tiffany352/ccb3559738f4e8d4152d940126998c41
	January 29 2017 - Added finishAnimate parameter to RichTextObject:Show() function
					- Fixed bug on iOS devices causing some characters to fail to appear. Using TextWrapped = false on character labels fixed this, thanks Buildthomas.


			TODO:
				- exit animations
				- emphasis animations
				- support for inline buttons
				- sounds for each text step
				- markup events that will fire a callback provided in the constructor when the text animation is reached, use for character animations, etc
			
			Let me know if these features will be useful and I'll add them more quickly.

___________________________________________________________________________________________________________________

API:

Constructor:

	RichText:New(GuiObject frame, String text, Dictionary startingProperties = {}, Boolean allowOverflow = true)
		frame: the parent frame which will be populated with text
		text: self explanitory
		startingProperties: a dictionary of what the default text properties should be
		allowOverflow: if false, text will stop rendering when it fills the vertical height of the frame. To continue the text in another frame, see RichText:ContinueOverflow() below...
		
		returns: richText object
			
	RichText:ContinueOverflow(GuiObject nextFrame, RichTextObject previousRichTextObject)
		nextFrame: the parent frame that text will continue into
		previousRichTextObject: the previous RichTextObject that is being overflown from.
		
		returns: richTextObject
	
			
RichText Object: (returned by constructor)

	RichTextObject:Animate(doYield = false)
		Will run the animation. If doYield is true, the thread will yield until the animation is complete. Else, it will wrap the animation function in a coroutine
		
	RichTextObject:Show(finishAnimation = false)
		Shows the entirety of the text body. Will interrupt and stop the animation if it's running. if finishAnimation is true, the remaining text will animate in instead of appearing instantly.
		
	RichTextObject:Hide()
		Hides the text body. Will interrupt and stop the animation if it's running. The animation can be replayed after hiding.
		
	
	Vector2 RichTextObject.ContentSize
		Content size in pixels
		
	Boolean RichTextObject.Overflown
		If allowOverflow was false, this value shows if the text is overflown or if it fit in the frame. If overflown, use RichText:ContinueOverflow to continue into a new frame.
		


___________________________________________________________________________________________________________________

USAGE:

The text supplied in the constructor can be any text string. Insert a markup modifier by including <MarkupKey=MarkupValue>. No spaces.

	Examples of what this looks like include:
		<Font=ArialBold> --Set the font to ArialBold
		<Img=639588687> -- Insert an inline image with this ID
		<AnimateStepTime=0.4> -- Set the animate step time to 0.4 seconds.
		<AnimateYield=1> -- Yield for one second at this point in the animation
		<TextColor3=1,0,0> -- Set text color to red
		<Color=Red> -- Equivalent to above. The shortcut for the property name is defined in the propertyShortcuts table, and the color shortcut is defined in the colors table.
		
	After you set any markup value, you can revert it back to default later by setting it to "/". For example:
		<Font=/>
		<AnimateStepTime=/>
		<Color=/>
		
	Default values are defined by values in the "default" table below, or by values supplied in the startingProperties dictionary when the object is constructed.

Currently does not support escapement characters for < and >, so you can't use these characters in the text string.


To when using RichText:ContinueOverflow, calling Animate(), Show(), or Hide() on the initial RichText object will pass this call onto subsequent overflown rich text objects, so
only a call to the first object is neccessary. See example.

___________________________________________________________________________________________________________________

Example code:

	local richText = require(richTextModule)
	local text = "Hello world!\nLine two! <AnimateDelay=1><Img=Thinking>"
	local textObject = richText:New(frame, text)
	textObject:Animate(true)
	print("Animation done!")


Example string 1: Basic

	local text = "<Font=SourceSansBold><TextScale=0.3>Oh!<TextScale=/><Font=/><AnimateYield=1> I didn't see you there<AnimateStepFrequency=1><AnimateStepTime=0.4> . . .<AnimateStepFrequency=/><AnimateStepTime=/>\n I wasn't expecting <Color=255,0,0>you<Color=/>. Please forgive the state of my room.<AnimateYield=1><Img=639588687>"
	
	--This yields this result: https://twitter.com/Defaultio/status/903094769617747968


Example string 2: Wind Waker

	Insert the WindWakerExample ScreenGui in this module into StarterGui.
	Insert this module into WindWakerExample.
	Ensure WindWakerExample.LocalText is not Disabled.
	
	-- This yields this result: https://twitter.com/Defaultio/status/903138250054709248
	
	
Example string 3: Text-in animations

	local text = "This text is about to be <Color=Green><AnimateStyle=Wiggle><AnimateStepFrequency=1><AnimateStyleTime=2>wiggly<AnimateStyle=/><AnimateStepFrequency=/><AnimateStyleTime=/><Color=/>!<AnimateYield=1.5>\nIt can also be <Color=Red><AnimateStyle=Fade><AnimateStepFrequency=1><AnimateStyleTime=0.5>fadey fadey<AnimateStyle=/><AnimateStepFrequency=/><AnimateStyleTime=/><Color=/>!<AnimateYield=1>\n<AnimateStyle=Rainbow><AnimateStyleTime=2>Or rainbow!!! :O<AnimateStyle=/><AnimateStyleTime=/><AnimateYield=1>\n<AnimateStyle=Swing><AnimateStyleTime=3>Make custom animations!"
	
	-- This yields this result: https://twitter.com/Defaultio/status/903346975688425472
	
	
Example string 4: Variable text justification per line

	local text = "Have you ever <Color=Red>thought<Color=/><AnimateStepFrequency=1><AnimateStepTime=0.4> . . .<AnimateStepFrequency=/><AnimateStepTime=/><AnimateYield=1><ContainerHorizontalAlignment=Center>\n<TextScale=0.5><AnimateStyle=Rainbow><AnimateStyleTime=2.5><Img=Thinking><AnimateStyle=/><TextScale=/><AnimateYield=3><ContainerHorizontalAlignment=Right>\n<Color=Green><AnimateStyle=Spin><AnimateStyleTime=1.5>Wow<AnimateStyle=/><Color=/>!"

	-- This yields this result: https://twitter.com/Defaultio/status/903381787467956224

Example 5: Overflowing

	Insert the OverflowingExample ScreenGui in this module into StarterGui.
	Inert this module into the OverflowingExample ScreenGui.
	Ensure OverflowingExample.LocalText is not disabled.
	
	-- This yields this result: https://twitter.com/Defaultio/status/918619989107621888

___________________________________________________________________________________________________________________	
	
--]]

local richText = {}

--------- SHORTCUTS ---------

-- Color shortcuts: you can use these strings instead of full property names
local propertyShortcuts = {}
propertyShortcuts.Color = "TextColor3"
propertyShortcuts.StrokeColor = "TextStrokeColor3"
propertyShortcuts.ImageColor = "ImageColor3"

-- Color shortcuts: you can use these strings instead of defining exact color values
richText.ColorShortcuts = {}
richText.ColorShortcuts.White = Color3.new(1, 1, 1)
richText.ColorShortcuts.Black = Color3.new(0, 0, 0)
richText.ColorShortcuts.Red = Color3.new(1, 0.3, 0.4)
richText.ColorShortcuts.Green = Color3.new(0.4, 1, 0.4)
richText.ColorShortcuts.Blue = Color3.new(0.4, 0.4, 1)
richText.ColorShortcuts.Cyan = Color3.new(0.4, 0.85, 1)
richText.ColorShortcuts.Orange = Color3.new(1, 0.5, 0.2)
richText.ColorShortcuts.Yellow = Color3.new(1, 0.9, 0.2)

-- Image shortcuts: you can use these string instead of using image ids
richText.ImageShortcuts = {}
richText.ImageShortcuts.Eggplant = 639588687
richText.ImageShortcuts.Thinking = 955646496
richText.ImageShortcuts.Sad = 947900188
richText.ImageShortcuts.Happy = 414889555
richText.ImageShortcuts.Despicable = 711674643

--------- DEFAULTS ---------

local defaults = {}

--Text alignment default properties
defaults.ContainerHorizontalAlignment = "Left" -- Align,ent of text within frame container
defaults.ContainerVerticalAlignment = "Top" 
defaults.TextYAlignment = "Bottom" -- Alignment of the text on the line, only makes a difference if the line has variable text sizes

-- Text size default properties
defaults.TextScaled = true
defaults.TextScaleRelativeTo = "Frame" -- "Frame" or "Screen" If Frame, will scale relative to vertical size of the parent frame. If Screen, will scale relative to vertical size of the ScreenGui.
defaults.TextScale = 1 -- If you want the frame to have a nominal count of n lines of text, make this value 1 / n. For four lines, 1 / 4 = 0.25.
defaults.TextSize = 20 -- Only applicable if TextScaled = false

-- TextLabel default properties
defaults.Font = "SourceSans"
defaults.TextColor3 = "White"
defaults.TextStrokeColor3 = "Black"
defaults.TextTransparency = 0
defaults.TextStrokeTransparency = 1
defaults.BackgroundTransparency = 1
defaults.BorderSizePixel = 0

-- Image label default properties
defaults.ImageColor3 = "White"
defaults.ImageTransparency = 0
defaults.ImageRectOffset = "0,0"
defaults.ImageRectSize = "0,0"

-- Text animation default properties
	-- character appearance timing:
defaults.AnimateStepTime = 0 -- Seconds between newframes
defaults.AnimateStepGrouping = "Letter" -- "Word" or "Letter" or "All"
defaults.AnimateStepFrequency = 3 -- How often to step, 1 is all, 2 is step in pairs, 3 is every three, etc.
	-- yielding:
defaults.AnimateYield = 0 -- Set this markup to yield
	-- entrance style parameters:
defaults.AnimateStyle = "Fade"
defaults.AnimateStyleTime = 0.1 -- How long it takes for an entrance style to fully execute
defaults.AnimateStyleNumPeriods = 3 -- Used differently for each entrance style
defaults.AnimateStyleAmplitude = 0.5 -- Used differently for each entrance style


--------- ENTRANCE ANIMATION FUNCTIONS ---------

-- These are functions responsible for animating how text enters. The functions are passed:
	-- characters: A list of the characters to be animated.
	-- animateAlpha: A value of 0 - 1 that represents the lifetime of the animation
	-- properties: A dictionary of all the properties at that character, including InitialSize and InitialPosition
	
local animationStyles = {}

function animationStyles.Appear(character)
	character.Visible = true
end

function animationStyles.Fade(character, animateAlpha, properties)
	character.Visible = true
	if character:IsA("TextLabel") then
		character.TextTransparency = 1 - (animateAlpha * (1 - properties.TextTransparency))
	elseif character:IsA("ImageLabel") then
		character.ImageTransparency = 1 - (animateAlpha * (1 - properties.ImageTransparency))
	end
end

function animationStyles.Wiggle(character, animateAlpha, properties)
	character.Visible = true
	local amplitude = properties.InitialSize.Y.Offset * (1 - animateAlpha) * properties.AnimateStyleAmplitude
	character.Position = properties.InitialPosition + UDim2.new(0, 0, 0, math.sin(animateAlpha * math.pi * 2 * properties.AnimateStyleNumPeriods) * amplitude / 2)
end

function animationStyles.Swing(character, animateAlpha, properties)
	character.Visible = true
	local amplitude = 90 * (1 - animateAlpha) * properties.AnimateStyleAmplitude
	character.Rotation = math.sin(animateAlpha * math.pi * 2 * properties.AnimateStyleNumPeriods) * amplitude
end

function animationStyles.Spin(character, animateAlpha, properties)
	character.Visible = true
	character.Position = properties.InitialPosition + UDim2.new(0, properties.InitialSize.X.Offset / 2, 0, properties.InitialSize.Y.Offset / 2)
	character.AnchorPoint = Vector2.new(0.5, 0.5)
	character.Rotation = animateAlpha * properties.AnimateStyleNumPeriods * 360
end

function animationStyles.Rainbow(character, animateAlpha, properties)
	character.Visible = true
	local rainbowColor = Color3.fromHSV(animateAlpha * properties.AnimateStyleNumPeriods % 1, 1, 1)
	if character:IsA("TextLabel") then
		local initialColor = getColorFromString(properties.TextColor3)
		character.TextColor3 = Color3.new(rainbowColor.r + animateAlpha * (initialColor.r - rainbowColor.r), rainbowColor.g + animateAlpha * (initialColor.g - rainbowColor.g), rainbowColor.b + animateAlpha * (initialColor.b - rainbowColor.b))
	else
		local initialColor = getColorFromString(properties.ImageColor3)
		character.ImageColor3 = Color3.new(rainbowColor.r + animateAlpha * (initialColor.r - rainbowColor.r), rainbowColor.g + animateAlpha * (initialColor.g - rainbowColor.g), rainbowColor.b + animateAlpha * (initialColor.b - rainbowColor.b))
	end
end


--------- MODULE BEGIN ---------

local textService = game:GetService("TextService")
local runService = game:GetService("RunService")
local animationCount = 0

function getLayerCollector(frame)
	if not frame then
		return nil
	elseif frame:IsA("LayerCollector") then
		return frame
	elseif frame and frame.Parent then
		return getLayerCollector(frame.Parent)
	else
		return nil
	end
end

function shallowCopy(tab)
	local ret = {}
	for key, value in pairs(tab) do
		ret[key] = value
	end
	return ret
end

function getColorFromString(value)
	if richText.ColorShortcuts[value] then
		 return richText.ColorShortcuts[value]
	else
		local r, g, b = value:match("(%d+),(%d+),(%d+)")
		return Color3.new(r / 255, g / 255, b / 255)
	end
end

function getVector2FromString(value)
	local x, y = value:match("(%d+),(%d+)")
	return Vector2.new(x, y)
end

function setHorizontalAlignment(frame, alignment)
	if alignment == "Left" then
		frame.AnchorPoint = Vector2.new(0, 0)
		frame.Position = UDim2.new(0, 0, 0, 0)
	elseif alignment == "Center" then
		frame.AnchorPoint = Vector2.new(0.5, 0)
		frame.Position = UDim2.new(0.5, 0, 0, 0)
	elseif alignment == "Right" then
		frame.AnchorPoint = Vector2.new(1, 0)
		frame.Position = UDim2.new(1, 0, 0, 0)
	end
end

function richText:New(frame, text, startingProperties, allowOverflow, prevTextObject)
	for _, v in pairs(frame:GetChildren()) do
		v:Destroy()
	end
	if allowOverflow == nil then
		allowOverflow = true
	end
	
	local properties = {}
	local defaultProperties = {}
	if prevTextObject then
		text = prevTextObject.Text
		startingProperties = prevTextObject.StartingProperties
	end
	
	local lineFrames = {}
	local textFrames = {}
	local frameProperties = {}
	local linePosition = 0
	local overflown = false
	local textLabel = Instance.new("TextLabel")
	local imageLabel = Instance.new("ImageLabel")
	local layerCollector = getLayerCollector(frame)
	
	local applyProperty, applyMarkup, formatLabel, printText, printImage, printSeries
	
	----- Apply properties / markups -----
	function applyMarkup(key, value)
		key = propertyShortcuts[key] or key
		if value == "/" then
			if defaultProperties[key] then
				value = defaultProperties[key]
			else
				warn("Attempt to default <"..key.."> to value with no default")
			end
		end
		if tonumber(value) then
			value = tonumber(value)
		elseif value == "false" or value == "true" then
			value = value == "true"
		end
		properties[key] = value
		
		if applyProperty(key, value) then
			-- Ok
		elseif key == "ContainerHorizontalAlignment" and lineFrames[#lineFrames] then
			setHorizontalAlignment(lineFrames[#lineFrames].Container, value)
		elseif defaults[key] then
			-- Ok
		elseif key == "Img" then
			printImage(value)
		else
			-- Unknown value
			return false	
		end
		return true
	end
	
	function applyProperty(name, value, frame)
		local propertyType
		local ret = false
		for _, label in pairs(frame and {frame} or {textLabel, imageLabel}) do
			local isProperty = pcall(function() propertyType = typeof(label[name]) end) -- is there a better way to check if it's a property?
			if isProperty then
				if propertyType == "Color3" then
					label[name] = getColorFromString(value)
				elseif propertyType == "Vector2" then
					label[name] = getVector2FromString(value)
				else
					label[name] = value	
				end
				ret = true	
			end
		end
		return ret
	end
	
	----- Set up default properties -----
	for name, value in pairs(defaults) do
		applyMarkup(name, value)
		defaultProperties[propertyShortcuts[name] or name] = properties[propertyShortcuts[name] or name]
	end
	for name, value in pairs(startingProperties or {}) do
		applyMarkup(name, value)
		defaultProperties[propertyShortcuts[name] or name] = properties[propertyShortcuts[name] or name]
	end
	
	if prevTextObject then
		properties = prevTextObject.OverflowPickupProperties
		for name, value in pairs(properties) do
			applyMarkup(name, value)
		end
	end
	
	----- Get vertical size -----
	local function getTextSize()
		if properties.TextScaled == true then
			local relativeHeight
			if properties.TextScaleRelativeTo == "Screen" then
				relativeHeight = layerCollector.AbsoluteSize.Y
			elseif properties.TextScaleRelativeTo == "Frame" then
				relativeHeight = frame.AbsoluteSize.Y
			end
			return math.min(properties.TextScale * relativeHeight, 100)
		else
			return properties.TextSize
		end
	end
	
	----- Lines -----
	local contentHeight = 0
	local function newLine()
		local lastLineFrame = lineFrames[#lineFrames]
		if lastLineFrame then
			contentHeight = contentHeight + lastLineFrame.Size.Y.Offset
			if not allowOverflow and contentHeight + getTextSize() > frame.AbsoluteSize.Y then
				overflown = true
				return
			end
		end
		local lineFrame = Instance.new("Frame")
		lineFrame.Name = string.format("Line%03d", #lineFrames + 1)
		lineFrame.Size = UDim2.new(0, 0, 0, 0)
		lineFrame.BackgroundTransparency = 1		
		local textContainer = Instance.new("Frame", lineFrame)
		textContainer.Name = "Container"
		textContainer.Size = UDim2.new(0, 0, 0, 0)
		textContainer.BackgroundTransparency = 1
		setHorizontalAlignment(textContainer, properties.ContainerHorizontalAlignment)
		lineFrame.Parent = frame
		table.insert(lineFrames, lineFrame)
		textFrames[#lineFrames] = {}
		linePosition = 0
	end
	newLine()
	
	----- Label printing -----
	local function addFrameProperties(frame)
		frameProperties[frame] = shallowCopy(properties)
		frameProperties[frame].InitialSize = frame.Size
		frameProperties[frame].InitialPosition = frame.Position
		frameProperties[frame].InitialAnchorPoint = frame.AnchorPoint
	end
	
	function formatLabel(newLabel, labelHeight, labelWidth, endOfLineCallback)
		local lineFrame = lineFrames[#lineFrames]
		
		local verticalAlignment = tostring(properties.TextYAlignment)
		if verticalAlignment  == "Top" then
			newLabel.Position = UDim2.new(0, linePosition, 0, 0)
			newLabel.AnchorPoint = Vector2.new(0, 0)
		elseif verticalAlignment  == "Center" then
			newLabel.Position = UDim2.new(0, linePosition, 0.5, 0)
			newLabel.AnchorPoint = Vector2.new(0, 0.5)
		elseif verticalAlignment  == "Bottom" then
			newLabel.Position = UDim2.new(0, linePosition, 1, 0)
			newLabel.AnchorPoint = Vector2.new(0, 1)
		end
		
		linePosition = linePosition + labelWidth
		if linePosition > frame.AbsoluteSize.X and not (linePosition == labelWidth) then
			-- Newline, get rid of label and retry it on the next line
			newLabel:Destroy()
			local lastLabel = textFrames[#lineFrames][#textFrames[#lineFrames]]
			if lastLabel:IsA("TextLabel") and lastLabel.Text == " " then -- get rid of trailing space
				lineFrame.Container.Size = UDim2.new(0, linePosition - labelWidth - lastLabel.Size.X.Offset, 1, 0)
				lastLabel:Destroy()
				table.remove(textFrames[#lineFrames])
			end
			newLine()
			endOfLineCallback()
		else
			-- Label is ok
			newLabel.Size = UDim2.new(0, labelWidth, 0, labelHeight)
			lineFrame.Container.Size = UDim2.new(0, linePosition, 1, 0)
			lineFrame.Size = UDim2.new(1, 0, 0, math.max(lineFrame.Size.Y.Offset, labelHeight))
			newLabel.Name = string.format("Group%03d", #textFrames[#lineFrames] + 1)
			newLabel.Parent = lineFrame.Container
			table.insert(textFrames[#lineFrames], newLabel)
			addFrameProperties(newLabel)
			properties.AnimateYield = 0
		end
	end
	
	function printText(text)
		if text == "\n" then
			newLine()
			return
		elseif text == " " and linePosition == 0 then
			return -- no leading spaces
		end
		
		local textSize = getTextSize()
		local textWidth = textService:GetTextSize(text, textSize, textLabel.Font, Vector2.new(layerCollector.AbsoluteSize.X, textSize)).X
		
		local newTextLabel = textLabel:Clone()
		newTextLabel.TextScaled = false
		newTextLabel.TextSize = textSize
		newTextLabel.Text = text -- This text is never actually displayed. We just use it as a reference for knowing what the group string is.
		newTextLabel.TextTransparency = 1
		newTextLabel.TextStrokeTransparency = 1
		newTextLabel.TextWrapped = false
		
		-- Keep the real text in individual frames per character:
		local charPos = 0
		local i = 1
		for first, last in utf8.graphemes(text) do
			local character = string.sub(text, first, last)
			local characterWidth = textService:GetTextSize(character, textSize, textLabel.Font, Vector2.new(layerCollector.AbsoluteSize.X, textSize)).X
			local characterLabel = textLabel:Clone()
			characterLabel.Text = character
			characterLabel.TextScaled = false
			characterLabel.TextSize = textSize
			characterLabel.Position = UDim2.new(0, charPos, 0, 0)
			characterLabel.Size = UDim2.new(0, characterWidth, 0, textSize)
			characterLabel.Name = string.format("Char%03d", i)
			characterLabel.Parent = newTextLabel
			characterLabel.Visible = false
			addFrameProperties(characterLabel)
			charPos = charPos + characterWidth
			i = i + 1
		end

		formatLabel(newTextLabel, textSize, textWidth, function() if not overflown then printText(text) end end)
	end
	
	function printImage(imageId)
		local imageHeight = getTextSize()
		local imageWidth = imageHeight -- Would be nice if we could get aspect ratio of image to get width properly.
		
		local newImageLabel = imageLabel:Clone()
		
		if richText.ImageShortcuts[imageId] then
			newImageLabel.Image = typeof(richText.ImageShortcuts[imageId]) == "number" and "rbxassetid://"..richText.ImageShortcuts[imageId] or richText.ImageShortcuts[imageId]
		else
			newImageLabel.Image = "rbxassetid://"..imageId
		end
		newImageLabel.Size = UDim2.new(0, imageHeight, 0, imageWidth)
		newImageLabel.Visible = false

		formatLabel(newImageLabel, imageHeight, imageWidth, function() if not overflown then printImage(imageId) end end)
	end
	
	function printSeries(labelSeries)	
		for _, t in pairs(labelSeries) do
			local markupKey, markupValue = string.match(t, "<(.+)=(.+)>")
			if markupKey and markupValue then
				if not applyMarkup(markupKey, markupValue) then
					warn("Could not apply markup: ", t)
				end			
			else
				printText(t)
			end
		end	
	end
	
	----- Text traversal + parsing -----
	local overflowText
	local textPos = 1
	local textLength = #text
	local labelSeries = {}
	
	if prevTextObject then
		textPos = prevTextObject.OverflowPickupIndex
	end
	
	while textPos and textPos <= textLength do
		local nextMarkupStart, nextMarkupEnd = string.find(text, "<.->", textPos)
		local nextSpaceStart, nextSpaceEnd = string.find(text, "[ \t\n]", textPos)
		
		local nextBreakStart, nextBreakEnd, breakIsWhitespace
		if nextMarkupStart and nextMarkupEnd and (not nextSpaceStart or nextMarkupStart < nextSpaceStart) then
			nextBreakStart, nextBreakEnd = nextMarkupStart, nextMarkupEnd
		else
			nextBreakStart, nextBreakEnd = nextSpaceStart or textLength + 1, nextSpaceEnd or textLength + 1
			breakIsWhitespace = true
		end
		
		local nextWord = nextBreakStart > textPos and string.sub(text, textPos, nextBreakStart - 1) or nil
		local nextBreak = nextBreakStart <= textLength and string.sub(text, nextBreakStart, nextBreakEnd) or nil
		table.insert(labelSeries, nextWord)
		
		if breakIsWhitespace then
			printSeries(labelSeries)
			if overflown then
				break
			end
			printSeries({nextBreak})
			if overflown then
				textPos = nextBreakStart
				break
			end
			labelSeries = {}
		else
			table.insert(labelSeries, nextBreak)
		end
		
		textPos = nextBreakEnd + 1
		--textPos = utf8.offset(text, 2, nextBreakEnd)
	end
	
	if not overflown then
		printSeries(labelSeries)
	end

	----- Alignment layout -----
	local listLayout = Instance.new("UIListLayout")
	listLayout.HorizontalAlignment = properties.ContainerHorizontalAlignment
	listLayout.VerticalAlignment = properties.ContainerVerticalAlignment
	listLayout.Parent = frame
	
	----- Calculate content size -----
	local contentHeight = 0
	local contentLeft = frame.AbsoluteSize.X
	local contentRight = 0
	for _, lineFrame in pairs(lineFrames) do
		contentHeight = contentHeight + lineFrame.Size.Y.Offset
		local container = lineFrame.Container
		local left, right
		if container.AnchorPoint.X == 0 then
			left = container.Position.X.Offset
			right = container.Size.X.Offset
		elseif container.AnchorPoint.X == 0.5 then
			left = lineFrame.AbsoluteSize.X / 2 - container.Size.X.Offset / 2
			right = lineFrame.AbsoluteSize.X / 2 + container.Size.X.Offset / 2
		elseif container.AnchorPoint.X == 1 then
			left = lineFrame.AbsoluteSize.X - container.Size.X.Offset
			right = lineFrame.AbsoluteSize.X
		end
		contentLeft = math.min(contentLeft, left)
		contentRight = math.max(contentRight, right)
	end
	
	----- Animation -----
	animationCount = animationCount + 1
	local animationDone = false
	local allTextReached = false
	local overrideYield = false
	local animationRenderstepBinding = "TextAnimation"..animationCount
	local animateQueue = {}
	
	local function updateAnimations()
		if allTextReached and #animateQueue == 0 or animationDone then
			animationDone = true
			runService:UnbindFromRenderStep(animationRenderstepBinding)
			animateQueue = {}
			return
		end

		local t = tick()
		for i = #animateQueue, 1, -1 do
			local set = animateQueue[i]
			local properties = set.Settings
			local animateStyle = animationStyles[properties.AnimateStyle]
			if not animateStyle then
				warn("No animation style found for: ", properties.AnimateStyle, ", defaulting to Appear")
				animateStyle = animationStyles.Appear
			end
			local animateAlpha = math.min((t - set.Start) / properties.AnimateStyleTime, 1)
			animateStyle(set.Char, animateAlpha, properties) 
			if animateAlpha >= 1 then
				table.remove(animateQueue, i)
			end
		end
	end
	
	local function setFrameToDefault(frame)
		frame.Position = frameProperties[frame].InitialPosition
		frame.Size = frameProperties[frame].InitialSize
		frame.AnchorPoint = frameProperties[frame].InitialAnchorPoint
		for name, value in pairs(frameProperties[frame]) do
			applyProperty(name, value, frame)
		end
	end

	local function setGroupVisible(frame, visible)
		frame.Visible = visible
		for _, v in pairs(frame:GetChildren()) do
			v.Visible = visible
			if visible then
				setFrameToDefault(v)
			end
		end
		if visible and frame:IsA("ImageLabel") then
			setFrameToDefault(frame)
		end
	end

	local function animate(waitForAnimationToFinish)
		animationDone = false
		runService:BindToRenderStep(animationRenderstepBinding, Enum.RenderPriority.Last.Value, updateAnimations)

		local stepGrouping
		local stepTime
		local stepFrequency
		local numAnimated
		
		-- Make everything invisible to start
		for lineNum, list in pairs(textFrames) do
			for _, frame in pairs(list) do
				setGroupVisible(frame, false)
			end
		end
	
		local function animateCharacter(char, properties)
			table.insert(animateQueue, {Char = char, Settings = properties, Start = tick()})
		end
		
		local function yield()
			if not overrideYield and numAnimated % stepFrequency == 0 and stepTime >= 0 then
				local yieldTime = stepTime > 0 and stepTime or nil
				wait(yieldTime)
			end
		end
		
		for lineNum, list in pairs(textFrames) do
			for _, frame in pairs(list) do
				local properties = frameProperties[frame]
				if not (properties.AnimateStepGrouping  == stepGrouping) or not (properties.AnimateStepFrequency == stepFrequency) then
					numAnimated = 0
				end
				stepGrouping = properties.AnimateStepGrouping
				stepTime = properties.AnimateStepTime
				stepFrequency = properties.AnimateStepFrequency
			
				if properties.AnimateYield > 0 then
					wait(properties.AnimateYield)
				end

				if stepGrouping == "Word" or stepGrouping == "All" then
					--if not (frame:IsA("TextLabel") and (frame.Text == " ")) then
						if frame:IsA("TextLabel") then
							frame.Visible = true
							for _, v in pairs(frame:GetChildren()) do
								animateCharacter(v, frameProperties[v])
							end
						else
							animateCharacter(frame, properties)
						end
						if stepGrouping == "Word" then
							numAnimated = numAnimated + 1
							yield()
						end
					--end
				elseif stepGrouping == "Letter" then
					if frame:IsA("TextLabel") --[[and not (frame.Text == " ") ]]then
						frame.Visible = true
						local text = frame.Text
						local i = 1
						while true do
							local v = frame:FindFirstChild(string.format("Char%03d", i))
							if not v then
								break
							end
							animateCharacter(v, frameProperties[v])
							numAnimated = numAnimated + 1
							yield()
							if animationDone then
								return
							end
							i = i + 1
						end
					else
						animateCharacter(frame, properties)
						numAnimated = numAnimated + 1
						yield()
					end
				else
					warn("Invalid step grouping: ", stepGrouping)
				end
				
				if animationDone then
					return
				end
			end
		end
			
		allTextReached = true
		
		if waitForAnimationToFinish then
			while #animateQueue > 0 do
				runService.RenderStepped:Wait()
			end
		end	
	end
	


	local textObject = {}
	
	----- Overflowing -----
	
	textObject.Overflown = overflown
	textObject.OverflowPickupIndex = textPos
	textObject.StartingProperties = startingProperties
	textObject.OverflowPickupProperties = properties
	textObject.Text = text

	if prevTextObject then
		prevTextObject.NextTextObject = textObject
	end
	
	-- to overflow: check if textObject.Overflown, then use richText:ContinueOverflow(newFrame, textObject) to continue to another frame.
	
	
	----- Return object API -----

	textObject.ContentSize = Vector2.new(contentRight - contentLeft, contentHeight)

	function textObject:Animate(yield)
		if yield then
			animate()
		else
			coroutine.wrap(animate)()
		end
		if self.NextTextObject then
			self.NextTextObject:Animate(yield)
		end
	end
	
	function textObject:Show(finishAnimation)
		if finishAnimation then
			overrideYield = true
		else
			animationDone = true
			for lineNum, list in pairs(textFrames) do
				for _, frame in pairs(list) do
					setGroupVisible(frame, true)
				end
			end
		end
		if self.NextTextObject then
			self.NextTextObject:Show(finishAnimation)
		end
	end
	
	function textObject:Hide()
		animationDone = true
		for lineNum, list in pairs(textFrames) do
			for _, frame in pairs(list) do
				setGroupVisible(frame, false)
			end
		end
		if self.NextTextObject then
			self.NextTextObject:Hide()
		end
	end
	
	return textObject
end


function richText:ContinueOverflow(newFrame, prevTextObject)
	return richText:New(newFrame, nil, nil, false, prevTextObject)
end


return richText
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAC781507A22C4098B8C552FEDB34CA97">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Otter</string>
					<string name="ScriptGuid">{8D3EF636-406D-450C-9995-B741197CC4AB}</string>
					<ProtectedString name="Source"><![CDATA[return {
	createGroupMotor = require(script.createGroupMotor),
	createSingleMotor = require(script.createSingleMotor),
	spring = require(script.spring),
	instant = require(script.instant),
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX37030B002DD94F2BBE3CCDCDDE42BC93">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">assign</string>
						<string name="ScriptGuid">{71328342-F41A-48F3-99D5-B0178CE619AD}</string>
						<ProtectedString name="Source"><![CDATA[local function assign(target, ...)
	for i = 1, select("#", ...) do
		local source = select(i, ...)

		for key, value in pairs(source) do
			target[key] = value
		end
	end

	return target
end

return assign]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAE5EE4B5988F41A29C270C82E273BE0D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createGroupMotor</string>
						<string name="ScriptGuid">{D00CA300-F1D3-4354-AF7E-AB6CE7A9883E}</string>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local assign = require(script.Parent.assign)
local createSignal = require(script.Parent.createSignal)

local GroupMotor = {}
GroupMotor.prototype = {}
GroupMotor.__index = GroupMotor.prototype

local function createGroupMotor(initialValues)
	assert(typeof(initialValues) == "table")

	local states = {}

	for key, value in pairs(initialValues) do
		states[key] = {
			value = value,
			complete = true,
		}
	end

	local self = {
		__goals = {},
		__states = states,
		__allComplete = true,
		__onComplete = createSignal(),
		__onStep = createSignal(),
	}

	setmetatable(self, GroupMotor)

	return self
end

function GroupMotor.prototype:start()
	self.__connection = RunService.RenderStepped:Connect(function(dt)
		self:step(dt)
	end)
end

function GroupMotor.prototype:stop()
	if self.__connection ~= nil then
		self.__connection:Disconnect()
	end
end

function GroupMotor.prototype:step(dt)
	assert(typeof(dt) == "number")

	if self.__allComplete then
		return
	end

	local allComplete = true
	local values = {}

	for key, state in pairs(self.__states) do
		if not state.complete then
			local goal = self.__goals[key]

			if goal ~= nil then
				local maybeNewState = goal:step(state, dt)

				if maybeNewState ~= nil then
					state = maybeNewState
					self.__states[key] = maybeNewState
				end
			else
				state.complete = true
			end

			if not state.complete then
				allComplete = false
			end
		end

		values[key] = state.value
	end

	local wasAllComplete = self.__allComplete
	self.__allComplete = allComplete

	self.__onStep:fire(values)

	if allComplete and not wasAllComplete then
		self.__onComplete:fire(values)
	end
end

function GroupMotor.prototype:setGoal(goals)
	assert(typeof(goals) == "table")

	self.__goals = assign({}, self.__goals, goals)

	for key in pairs(goals) do
		local state = self.__states[key]

		if state == nil then
			error(("Cannot set goal for the value %s because it doesn't exist"):format(tostring(key)), 2)
		end

		state.complete = false
	end

	self.__allComplete = false
end

function GroupMotor.prototype:onStep(callback)
	assert(typeof(callback) == "function")

	return self.__onStep:subscribe(callback)
end

function GroupMotor.prototype:onComplete(callback)
	assert(typeof(callback) == "function")

	return self.__onComplete:subscribe(callback)
end

function GroupMotor.prototype:destroy()
	self:stop()
end

return createGroupMotor]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCA7ADE5349D443B381BA04BCD4D5A03C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createGroupMotor.spec</string>
						<string name="ScriptGuid">{6306EA4D-0243-4042-B655-1D72CD37617D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local validateMotor = require(script.Parent.validateMotor)
	local createSpy = require(script.Parent.createSpy)

	local createGroupMotor = require(script.Parent.createGroupMotor)

	-- test motion object that completes after step has been called numSteps times
	local function createStepper(numSteps)
		local self = {
			stepCount = 0,
		}

		self.step = function(_, state, dt)
			self.stepCount = self.stepCount + 1

			if self.stepCount >= numSteps then
				return {
					value = state.value,
					velocity = state.velocity,
					complete = true,
				}
			end

			return state
		end

		setmetatable(self, {
			__index = function(_, key)
				error(("%q is not a valid member of stepper"):format(key))
			end,
		})

		return self
	end

	it("should be a valid motor", function()
		local motor = createGroupMotor({})
		validateMotor(motor)
		motor:destroy()
	end)

	describe("onStep", function()
		it("should not be called initially", function()
			local motor = createGroupMotor({
				x = 0,
			})

			local spy = createSpy()
			motor:onStep(spy.value)

			motor:setGoal({
				x = createStepper(5),
			})

			expect(spy.callCount).to.equal(0)
		end)
	end)

	describe("onComplete should be called when", function()
		it("has completed its motion", function()
			local motor = createGroupMotor({
				x = 0,
			})

			motor:setGoal({
				x = createStepper(5),
			})

			local spy = createSpy()

			motor:onComplete(spy.value)

			for _ = 1, 5 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(1)

			motor:destroy()
		end)

		it("has multiple atributes in motion", function()
			local motor = createGroupMotor({
				x = 0,
				y = 10,
			})

			motor:setGoal({
				x = createStepper(2),
				y = createStepper(5),
			})

			local spy = createSpy()

			motor:onComplete(spy.value)

			for _ = 1, 2 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(0)

			for _ = 1, 3 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(1)

			motor:destroy()
		end)

		it("has restarted its motion", function()
			local motor = createGroupMotor({
				x = 0,
			})

			motor:setGoal({
				x = createStepper(3),
			})

			local spy = createSpy()

			motor:onComplete(spy.value)

			for _ = 1, 3 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(1)

			motor:setGoal({
				x = createStepper(3),
			})

			for _ = 1, 3 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(2)

			motor:destroy()
		end)
	end)

	describe("onComplete should not be called when", function()
		it("has no goals set", function()
			local motor = createGroupMotor({
				x = 2,
			})

			local spy = createSpy()
			motor:onComplete(spy.value)

			for _ = 1, 3 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)

		it("has not completed motion", function()
			local motor = createGroupMotor({
				x = 0,
			})

			motor:setGoal({
				x = createStepper(2),
			})

			local spy = createSpy()
			motor:onComplete(spy.value)

			motor:step(1)

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)

		it("has one non-completed motion", function()
			local motor = createGroupMotor({
				x = 0,
				y = 0,
			})

			motor:setGoal({
				x = createStepper(0),
				y = createStepper(2),
			})

			local spy = createSpy()
			motor:onComplete(spy.value)

			motor:step(1)

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)

		it("does not call step", function()
			local motor = createGroupMotor({
				x = 0,
			})

			motor:setGoal({
				x = createStepper(0),
			})

			local spy = createSpy()
			motor:onComplete(spy.value)

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX27F4CA659273409781F30F0427E65A3C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal</string>
						<string name="ScriptGuid">{0C7A3A00-9066-43CD-BDE6-E31CFC69D5D6}</string>
						<ProtectedString name="Source"><![CDATA[local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXECF5110872BF45C38059F7D6F08AF0B1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal.spec</string>
						<string name="ScriptGuid">{52C3FE1C-A81A-477B-81A1-1EDF10B3F640}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createSignal = require(script.Parent.createSignal)

	local createSpy = require(script.Parent.createSpy)

	it("should fire subscribers and disconnect them", function()
		local signal = createSignal()

		local spy = createSpy()
		local disconnect = signal:subscribe(spy.value)

		expect(spy.callCount).to.equal(0)

		local a = 1
		local b = {}
		local c = "hello"
		signal:fire(a, b, c)

		expect(spy.callCount).to.equal(1)
		spy:assertCalledWith(a, b, c)

		disconnect()

		signal:fire()

		expect(spy.callCount).to.equal(1)
	end)

	it("should handle multiple subscribers", function()
		local signal = createSignal()

		local spyA = createSpy()
		local spyB = createSpy()

		local disconnectA = signal:subscribe(spyA.value)
		local disconnectB = signal:subscribe(spyB.value)

		expect(spyA.callCount).to.equal(0)
		expect(spyB.callCount).to.equal(0)

		local a = {}
		local b = 67
		signal:fire(a, b)

		expect(spyA.callCount).to.equal(1)
		spyA:assertCalledWith(a, b)

		expect(spyB.callCount).to.equal(1)
		spyB:assertCalledWith(a, b)

		disconnectA()

		signal:fire(b, a)

		expect(spyA.callCount).to.equal(1)

		expect(spyB.callCount).to.equal(2)
		spyB:assertCalledWith(b, a)

		disconnectB()
	end)

	it("should stop firing a connection if disconnected mid-fire", function()
		local signal = createSignal()

		-- In this test, we'll connect two listeners that each try to disconnect
		-- the other. Because the order of listeners firing isn't defined, we
		-- have to be careful to handle either case.

		local disconnectA
		local disconnectB

		local spyA = createSpy(function()
			disconnectB()
		end)

		local spyB = createSpy(function()
			disconnectA()
		end)

		disconnectA = signal:subscribe(spyA.value)
		disconnectB = signal:subscribe(spyB.value)

		signal:fire()

		-- Exactly once listener should have been called.
		expect(spyA.callCount + spyB.callCount).to.equal(1)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA9AA54C5C5F74AC9B5916EAA69AC4661">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSingleMotor</string>
						<string name="ScriptGuid">{C6590021-83A5-4141-9AD0-FE35651EF834}</string>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local createSignal = require(script.Parent.createSignal)

local SingleMotor = {}
SingleMotor.prototype = {}
SingleMotor.__index = SingleMotor.prototype

local function createSingleMotor(initialValue)
	assert(typeof(initialValue) == "number")

	local self = {
		__goal = nil,
		__state = {
			value = initialValue,
			complete = true,
		},
		__onComplete = createSignal(),
		__onStep = createSignal(),
	}

	setmetatable(self, SingleMotor)

	return self
end

function SingleMotor.prototype:start()
	self.__connection = RunService.RenderStepped:Connect(function(dt)
		self:step(dt)
	end)
end

function SingleMotor.prototype:stop()
	if self.__connection ~= nil then
		self.__connection:Disconnect()
	end
end

function SingleMotor.prototype:step(dt)
	assert(typeof(dt) == "number")

	if self.__state.complete then
		return
	end

	if self.__goal == nil then
		return
	end

	local newState = self.__goal:step(self.__state, dt)

	if newState ~= nil then
		self.__state = newState
	end

	self.__onStep:fire(self.__state.value)

	if self.__state.complete then
		self.__onComplete:fire(self.__state.value)
	end
end

function SingleMotor.prototype:setGoal(goal)
	self.__goal = goal
	self.__state.complete = false
end

function SingleMotor.prototype:onStep(callback)
	assert(typeof(callback) == "function")

	return self.__onStep:subscribe(callback)
end

function SingleMotor.prototype:onComplete(callback)
	assert(typeof(callback) == "function")

	return self.__onComplete:subscribe(callback)
end

function SingleMotor.prototype:destroy()
	self:stop()
end

return createSingleMotor]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9C0C8E1227784F2491EE40E70CD9CAF0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSingleMotor.spec</string>
						<string name="ScriptGuid">{7C26A65A-02D3-456F-AF21-DE14218171EA}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local validateMotor = require(script.Parent.validateMotor)
	local createSpy = require(script.Parent.createSpy)

	local createSingleMotor = require(script.Parent.createSingleMotor)


	local identityGoal = {
		step = function(self, state, dt)
			return state
		end,
	}

	-- test motion object that completes after step has been called numSteps times
	local function createStepper(numSteps)
		local self = {
			stepCount = 0,
		}

		self.step = function(_, state, dt)
			self.stepCount = self.stepCount + 1

			if self.stepCount >= numSteps then
				return {
					value = state.value,
					velocity = state.velocity,
					complete = true,
				}
			end

			return state
		end

		setmetatable(self, {
			__index = function(_, key)
				error(("%q is not a valid member of stepper"):format(key))
			end,
		})

		return self
	end

	it("should be a valid motor", function()
		local motor = createSingleMotor(0)
		validateMotor(motor)
		motor:destroy()
	end)

	it("should invoke subscribers with new values", function()
		local motor = createSingleMotor(8)
		motor:setGoal(identityGoal)

		local spy = createSpy()

		local disconnect = motor:onStep(spy.value)

		expect(spy.callCount).to.equal(0)

		motor:step(1)

		expect(spy.callCount).to.equal(1)
		spy:assertCalledWith(8)

		disconnect()

		motor:step(1)

		expect(spy.callCount).to.equal(1)
	end)

	describe("onComplete should be called when", function()
		it("has completed its motion", function()
			local motor = createSingleMotor(0)
			motor:setGoal(createStepper(5))

			local spy = createSpy()

			motor:onComplete(spy.value)

			for _ = 1, 5 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(1)

			motor:destroy()
		end)

		it("has restarted its motion", function()
			local motor = createSingleMotor(0)
			motor:setGoal(createStepper(5))

			local spy = createSpy()

			motor:onComplete(spy.value)

			expect(spy.callCount).to.equal(0)

			for _ = 1, 5 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(1)

			motor:setGoal(createStepper(5))

			for _ = 1, 5 do
				motor:step(1)
			end

			expect(spy.callCount).to.equal(2)

			motor:destroy()
		end)
	end)

	describe("onComplete should not be called when", function()
		it("has not completed motion", function()
			local motor = createSingleMotor(0)
			motor:setGoal(createStepper(10))

			local spy = createSpy()

			motor:onComplete(spy.value)

			motor:step(1)

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)

		it("does not call step", function()
			local motor = createSingleMotor(0)
			motor:setGoal(createStepper(0))

			local spy = createSpy()

			motor:onComplete(spy.value)

			expect(spy.callCount).to.equal(0)

			motor:destroy()
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX85BB1F293C014811980960865C0C4B74">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSpy</string>
						<string name="ScriptGuid">{E9032175-6A37-408B-81ED-ED32809C3C9C}</string>
						<ProtectedString name="Source"><![CDATA[local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		assert(self.valuesLength, len, "length of expected values differs from stored values")

		for i = 1, len do
			local expected = select(i, ...)
			assert(self.values[i], expected, "value differs")
		end
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX369601491DF14959B4525C9EEDDE4AF0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid">{01371DDB-56A7-4007-B490-F4D26FE49BCB}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	itFIXME("should load successfully", function()
		require(script.Parent)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE7ADDA77EFFE47CA8E3E60C8F2F62F38">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">instant</string>
						<string name="ScriptGuid">{200544F3-4F1B-4AD2-AB32-9C20201072C8}</string>
						<ProtectedString name="Source"><![CDATA[local function step(self, state, dt)
	return {
		value = self.__targetValue,
		complete = true,
	}
end

local function instant(targetValue)
	return {
		__targetValue = targetValue,
		step = step,
	}
end

return instant]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX336D6FCE4E4645C49D222C0D0348AECE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">instant.spec</string>
						<string name="ScriptGuid">{924CFE5E-2576-45D8-ABD2-0DE8D8AE40E1}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local instant = require(script.Parent.instant)

	it("should have the expected APIs", function()
		local goal = instant(5)

		expect(goal).to.be.a("table")
		expect(goal.step).to.be.a("function")
	end)

	it("should immediately complete", function()
		local state = {
			value = 5,
			complete = false,
		}

		local goal = instant(10)
		state = goal:step(state, 1e-3)

		expect(state.value).to.equal(10)
		expect(state.complete).to.equal(true)
	end)

	it("should remove extra values from state", function()
		local state = {
			value = 5,
			complete = false,

			velocity = 7,
			somethingElse = {},
		}

		local goal = instant(10)
		state = goal:step(state, 1e-3)

		expect(state.velocity).to.never.be.ok()
		expect(state.somethingElse).to.never.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX092F489FBD5E40EBB99E46FB7D14B408">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">spring</string>
						<string name="ScriptGuid">{1F2BCD05-45E2-41E7-89B4-D3FA75547A58}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	An analytical spring solution as a function of damping ratio and frequency.

	Adapted from
	https://gist.github.com/Fraktality/1033625223e13c01aa7144abe4aaf54d
]]

local assign = require(script.Parent.assign)

local pi = math.pi
local abs = math.abs
local exp = math.exp
local sin = math.sin
local cos = math.cos
local sqrt = math.sqrt

local RESTING_VELOCITY_LIMIT = 1e-3
local RESTING_POSITION_LIMIT = 1e-2

local function step(self, state, dt)
	-- Advance the spring simulation by dt seconds.
	-- Take the damped harmonic oscillator ODE:
	--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
	-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
	-- Apply constant initial conditions:
	--    X[0] = p0
	--    X'[0] = v0
	-- Solve the IVP to get analytic expressions for X[t] and X'[t].
	-- The solution takes on one of three forms for d=1, d<1, and d>1

	local d = self.__dampingRatio
	local f = self.__frequency * 2 * pi -- Rad/s
	local g = self.__goalPosition

	local p0 = state.value
	local v0 = state.velocity or 0

	local offset = p0 - g
	local decay = exp(-dt*d*f)

	local p1, v1

	if d == 1 then -- Critically damped
		p1 = (v0*dt + offset*(f*dt + 1))*decay + g
		v1 = (v0 - f*dt*(offset*f + v0))*decay

	elseif d < 1 then -- Underdamped
		local c = sqrt(1 - d*d)

		local i = cos(f*c*dt)
		local j = sin(f*c*dt)

		-- Problem: Damping ratios close to 1 can cause numerical instability.
		-- Solution: Rearrange to group terms involving j/c, then find an approximation z for j/c.
		--    z = sin(dt*f*c)/c
		-- Substitute a for dt*f
		--    z = sin(a*c)/c
		-- Take the 5th-order series expansion of z at c = 0
		--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
		--    z  a - (a^3*c^2)/6 + (a^5*c^4)/120
		-- Rewrite in Horner form to mitigate precision issues
		--    z  a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

		local z
		if c > 1e-4 then
			z = j/c
		else
			local a = dt*f
			z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
		end

		-- Repeat the process with a->dt and c->b=f*c for the f->0 case
		local y
		if f*c > 1e-4 then
			y = j/(f*c)
		else
			local b = f*c
			y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
		end

		p1 = (offset*(i + d*z) + v0*y)*decay + g
		v1 = (v0*(i - z*d) - offset*(z*f))*decay

	else -- Overdamped
		local c = sqrt(d*d - 1)

		local r1 = -f*(d - c)
		local r2 = -f*(d + c)

		local co2 = (v0 - r1*offset)/(2*f*c)
		local co1 = offset - co2

		local e1 = co1*exp(r1*dt)
		local e2 = co2*exp(r2*dt)

		p1 = e1 + e2 + g
		v1 = r1*e1 + r2*e2
	end

	local positionOffset = abs(p1 - self.__goalPosition)
	local velocityOffset = abs(v1)

	local complete = velocityOffset < RESTING_VELOCITY_LIMIT and positionOffset < RESTING_POSITION_LIMIT

	if complete then
		p1 = self.__goalPosition
		v1 = 0
	end

	return {
		value = p1,
		velocity = v1,
		complete = complete,
	}
end

local function spring(goalPosition, inputOptions)
	assert(typeof(goalPosition) == "number")

	local options = {
		dampingRatio = 1,
		frequency = 1,
	}

	if inputOptions ~= nil then
		assert(typeof(inputOptions) == "table")
		assign(options, inputOptions)
	end

	local dampingRatio = options.dampingRatio
	local frequency = options.frequency

	assert(typeof(dampingRatio) == "number")
	assert(typeof(frequency) == "number")

	assert(dampingRatio * frequency >= 0, "Expected dampingRatio * frequency >= 0")

	local self = {
		__dampingRatio = dampingRatio,
		__frequency = frequency, -- Hz
		__goalPosition = goalPosition,
		step = step,
	}

	return self
end

return spring
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX40A627999F73481B9814DB90DA132F4B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">spring.spec</string>
						<string name="ScriptGuid">{D3A05847-F320-4A59-8BF4-9A8440499E2D}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local spring = require(script.Parent.spring)

	it("should have all expected APIs", function()
		expect(spring).to.be.a("function")

		local s = spring(1, {
			dampingRatio = 0.1,
			frequency = 10,
		})

		expect(s).to.be.a("table")
		expect(s.step).to.be.a("function")

		-- handle when spring lacks option table
		s = spring(1)

		expect(s).to.be.a("table")
		expect(s.step).to.be.a("function")
	end)

	it("should handle being still correctly", function()
		local s = spring(1, {
			dampingRatio = 0.1,
			frequency = 10,
		})

		local state = s:step({
			value = 1,
			velocity = 0,
			complete = false,
		}, 1)

		expect(state.value).to.equal(1)
		expect(state.velocity).to.equal(0)
		expect(state.complete).to.equal(true)
	end)

	it("should return not complete when in motion", function()
		local goal = spring(100, {
			dampingRatio = 0.1,
			frequency = 10,
		})

		local state = {
			value = 1,
			velocity = 0,
			complete = false,
		}

		state = goal:step(state, 1e-3)

		expect(state.value < 100).to.equal(true)
		expect(state.velocity > 0).to.equal(true)
		expect(state.complete).to.equal(false)
	end)

	describe("should eventaully complete when", function()
		it("is critically damped", function()
			local s = spring(3, {
				dampingRatio = 1,
				frequency = 0.5,
			})

			local state = {
				value = 1,
				velocity = 0,
				complete = false,
			}

			while not state.complete do
				state = s:step(state, 0.5)
			end

			expect(state.complete).to.equal(true)
			expect(state.value).to.equal(3)
			expect(state.velocity).to.equal(0)
		end)

		it("is over damped", function()
			local s = spring(3, {
				dampingRatio = 10,
				frequency = 0.5,
			})

			local state = {
				value = 1,
				velocity = 0,
				complete = false,
			}

			while not state.complete do
				state = s:step(state, 0.5)
			end

			expect(state.complete).to.equal(true)
			expect(state.value).to.equal(3)
			expect(state.velocity).to.equal(0)
		end)

		it("is under damped", function()
			local s = spring(3, {
				dampingRatio = 0.1,
				frequency = 0.5,
			})

			local state = {
				value = 1,
				velocity = 0,
				complete = false,
			}

			while not state.complete do
				state = s:step(state, 0.5)
			end

			expect(state.complete).to.equal(true)
			expect(state.value).to.equal(3)
			expect(state.velocity).to.equal(0)
		end)
	end)

	it("should remain complete when completed", function()
		local s = spring(3, {
			dampingRatio = 1,
			frequency = 0.5,
		})

		local state = {
			value = 1,
			velocity = 0,
			complete = false,
		}

		while not state.complete do
			state = s:step(state, 0.5)
		end
		state = s:step(state, 0.5)

		expect(state.complete).to.equal(true)
		expect(state.value).to.equal(3)
		expect(state.velocity).to.equal(0)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7E68802C165E4D1F90E8003145EF8748">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">validateMotor</string>
						<string name="ScriptGuid">{B1DC372C-8C8A-4170-8C71-FEE03104827B}</string>
						<ProtectedString name="Source"><![CDATA[local function validateMotor(motor)
	assert(typeof(motor) == "table")
	assert(typeof(motor.start) == "function")
	assert(typeof(motor.stop) == "function")
	assert(typeof(motor.step) == "function")
	assert(typeof(motor.setGoal) == "function")
	assert(typeof(motor.onStep) == "function")
	assert(typeof(motor.onComplete) == "function")
	assert(typeof(motor.destroy) == "function")
end

return validateMotor]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX64C953BCC28C42B8A5D5AFC051A257C2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RECS</string>
					<string name="ScriptGuid">{B9D031BA-A4F8-458E-9152-C2A0F3FCD408}</string>
					<ProtectedString name="Source"><![CDATA[local defineRegistration = require(script.defineRegistration)

return {
    Core = require(script.Core),
    defineComponent = require(script.defineComponent),
    System = require(script.System),
    interval = defineRegistration.interval,
    event = defineRegistration.event,
    BuiltInPlugins = require(script.BuiltInPlugins),
}
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX41ACD5DAE9094163850CB4E04ED8691A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core</string>
						<string name="ScriptGuid">{EAB43062-F683-43B2-9CEB-92D78D8F6CDA}</string>
						<ProtectedString name="Source"><![CDATA[--[[

    A RECS Core is the root of a RECS setup. It contains systems, entities, and
    component registrations, and is responsible for managing all of these.

    Many Core methods operate on the concept of a "component identifier", which
    can be two different things, for ease of use. A component identifier is
    either a component class itself or the name of one.

    Cores have a notion of plugins, which allow running code during some steps
    of the Core that you wouldn't otherwise be able to. Plugins allow you to
    bypass some of the separation of concerns that RECS normally encourages.
    When taking advantage of this, you should be very careful - the structure
    that RECS encourages is there for a reason, and you should think carefully
    about whether you _need_ to bypass it.

    Plugins are specified in the Core constructor as an array. A plugin must
    be a table with a set of methods. Currently, the following plugin methods
    are supported by the Core:

    - coreInit(Core): Called when the Core initializes.
    - componentRegistered(Core, componentClass): Called when a component class
      is registered in the core.
    - componentAdded(Core, entityId, componentInstance): Called when a component
      instance is added to an entity. Called before the addition signal for that
      component has been fired.
    - componentRemoving(Core, entityId, componentInstance): Called when a
      component instance is being removed from an entity, i.e. during entity
      destruction or when removing a component. Called after the removal signal
      for that component has been fired.
    - singletonAdded(Core, singletonInstance): Called when a singleton component
      is added to the Core.
    - beforeSystemStart(Core): Called during Core::start, before systems' init
      methods have been called.
    - afterSystemStart(Core): Called during Core::start, after systems' init
      methods have been called but before steppers start.
    - afterStepperStart(Core): Called during Core::start, after steppers start.

    All plugin methods are optional.

]]

local HttpService = game:GetService("HttpService")

local EventStepper = require(script.Parent.EventStepper)
local TimeStepper = require(script.Parent.TimeStepper)
local createSignal = require(script.Parent.createSignal)

local errorMessages = {
    invalidIdentifier = "%q, a %s, is not a valid identifier for a component class",
    componentNotRegistered = "The component %q is not registered in this Core",
    componentClassAlreadyRegistered = "The component class %q is already registered in this Core",
    componentNotApplicable = "The component %q cannot be added to the entity %q of type %s",
    singletonAlreadyAdded = "A singleton component for class %q is already added to this Core",
    singletonNotPresent = "The singleton component for class %q does not exist in this Core",
    systemNotRegistered = "The system %q is not registered in this Core",
    systemClassAlreadyRegistered = "The system class %q is already registered in this Core",
    unknownStepperType = "Unknown stepper type %q. This is a RECS bug; please report it",
}

--[[

    Resolves a class name from a "component identifier", which may be either a
    class name or a component definition. Cores use class names to index
    components internally.

]]
local function resolveComponentByIdentifier(componentIdentifier)
    if typeof(componentIdentifier) == "string" then
        return componentIdentifier
    elseif typeof(componentIdentifier) == "table" then
        -- Assume it's a component class for efficiency / zoomies
        return componentIdentifier.className
    else
        error(errorMessages.invalidIdentifier:format(
            tostring(componentIdentifier),
            typeof(componentIdentifier)),
        3)
    end
end

local Core = {}
Core.__index = Core

--[[

    Given an optional array of plugins, creates a new RECS Core. A Core is,
    functionally, the entire ECS.

]]
function Core.new(plugins)
    local self = setmetatable({
        -- All component instances in the Core. Structure:
        -- [componentClassName] = {
        --     [entityId] = componentInstance,
        -- }
        _components = {},
        -- A map of component class names to component class definitions.
        _componentClasses = {},
        -- A map of singleton component class names to singleton component instances.
        -- Singleton components are instances of regular component classes that
        -- are not attached to an entity.
        _singletons = {},
        -- A map of system class names to system instances.
        _systems = {},
        -- An array of all the steppers in the Core.
        _steppers = {},
        -- A map of component class names to component added signals.
        _componentAddedSignals = {},
        -- A map of component class names to component removing signals.
        _componentRemovingSignals = {},
        -- A map of signals to raise functions.
        _signalRaisers = {},
        -- An array of all the plugins that the Core is using.
        _plugins = plugins or {},
    }, Core)

    self:__callPluginMethod("coreInit")

    return self
end

--[[

    An internal method that calls a method on all plugins, if present, in the
    order specified, with given arguments. Used to make plugins more ergonomic.

    Plugin methods are called with the Core as the first argument.

]]
function Core:__callPluginMethod(methodName, ...)
    for _, plugin in ipairs(self._plugins) do
        if plugin[methodName] ~= nil then
            plugin[methodName](plugin, self, ...)
        end
    end
end

--[[

    Tests if a component can be added to an entity.

    Throws if this is not the case.

]]
function Core:__checkIfCanAddComponentToEntity(componentClass, entityId)
    if componentClass.entityFilter ~= nil and not componentClass.entityFilter(entityId) then
        error(
            errorMessages.componentNotApplicable:format(
                componentClass.className,
                tostring(entityId),
                typeof(entityId)),
        3)
    end
end

--[[

    Registers a component class with the Core. This method will throw if a
    component class with the same name has already been registered.

]]
function Core:registerComponent(componentClass)
    local name = componentClass.className

    if self._componentClasses[name] ~= nil then
        error(errorMessages.componentClassAlreadyRegistered:format(
            name
        ), 2)
    end

    self._componentClasses[name] = componentClass
    self._components[name] = {}

    local addedSignal, raiseAdded = createSignal()
    local removingSignal, raiseRemoved = createSignal()

    self._componentAddedSignals[name] = addedSignal
    self._componentRemovingSignals[name] = removingSignal
    self._signalRaisers[addedSignal] = raiseAdded
    self._signalRaisers[removingSignal] = raiseRemoved

    self:__callPluginMethod("componentRegistered", componentClass)
end

--[[

    Given an instance, traverses its children. If a child is a ModuleScript, it
    is required and the return result is passed to registerComponent. If a child
    is a Folder, its children are inspected using the same process. Other
    instance classes are ignored.

    Throws if one of the component classes has already been registered in the Core.

]]
function Core:registerComponentsInInstance(rootInstance)
    for _, child in ipairs(rootInstance:GetChildren()) do
        if child:IsA("ModuleScript") then
            self:registerComponent(require(child))
        elseif child:IsA("Folder") then
            self:registerComponentsInInstance(child)
        end
    end
end

--[[

    Given a component class name, gets the class that was registered in the Core.

    Throws if the component class has not been registered.

]]
function Core:getComponentClass(className)
    local componentClass = self._componentClasses[className]

    if componentClass == nil then
        error(errorMessages.componentNotRegistered:format(className), 2)
    end

    return componentClass
end

--[[

    Creates a new entity and returns an identifier for the entity that can be
    used in calls to other Core methods.

    Do not rely upon any details of the return type. The only guarantee RECS
    makes about the return value of this function is that it is serializable
    as-is.

]]
function Core:createEntity()
    -- The Core is using a hash map for storing component records.
    -- HttpService::GenerateGUID may be too slow for use, and can be replaced
    -- later if need be.
    return HttpService:GenerateGUID(true)
end

--[[

    Given an entity ID, destroys the entity, removing all components from it.
    This method will do nothing if the entity ID is invalid, was not part of
    this Core, or was destroyed already.

]]
function Core:destroyEntity(entityId)
    -- Call plugin methods and fire removal signals before disturbing the
    -- actual component.
    for componentClassName, componentInstances in pairs(self._components) do
        local componentInstance = componentInstances[entityId]

        if componentInstance ~= nil then
            local removingSignal = self._componentRemovingSignals[componentClassName]
            local raise = self._signalRaisers[removingSignal]
            raise(entityId, componentInstance)

            self:__callPluginMethod("componentRemoving", entityId, componentInstance)
        end
    end

    for componentClassName, componentInstances in pairs(self._components) do
        componentInstances[entityId] = nil
    end
end

--[[

    Given an entity ID and a component identifier, returns the component
    attached to the entity, or nil.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:getComponent(entityId, componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)
    local componentInstances = self._components[componentIdentifier]

    if componentInstances ~= nil then
        return componentInstances[entityId]
    else
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end
end

--[[

    Given an entity ID and a component identifier, returns a boolean indicating
    whether the entity has an instance of the component attached to it.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:hasComponent(entityId, componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)

    -- We could implement this in terms of getComponent but then the stack level
    -- for getComponent's error message would be wrong - it would point at this
    -- component, not the caller of hasComponent. Thus, hasComponent is built
    -- from the ground up here.
    local componentInstances = self._components[componentIdentifier]

    if componentInstances ~= nil then
        return componentInstances[entityId] ~= nil
    else
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end
end

--[[

    Given an entity ID and a component identifier, adds a new instance of the
    component to the entity. Returns a boolean that is true if the component
    was added, and false if it already existed on the entity, followed by the
    added component.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:addComponent(entityId, componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)
    local componentClass = self._componentClasses[componentIdentifier]

    if componentClass ~= nil then
        self:__checkIfCanAddComponentToEntity(componentClass, entityId)

        local componentInstances = self._components[componentIdentifier]
        local componentInstance = componentInstances[entityId]

        if componentInstance ~= nil then
            -- Don't re-create the component or overwrite what's already there!
            return false, componentInstance
        else
            componentInstance = componentClass._create()
            componentInstances[entityId] = componentInstance

            self:__callPluginMethod("componentAdded", entityId, componentInstance)

            local signal = self._componentAddedSignals[componentIdentifier]
            self._signalRaisers[signal](entityId, componentInstance)
        end

        return true, componentInstance
    else
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end
end

--[[

    Given an entity ID and a tuple of component identifiers, adds all the
    components to the entity. Returns nothing, unlike addComponent.
    batchAddComponents will add all components to an entity before firing
    any added signals or invoking plugins' componentAdded callbacks.

    Throws if any of the identified component classes aren't registered in the Core.

]]
function Core:batchAddComponents(entityId, ...)
    local createdInstances = {}
    local identifierCount = select("#", ...)

    for i = 1, identifierCount do
        local rawIdentifier = select(i, ...)
        local convertedIdentifier = resolveComponentByIdentifier(rawIdentifier)
        local componentClass = self._componentClasses[convertedIdentifier]

        if componentClass == nil then
            error(errorMessages.componentNotRegistered:format(convertedIdentifier), 2)
        end

        self:__checkIfCanAddComponentToEntity(componentClass, entityId)

        local componentInstances = self._components[convertedIdentifier]

        -- It's possible that you could call batchAddComponents when a component
        -- already exists on the entity, so we should avoid leaking existing
        -- components if they exist.
        if componentInstances[entityId] == nil then
            local componentInstance = componentClass._create()
            createdInstances[convertedIdentifier] = componentInstance
            componentInstances[entityId] = componentInstance
        end
    end

    for identifier, componentInstance in pairs(createdInstances) do
        self:__callPluginMethod("componentAdded", entityId, componentInstance)

        local addedSignal = self._componentAddedSignals[identifier]
        self._signalRaisers[addedSignal](entityId, componentInstance)
    end
end

--[[

    Given an entity ID and a component identifier, removes the component
    instance from the entity. Returns true plus the removed component if there
    was a component instance attached to the entity, or false if there wasn't.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:removeComponent(entityId, componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)
    local componentInstances = self._components[componentIdentifier]

    if componentInstances ~= nil then
        local componentInstance = componentInstances[entityId]

        if componentInstance == nil then
            return false
        end

        local signal = self._componentRemovingSignals[componentIdentifier]
        self._signalRaisers[signal](entityId, componentInstance)

        self:__callPluginMethod("componentRemoving", entityId, componentInstance)

        componentInstances[entityId] = nil
        return true, componentInstance
    else
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end
end

--[[

    Given an entity ID and a series of component identifiers, removes all
    specified component instances from the entity. Unlike removeComponent, does
    not return anything. batchRemoveComponents will fire all removal signals and
    invoke all plugins before actually removing components.

    Throws if any of the identified component classes aren't registered in the Core.

]]
function Core:batchRemoveComponents(entityId, ...)
    local toRemove = {}
    local identifierCount = select("#", ...)

    for i = 1, identifierCount do
        local rawIdentifier = select(i, ...)
        local convertedIdentifier = resolveComponentByIdentifier(rawIdentifier)
        local componentInstances = self._components[convertedIdentifier]

        if componentInstances == nil then
            error(errorMessages.componentNotRegistered:format(convertedIdentifier), 2)
        end

        local componentInstance = componentInstances[entityId]

        if componentInstance ~= nil then
            local removingSignal = self._componentRemovingSignals[convertedIdentifier]
            self._signalRaisers[removingSignal](entityId, componentInstance)

            self:__callPluginMethod("componentRemoving", entityId, componentInstance)

            table.insert(toRemove, componentInstances)
        end
    end

    for _, instances in ipairs(toRemove) do
        instances[entityId] = nil
    end
end

--[[

    Given a tuple of component identifiers, returns an iterator function over
    all the entities with a given set of components. The iterator function, when
    called, will yield the entity ID, followed by each component in the order
    specified. Callers should avoid adding or removing components in the set
    the iterator is using; RECS does not guarantee that the iterator will remain
    stable in this case.

    The iterator is not ordered in any way, and you should not rely on the order
    that the iterator returns entity IDs. Return values will be ordered, but the
    order of iteration is undefined.

    Throws if any of the identified component classes aren't registered in the Core.

]]
function Core:components(...)
    local count = select("#", ...)

    -- We don't have to do a lot of work if there's only one component!
    -- Most of the bulk of this method is handling multiple arguments; when
    -- there's only one, the workload is much lighter.
    if count == 1 then
        local rawIdentifier = ...
        local convertedIdentifier = resolveComponentByIdentifier(rawIdentifier)

        local map = self._components[convertedIdentifier]

        if map == nil then
            error(errorMessages.componentNotRegistered:format(convertedIdentifier), 2)
        end

        -- Pairs returns an iterator (or something that can be used as one, anyways)
        return pairs(map)
    end

    -- Use a constant table to accumulate results in to avoid unnecessary table
    -- allocations and resizing
    local result = {}
    local componentMaps = {}

    -- Convert the supplied identifiers to internal keys and look up the
    -- component maps. Also perform error checking now, since it's a relatively
    -- cheap place to do it.
    for i = 1, count do
        local rawIdentifier = select(i, ...)
        local convertedIdentifier = resolveComponentByIdentifier(rawIdentifier)

        local map = self._components[convertedIdentifier]

        if map == nil then
            error(errorMessages.componentNotRegistered:format(convertedIdentifier), 2)
        end

        componentMaps[i] = map
    end

    -- We iterate over this map to get entity IDs.
    local firstMap = componentMaps[1]

    -- Coroutine iterators are cool!
    -- Wrapping the function in coroutine.wrap and outputting values with
    -- coroutine.yield means we can write _almost_ the same code that we would
    -- to generate a table, except it's an iterator!
    return coroutine.wrap(function()
        -- For now, we iterate over the first component. There is an
        -- optimization that we can do: pick the component map with the least
        -- number of entities in it, and iterate over that. All other maps are
        -- indexed into using the entity ID we get from here, so iterating over
        -- the smallest map should improve performance!
        -- Since maps have no notion of size, we have to track it separately,
        -- but it should be pretty easy to do this sort of bookkeeping in
        -- addComponent and removeComponent, and it shouldn't desynchronize.
        for entityId, firstComponent in pairs(firstMap) do
            local entityHasAllComponents = true

            result[1] = entityId
            result[2] = firstComponent

            -- We don't need to iterate over any other map because we already
            -- have a key to look up.
            for i = 2, count do
                local otherMap = componentMaps[i]
                local otherComponent = otherMap[entityId]

                if otherComponent == nil then
                    entityHasAllComponents = false
                    -- No reason to continue looking; we already know this
                    -- entity doesn't fit the criteria.
                    break
                else
                    -- Increment i by 1, since index 1 is the entity ID.
                    result[i + 1] = otherComponent
                end
            end

            -- Only yield the coroutine if we have a full results table.
            if entityHasAllComponents then
                coroutine.yield(unpack(result))
            end
        end
    end)
end

--[[

    Gets a signal that fires whenever a component is added to an entity. The
    signal will be fired with the entity ID and the component that was added.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:getComponentAddedSignal(componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)

    local signal = self._componentAddedSignals[componentIdentifier]
    if signal == nil then
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end

    return signal
end

--[[

    Gets a signal that fires whenever a component is removed from an entity. The
    signal will be fired with the entity ID and the component that was removed.

    Throws if the identified component class isn't registered in the Core.

]]
function Core:getComponentRemovingSignal(componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)

    local signal = self._componentRemovingSignals[componentIdentifier]
    if signal == nil then
        error(errorMessages.componentNotRegistered:format(componentIdentifier), 2)
    end

    return signal
end

--[[

    Adds a singleton component to the Core. Returns the component instance.

    Throws if the singleton component already exists on the Core.

]]
function Core:addSingleton(componentClass)
    local singletonIdentifier = componentClass.className

    if self._singletons[singletonIdentifier] == nil then
        local singleton = componentClass._create()
        self._singletons[singletonIdentifier] = singleton

        self:__callPluginMethod("singletonAdded", singleton)

        return singleton
    else
        error(errorMessages.singletonAlreadyAdded:format(singletonIdentifier), 2)
    end
end

--[[

    Given a component identifier, returns the singleton component attached to
    this Core.

    Throws if the singleton doesn't exist on the Core.

]]
function Core:getSingleton(componentIdentifier)
    componentIdentifier = resolveComponentByIdentifier(componentIdentifier)

    local singleton = self._singletons[componentIdentifier]

    if singleton == nil then
        error(errorMessages.singletonNotPresent:format(componentIdentifier), 2)
    end

    return singleton
end

--[[

    Registers a system class with the Core and creates an internal instance of
    the system. The system's init method will not be called until Core::start is
    called.

    Throws if the system class has already been registered in the Core.

]]
function Core:registerSystem(systemClass)
    if self._systems[systemClass.name] ~= nil then
        error(errorMessages.systemClassAlreadyRegistered:format(systemClass.name), 2)
    end

    local system = systemClass._create(self)
    self._systems[systemClass.name] = system
end

--[[

    Given a table of system classes, registers all of them with the Core.

    Throws if one of the system classes has already been registered in the Core.

]]
function Core:registerSystems(systems)
    -- Deliberately use pairs to accept either a map or an array.
    for _, systemClass in pairs(systems) do
        self:registerSystem(systemClass)
    end
end

--[[

    Given an instance, traverses its children. If a child is a ModuleScript, it
    is required and the return result is passed to registerSystem. If a child is
    a Folder, its children are inspected using the same process. Other classes
    are ignored.

    Throws if one of the system classes has already been registered in the Core.

]]
function Core:registerSystemsInInstance(rootInstance)
    for _, child in ipairs(rootInstance:GetChildren()) do
        if child:IsA("ModuleScript") then
            self:registerSystem(require(child))
        elseif child:IsA("Folder") then
            self:registerSystemsInInstance(child)
        end
    end
end

--[[

    Registers a stepper definition in the Core. The same stepper definition may
    be registered multiple times, though this is likely not intentional. This
    method must be called after all systems being stepped have been registered.

    Throws if one of the systems being stepped has not been registered yet.

    Throws if given an unknown stepper type. This error indicates a RECS bug.

]]
function Core:registerStepper(stepperDefinition)
    local systemInstances = {}

    for _, class in ipairs(stepperDefinition.systemClasses) do
        local instance = self._systems[class.name]

        if instance == nil then
            error(errorMessages.systemNotRegistered:format(class.name), 2)
        end

        table.insert(systemInstances, instance)
    end

    if stepperDefinition.type == "event" then
        table.insert(self._steppers, EventStepper.new(stepperDefinition.event, systemInstances))
    elseif stepperDefinition.type == "interval" then
        table.insert(self._steppers, TimeStepper.new(stepperDefinition.interval, systemInstances))
    else
        error(errorMessages.unknownStepperType:format(stepperDefinition.type), 2)
    end
end

--[[

    Given a table of stepper definitions, registers all of them in the Core.

    Throws if one of the systems being stepped has not been registered yet.

    Throws if given an unknown stepper type. This error indicates a RECS bug.

]]
function Core:registerSteppers(steppers)
    -- Deliberately use pairs to accept either a map or an array.
    for _, stepperDefinition in pairs(steppers) do
        self:registerStepper(stepperDefinition)
    end
end

--[[

    Starts the Core, calling init on all systems that possess the method and
    starting all steppers. After calling this method, the Core and all
    functionality represented by it will begin running your game's code.

    The order in which systems are initialized and steppers are started is not
    to be relied upon. Structure your code such that you do not depend on
    ordering in this case.

]]
function Core:start()
    self:__callPluginMethod("beforeSystemStart")

    -- Initialize all systems first.
    for _, system in pairs(self._systems) do
        -- Systems are not required to declare an init method, and a no-op one
        -- is not provided in the default System class.
        if system.init ~= nil then
            system:init()
        end
    end

    self:__callPluginMethod("afterSystemStart")

    -- Now start all steppers.
    for _, stepper in ipairs(self._steppers) do
        stepper:start()
    end

    self:__callPluginMethod("afterStepperStart")
end

return Core
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX32DB1FB27C734CFF955803D7C69A9B94">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core.spec</string>
						<string name="ScriptGuid">{66F39101-BE2F-47EC-982F-B409D71CF70E}</string>
						<ProtectedString name="Source"><![CDATA[-- luacheck: std +testez
local Core = require(script.Parent.Core)
local defineComponent = require(script.Parent.defineComponent)
local System = require(script.Parent.System)

return function()
    describe("new", function()
        it("should create new cores", function()
            local core = Core.new()
            expect(core).to.be.ok()
        end)
    end)

    describe("createEntity", function()
        it("should return a value", function()
            local core = Core.new()
            expect(core:createEntity()).to.be.ok()
        end)

        it("should return different values each time", function()
            local core = Core.new()
            local seenValues = {}

            for i = 1, 100 do
                local entityId = core:createEntity()
                assert(seenValues[entityId] == nil, "createEntity returned a duplicate value")
                seenValues[entityId] = true
            end
        end)
    end)

    describe("registerComponent", function()
        local ComponentClass = defineComponent({
            name = "TestComponent",
            generator = function()
                return {}
            end
        })

        it("should succeed when called", function()
            local core = Core.new()
            core:registerComponent(ComponentClass)
        end)

        it("should throw when registering a component repeatedly", function()
            local core = Core.new()
            core:registerComponent(ComponentClass)

            expect(function()
                core:registerComponent(ComponentClass)
            end).to.throw()
        end)
    end)

    describe("addSingleton", function()
        local SingletonClass = defineComponent({
            name = "TestSingleton",
            generator = function()
                return {}
            end
        })

        it("should add singleton components", function()
            local core = Core.new()
            local singleton = core:addSingleton(SingletonClass)
            expect(singleton).to.be.ok()
            expect(core:getSingleton(SingletonClass)).to.be.ok()
            expect(core:getSingleton(SingletonClass)).to.equal(singleton)
        end)

        it("should throw if the singleton is already added", function()
            local core = Core.new()
            core:addSingleton(SingletonClass)

            expect(function()
                core:addSingleton(SingletonClass)
            end).to.throw()
        end)
    end)

    describe("getSingleton", function()
        local SingletonClass = defineComponent({
            name = "TestSingleton",
            generator = function()
                return {}
            end
        })

        it("should get singleton components", function()
            local core = Core.new()
            local singleton = core:addSingleton(SingletonClass)
            expect(singleton).to.be.ok()
            expect(core:getSingleton(SingletonClass)).to.be.ok()
            expect(core:getSingleton(SingletonClass)).to.equal(singleton)
        end)

        it("should throw if the singleton isn't added", function()
            local core = Core.new()

            expect(function()
                core:getSingleton(SingletonClass)
            end).to.throw()
        end)
    end)

    describe("registerSystem", function()
        it("should succeed when called", function()
            local TestSystem = System:extend("TestSystem")
            local core = Core.new()
            core:registerSystem(TestSystem)
        end)

        it("should throw when registering a system repeatedly", function()
            local TestSystem = System:extend("TestSystem")
            local core = Core.new()
            core:registerSystem(TestSystem)

            expect(function()
                core:registerSystem(TestSystem)
            end).to.throw()
        end)

        it("should not call System:init", function()
            local TestSystem = System:extend("TestSystem")

            function TestSystem:init()
                error("System:init was called")
            end

            local core = Core.new()
            core:registerSystem(TestSystem)
        end)
    end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9E67B1B9CA09421581C3D659E4A408B3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">addComponent.spec</string>
							<string name="ScriptGuid">{1F3A86B4-CE86-4A30-A136-817B024AA104}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentClass = defineComponent({
        name = "TestComponent",
        generator = function()
            return {}
        end
    })

    it("should add components", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)
    end)

    it("should return the added component", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local addedNew, component = core:addComponent(entity, ComponentClass)
        expect(addedNew).to.equal(true)
        expect(component).to.be.ok()
    end)

    it("should return false plus the existing component if the component already exists", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local _, addedComponent = core:addComponent(entity, ComponentClass)
        local addedNew, component = core:addComponent(entity, ComponentClass)
        expect(addedNew).to.equal(false)
        expect(component).to.equal(addedComponent)
    end)

    it("should throw if the component has not been registered", function()
        local core = Core.new()
        local entity = core:createEntity()

        expect(function()
            core:addComponent(entity, ComponentClass)
        end).to.throw()
    end)

    it("should throw if the component's entityFilter forbids the addition", function()
        local core = Core.new()
        local entity = core:createEntity()

        local FilteredComponent = defineComponent({
            name = "Filtered",
            generator = function()
                return {}
            end,
            entityFilter = function(testEntity)
                expect(testEntity).to.equal(entity)
                return false
            end,
        })

        core:registerComponent(FilteredComponent)

        expect(function()
            core:addComponent(entity, FilteredComponent)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX67D3E16F979C4B9984B79438D837C7B4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">batchAddComponents.spec</string>
							<string name="ScriptGuid">{37287D26-55E3-44AB-A070-532FD3071B22}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentA = defineComponent({
        name = "A",
        generator = function()
            return {}
        end,
    })

    local ComponentB = defineComponent({
        name = "B",
        generator = function()
            return {}
        end,
    })

    local ComponentC = defineComponent({
        name = "C",
        generator = function()
            return {}
        end,
    })

    it("should add components", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local entity = core:createEntity()
        core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)
        expect(core:hasComponent(entity, ComponentA)).to.equal(true)
        expect(core:hasComponent(entity, ComponentB)).to.equal(true)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)
    end)

    it("should not replace components", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local entity = core:createEntity()
        local _, addedA = core:addComponent(entity, ComponentA)
        core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)

        expect(core:hasComponent(entity, ComponentA)).to.equal(true)
        expect(core:hasComponent(entity, ComponentB)).to.equal(true)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)
        expect(core:getComponent(entity, ComponentA)).to.equal(addedA)
    end)

    it("should fire events after all components have been added", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local signalA = core:getComponentAddedSignal(ComponentA)
        signalA:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentB)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentC)).to.equal(true)
        end)

        local signalB = core:getComponentAddedSignal(ComponentB)
        signalB:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentA)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentC)).to.equal(true)
        end)

        local signalC = core:getComponentAddedSignal(ComponentC)
        signalC:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentA)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentB)).to.equal(true)
        end)

        local entity = core:createEntity()
        core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)
        expect(core:hasComponent(entity, ComponentA)).to.equal(true)
        expect(core:hasComponent(entity, ComponentB)).to.equal(true)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)
    end)

    it("should throw if any of the components have not been registered", function()
        local core = Core.new()
        local entity = core:createEntity()

        expect(function()
            core:batchAddComponents(entity, ComponentA)
        end).to.throw()

        core:registerComponent(ComponentA)

        expect(function()
            core:batchAddComponents(entity, ComponentA, ComponentB)
        end).to.throw()

        core:registerComponent(ComponentC)

        expect(function()
            core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)
        end).to.throw()
    end)

    it("should throw if a component's entityFilter forbids the addition", function()
        local core = Core.new()
        local entity = core:createEntity()

        local FilteredComponent = defineComponent({
            name = "Filtered",
            generator = function()
                return {}
            end,
            entityFilter = function(testEntity)
                expect(testEntity).to.equal(entity)
                return false
            end,
        })

        core:registerComponent(FilteredComponent)

        expect(function()
            core:batchAddComponents(entity, FilteredComponent)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8E690F2E14ED4363A48C3377D0AE567B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">batchRemoveComponents.spec</string>
							<string name="ScriptGuid">{3CF8C15E-D3EE-47BB-9027-08475B025C25}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentA = defineComponent({
        name = "A",
        generator = function()
            return {}
        end,
    })

    local ComponentB = defineComponent({
        name = "B",
        generator = function()
            return {}
        end,
    })

    local ComponentC = defineComponent({
        name = "C",
        generator = function()
            return {}
        end,
    })

    it("should remove components", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local entity = core:createEntity()
        core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)
        expect(core:hasComponent(entity, ComponentA)).to.equal(true)
        expect(core:hasComponent(entity, ComponentB)).to.equal(true)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)

        core:batchRemoveComponents(entity, ComponentA, ComponentB)
        expect(core:hasComponent(entity, ComponentA)).to.equal(false)
        expect(core:hasComponent(entity, ComponentB)).to.equal(false)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)
    end)

    it("should work even if the components don't exist on the entity", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local entity = core:createEntity()
        core:batchRemoveComponents(entity, ComponentA, ComponentB)
        expect(core:hasComponent(entity, ComponentA)).to.equal(false)
        expect(core:hasComponent(entity, ComponentB)).to.equal(false)
    end)

    it("should fire events before removing any components", function()
        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)
        core:registerComponent(ComponentC)

        local signalA = core:getComponentRemovingSignal(ComponentA)
        signalA:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentB)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentC)).to.equal(true)
        end)

        local signalB = core:getComponentRemovingSignal(ComponentB)
        signalB:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentA)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentC)).to.equal(true)
        end)

        local signalC = core:getComponentRemovingSignal(ComponentC)
        signalC:connect(function(entityId, _)
            expect(core:hasComponent(entityId, ComponentA)).to.equal(true)
            expect(core:hasComponent(entityId, ComponentB)).to.equal(true)
        end)

        local entity = core:createEntity()
        core:batchAddComponents(entity, ComponentA, ComponentB, ComponentC)
        expect(core:hasComponent(entity, ComponentA)).to.equal(true)
        expect(core:hasComponent(entity, ComponentB)).to.equal(true)
        expect(core:hasComponent(entity, ComponentC)).to.equal(true)

        core:batchRemoveComponents(entity, ComponentA, ComponentB, ComponentC)
    end)

    it("should throw if any of the components have not been registered", function()
        local core = Core.new()
        local entity = core:createEntity()

        expect(function()
            core:batchRemoveComponents(entity, ComponentA)
        end).to.throw()

        core:registerComponent(ComponentA)

        expect(function()
            core:batchRemoveComponents(entity, ComponentA, ComponentB)
        end).to.throw()

        core:registerComponent(ComponentC)

        expect(function()
            core:batchRemoveComponents(entity, ComponentA, ComponentB, ComponentC)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD01E326F05644C01A05CF34B5C151225">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">components.spec</string>
							<string name="ScriptGuid">{B41F417B-C288-4CA2-9A26-0DB97C02F9CD}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    it("should iterate over entities", function()
        local ComponentClass = defineComponent({
            name = "TestComponent",
            generator = function()
                return {}
            end
        })

        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local _, addedComponent = core:addComponent(entity, ComponentClass)

        for iteratedEntity, iteratedComponent in core:components(ComponentClass) do
            -- There is only one entity that fits the constraints, so these expectations are valid.
            expect(iteratedEntity).to.equal(entity)
            expect(iteratedComponent).to.equal(addedComponent)
        end
    end)

    it("should return components in the order specified", function()
        local ComponentA = defineComponent({
            name = "A",
            generator = function()
                return {}
            end,
        })

        local ComponentB = defineComponent({
            name = "B",
            generator = function()
                return {}
            end,
        })

        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)

        local entity = core:createEntity()
        local _, addedA = core:addComponent(entity, ComponentA)
        local _, addedB = core:addComponent(entity, ComponentB)

        for iteratedEntity, iteratedA, iteratedB in core:components(ComponentA, ComponentB) do
            -- There is only one entity that fits the constraints, so these expectations are valid.
            expect(iteratedEntity).to.equal(entity)
            expect(iteratedA).to.equal(addedA)
            expect(iteratedB).to.equal(addedB)
        end

        for iteratedEntity, iteratedB, iteratedA in core:components(ComponentB, ComponentA) do
            expect(iteratedEntity).to.equal(entity)
            expect(iteratedA).to.equal(addedA)
            expect(iteratedB).to.equal(addedB)
        end
    end)

    it("should exclude entities that do not have all the components", function()
        local ComponentA = defineComponent({
            name = "A",
            generator = function()
                return {}
            end,
        })

        local ComponentB = defineComponent({
            name = "B",
            generator = function()
                return {}
            end,
        })

        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)

        local entityA = core:createEntity()
        local _, addedA = core:addComponent(entityA, ComponentA)
        local _, addedB = core:addComponent(entityA, ComponentB)

        local entityB = core:createEntity()
        core:addComponent(entityB, ComponentA)

        local entityC = core:createEntity()
        core:addComponent(entityC, ComponentB)

        for iteratedEntity, iteratedA, iteratedB in core:components(ComponentA, ComponentB) do
            expect(iteratedEntity).to.equal(entityA)
            expect(iteratedA).to.equal(addedA)
            expect(iteratedB).to.equal(addedB)
        end
    end)

    it("should include entities that have components that are not specified", function()
        local ComponentA = defineComponent({
            name = "A",
            generator = function()
                return {}
            end,
        })

        local ComponentB = defineComponent({
            name = "B",
            generator = function()
                return {}
            end,
        })

        local core = Core.new()
        core:registerComponent(ComponentA)
        core:registerComponent(ComponentB)

        local entityA = core:createEntity()
        local _, addedA = core:addComponent(entityA, ComponentA)
        core:addComponent(entityA, ComponentB)

        for iteratedEntity, iteratedA in core:components(ComponentA) do
            expect(iteratedEntity).to.equal(entityA)
            expect(iteratedA).to.equal(addedA)
        end
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX64ECA3EC55CC4D1E8620307518185BC1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">getComponent.spec</string>
							<string name="ScriptGuid">{4B05FF92-1F85-48F2-B6E8-09ED66D2DE93}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentClass = defineComponent({
        name = "TestComponent",
        generator = function()
            return {}
        end
    })

    it("should get components", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)
        expect(core:getComponent(entity, ComponentClass)).to.be.ok()
    end)

    it("should return the same component that was added", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local _, addedComponent = core:addComponent(entity, ComponentClass)
        expect(core:getComponent(entity, ComponentClass)).to.equal(addedComponent)
    end)

    it("should always return the same component", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)

        local firstCall = core:getComponent(entity, ComponentClass)
        local secondCall = core:getComponent(entity, ComponentClass)
        expect(firstCall).to.equal(secondCall)
    end)

    it("should not create components", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local component = core:getComponent(entity, ComponentClass)
        expect(component).to.equal(nil)
    end)

    it("should throw if the component has not been registered", function()
        local core = Core.new()
        local entity = core:createEntity()

        expect(function()
            core:getComponent(entity, ComponentClass)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAF37520C319F4731B9534569115E86B5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">getComponentAddedSignal.spec</string>
							<string name="ScriptGuid">{7F6672DF-BC7F-40F1-81C7-0681E19ED008}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentClass = defineComponent({
        name = "TestComponent",
        generator = function()
            return {}
        end
    })

    it("should get a signal", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        expect(core:getComponentAddedSignal(ComponentClass)).to.be.ok()
    end)

    it("should always get the same signal", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local signalA = core:getComponentAddedSignal(ComponentClass)
        local signalB = core:getComponentAddedSignal(ComponentClass)
        expect(signalA).to.equal(signalB)
    end)

    it("should fire when the component is added to an entity", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local callCount = 0
        local signal = core:getComponentAddedSignal(ComponentClass)
        signal:connect(function(entityId, componentInstance)
            callCount = callCount + 1
        end)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)

        expect(callCount).to.equal(1)
    end)

    it("should not fire when addComponent is called but the component already exists", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local callCount = 0
        local signal = core:getComponentAddedSignal(ComponentClass)
        signal:connect(function(entityId, componentInstance)
            callCount = callCount + 1
        end)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)
        core:addComponent(entity, ComponentClass)

        expect(callCount).to.equal(1)
    end)

    it("should be fired with the entity ID and the component instance", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entityId = core:createEntity()
        local addedEntityId, addedComponentInstance = nil, nil

        local signal = core:getComponentAddedSignal(ComponentClass)
        signal:connect(function(signalEntityId, signalComponentInstance)
            addedEntityId = signalEntityId
            addedComponentInstance = signalComponentInstance
        end)

        local _, componentInstance = core:addComponent(entityId, ComponentClass)
        expect(entityId).to.equal(addedEntityId)
        expect(componentInstance).to.equal(addedComponentInstance)
    end)

    it("should throw if the component has not been registered", function()
        local core = Core.new()

        expect(function()
            core:getComponentAddedSignal(ComponentClass)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX53733982A7D84F38BEBB5668D8DEA0AC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">getComponentRemovingSignal.spec</string>
							<string name="ScriptGuid">{1150FF30-09D3-40F2-9D62-786CC9F674FC}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentClass = defineComponent({
        name = "TestComponent",
        generator = function()
            return {}
        end
    })

    it("should get a signal", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        expect(core:getComponentRemovingSignal(ComponentClass)).to.be.ok()
    end)

    it("should always get the same signal", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local signalA = core:getComponentRemovingSignal(ComponentClass)
        local signalB = core:getComponentRemovingSignal(ComponentClass)
        expect(signalA).to.equal(signalB)
    end)

    it("should fire when the component is removed from an entity", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local callCount = 0
        local signal = core:getComponentRemovingSignal(ComponentClass)
        signal:connect(function(entityId, componentInstance)
            callCount = callCount + 1
        end)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)
        expect(callCount).to.equal(0)

        core:removeComponent(entity, ComponentClass)
        expect(callCount).to.equal(1)
    end)

    it("should not fire when removeComponent is called but the component does not exist", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local callCount = 0
        local signal = core:getComponentRemovingSignal(ComponentClass)
        signal:connect(function(entityId, componentInstance)
            callCount = callCount + 1
        end)

        local entity = core:createEntity()
        core:removeComponent(entity, ComponentClass)
        expect(callCount).to.equal(0)
    end)

    it("should be fired with the entity ID and the component instance", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entityId = core:createEntity()
        local removedEntityId, removedComponentInstance = nil, nil

        local signal = core:getComponentRemovingSignal(ComponentClass)
        signal:connect(function(signalEntityId, signalComponentInstance)
            removedEntityId = signalEntityId
            removedComponentInstance = signalComponentInstance
        end)

        core:addComponent(entityId, ComponentClass)
        local _, componentInstance = core:removeComponent(entityId, ComponentClass)
        expect(entityId).to.equal(removedEntityId)
        expect(componentInstance).to.equal(removedComponentInstance)
    end)

    it("should be fired when destroying an entity", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entityId = core:createEntity()
        local callCount = 0
        local removedEntityId, removedComponentInstance = nil, nil

        local signal = core:getComponentRemovingSignal(ComponentClass)
        signal:connect(function(signalEntityId, signalComponentInstance)
            callCount = callCount + 1
            removedEntityId = signalEntityId
            removedComponentInstance = signalComponentInstance
        end)

        local _, componentInstance = core:addComponent(entityId, ComponentClass)
        core:destroyEntity(entityId)

        expect(callCount).to.equal(1)
        expect(entityId).to.equal(removedEntityId)
        expect(componentInstance).to.equal(removedComponentInstance)
    end)

    it("should throw if the component has not been registered", function()
        local core = Core.new()

        expect(function()
            core:getComponentRemovingSignal(ComponentClass)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX99FD8B721E92485493C26B19B1C10A55">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">plugins.spec</string>
							<string name="ScriptGuid">{482760DB-1F65-4F23-A965-D1FACBB6B593}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)
local System = require(script.Parent.Parent.System)

return function()
    it("should call plugin methods in order", function()
        local callIndex = 1

        local pluginA = {
            coreInit = function()
                expect(callIndex).to.equal(1)
                callIndex = 1
            end
        }

        local pluginB = {
            coreInit = function()
                expect(callIndex).to.equal(1)
                callIndex = 2
            end
        }

        local pluginC = {
            coreInit = function()
                expect(callIndex).to.equal(2)
                callIndex = 3
            end
        }

        Core.new({ pluginA, pluginB, pluginC })
        expect(callIndex).to.equal(3)
    end)

    it("should call plugin methods once per execution scenario", function()
        local callCount = 0

        local plugin = {
            coreInit = function()
                callCount = callCount + 1
            end
        }

        Core.new({ plugin })
        expect(callCount).to.equal(1)
    end)

    describe("coreInit", function()
        it("should be called on Core creation", function()
            local callCount = 0

            local plugin = {
                coreInit = function()
                    callCount = callCount + 1
                end
            }

            Core.new({ plugin })
            expect(callCount).to.equal(1)
        end)

        it("should be called with the Core", function()
            local callCount = 0
            local calledCore = nil

            local plugin
            plugin = {
                coreInit = function(self, core)
                    callCount = callCount + 1
                    calledCore = core

                    expect(self).to.equal(plugin)
                end
            }

            local core = Core.new({ plugin })
            expect(callCount).to.equal(1)
            expect(calledCore).to.equal(core)
        end)
    end)

    describe("componentRegistered", function()
        it("should be called when a component is registered", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local callCount = 0

            local plugin = {
                componentRegistered = function(self, core, componentClass)
                    callCount = callCount + 1
                    expect(componentClass).to.equal(ComponentClass)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)
            expect(callCount).to.equal(1)
        end)
    end)

    describe("componentAdded", function()
        it("should be called when a component is added to an entity", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local callCount = 0
            local calledEntity = nil
            local calledComponentInstance = nil

            local plugin = {
                componentAdded = function(self, core, entityId, componentInstance)
                    expect(componentInstance.className).to.equal("TestComponent")

                    callCount = callCount + 1
                    calledEntity = entityId
                    calledComponentInstance = componentInstance
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)
            local entity = core:createEntity()
            local _, componentInstance = core:addComponent(entity, ComponentClass)

            expect(callCount).to.equal(1)
            expect(entity).to.equal(calledEntity)
            expect(componentInstance).to.equal(calledComponentInstance)
        end)

        it("should be called before events are fired in addComponent", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local eventFired = false

            local plugin = {
                componentAdded = function(self, core, entityId, componentInstance)
                    expect(eventFired).to.equal(false)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)

            local signal = core:getComponentAddedSignal(ComponentClass)
            signal:connect(function()
                eventFired = true
            end)

            local entity = core:createEntity()
            core:addComponent(entity, ComponentClass)
        end)

        it("should be called before events are fired in batchAddComponents", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local eventFired = false

            local plugin = {
                componentAdded = function(self, core, entityId, componentInstance)
                    expect(eventFired).to.equal(false)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)

            local signal = core:getComponentAddedSignal(ComponentClass)
            signal:connect(function()
                eventFired = true
            end)

            local entity = core:createEntity()
            core:batchAddComponents(entity, ComponentClass)
        end)
    end)

    describe("componentRemoving", function()
        it("should be called when a component is removed from an entity", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local callCount = 0
            local calledEntity = nil
            local calledComponentInstance = nil

            local plugin = {
                componentRemoving = function(self, core, entityId, componentInstance)
                    expect(componentInstance.className).to.equal("TestComponent")

                    callCount = callCount + 1
                    calledEntity = entityId
                    calledComponentInstance = componentInstance
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)
            local entity = core:createEntity()
            core:addComponent(entity, ComponentClass)
            local _, componentInstance = core:removeComponent(entity, ComponentClass)

            expect(callCount).to.equal(1)
            expect(entity).to.equal(calledEntity)
            expect(componentInstance).to.equal(calledComponentInstance)
        end)

        it("should be called when an entity is destroyed", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local callCount = 0
            local calledEntity = nil
            local calledComponentInstance = nil

            local plugin = {
                componentRemoving = function(self, core, entityId, componentInstance)
                    expect(componentInstance.className).to.equal("TestComponent")

                    callCount = callCount + 1
                    calledEntity = entityId
                    calledComponentInstance = componentInstance
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)
            local entity = core:createEntity()
            local _, componentInstance = core:addComponent(entity, ComponentClass)
            core:destroyEntity(entity)

            expect(callCount).to.equal(1)
            expect(entity).to.equal(calledEntity)
            expect(componentInstance).to.equal(calledComponentInstance)
        end)

        it("should be called after events are fired in removeComponent", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local eventFired = false

            local plugin = {
                componentRemoving = function(self, core, entityId, componentInstance)
                    expect(eventFired).to.equal(true)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)

            local signal = core:getComponentRemovingSignal(ComponentClass)
            signal:connect(function()
                eventFired = true
            end)

            local entity = core:createEntity()
            core:addComponent(entity, ComponentClass)
            core:removeComponent(entity, ComponentClass)
        end)

        it("should be called after events are fired in batchRemoveComponents", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local eventFired = false

            local plugin = {
                componentRemoving = function(self, core, entityId, componentInstance)
                    expect(eventFired).to.equal(true)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)

            local signal = core:getComponentRemovingSignal(ComponentClass)
            signal:connect(function()
                eventFired = true
            end)

            local entity = core:createEntity()
            core:addComponent(entity, ComponentClass)
            core:batchRemoveComponents(entity, ComponentClass)
        end)

        it("should be called after events are fired in destroyEntity", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local eventFired = false

            local plugin = {
                componentRemoving = function(self, core, entityId, componentInstance)
                    expect(eventFired).to.equal(true)
                end,
            }

            local core = Core.new({ plugin })
            core:registerComponent(ComponentClass)

            local signal = core:getComponentRemovingSignal(ComponentClass)
            signal:connect(function()
                eventFired = true
            end)

            local entity = core:createEntity()
            core:addComponent(entity, ComponentClass)
            core:destroyEntity(entity)
        end)
    end)

    describe("singletonAdded", function()
        it("should be called when a singleton is added", function()
            local ComponentClass = defineComponent({
                name = "TestComponent",
                generator = function()
                    return {}
                end
            })

            local callCount = 0
            local calledSingleton = nil

            local plugin = {
                singletonAdded = function(self, core, singleton)
                    callCount = callCount + 1
                    calledSingleton = singleton
                end,
            }

            local core = Core.new({ plugin })
            local singleton = core:addSingleton(ComponentClass)

            expect(callCount).to.equal(1)
            expect(calledSingleton).to.equal(singleton)
        end)
    end)

    describe("beforeSystemStart", function()
        it("should be called before systems init", function()
            local systemsInitialized = false
            local SystemClass = System:extend("SystemClass")

            function SystemClass:init()
                systemsInitialized = true
            end

            local plugin = {
                beforeSystemStart = function(self, core)
                    expect(systemsInitialized).to.equal(false)
                end
            }

            local core = Core.new({ plugin })
            core:registerSystem(SystemClass)
            core:start()
            expect(systemsInitialized).to.equal(true)
        end)
    end)

    describe("afterSystemStart", function()
        it("should be called after systems init", function()
            local systemsInitialized = false
            local SystemClass = System:extend("SystemClass")

            function SystemClass:init()
                systemsInitialized = true
            end

            local plugin = {
                afterSystemStart = function(self, core)
                    expect(systemsInitialized).to.equal(true)
                end
            }

            local core = Core.new({ plugin })
            core:registerSystem(SystemClass)
            core:start()
            expect(systemsInitialized).to.equal(true)
        end)
    end)

    describe("afterStepperStart", function()
        it("should be called after systems init", function()
            local systemsInitialized = false
            local SystemClass = System:extend("SystemClass")

            function SystemClass:init()
                systemsInitialized = true
            end

            local plugin = {
                afterStepperStart = function(self, core)
                    expect(systemsInitialized).to.equal(true)
                end
            }

            local core = Core.new({ plugin })
            core:registerSystem(SystemClass)
            core:start()
            expect(systemsInitialized).to.equal(true)
        end)
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX864E1BB8516945D89847C1E961DB1C3B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">removeComponent.spec</string>
							<string name="ScriptGuid">{E1D45F9E-6CFE-478E-AE17-4C7B00CDD8F0}</string>
							<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Parent.Core)
local defineComponent = require(script.Parent.Parent.defineComponent)

return function()
    local ComponentClass = defineComponent({
        name = "TestComponent",
        generator = function()
            return {}
        end
    })

    it("should remove components", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        core:addComponent(entity, ComponentClass)
        core:removeComponent(entity, ComponentClass)
    end)

    it("should return the removed component", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local _, component = core:addComponent(entity, ComponentClass)
        expect(component).to.be.ok()

        local success, removedComponent = core:removeComponent(entity, ComponentClass)
        expect(success).to.equal(true)
        expect(removedComponent).to.equal(component)
    end)

    it("should return false if the component doesn't exist on the entity", function()
        local core = Core.new()
        core:registerComponent(ComponentClass)

        local entity = core:createEntity()
        local success, removedComponent = core:removeComponent(entity, ComponentClass)
        expect(success).to.equal(false)
        expect(removedComponent).to.equal(nil)
    end)

    it("should throw if the component has not been registered", function()
        local core = Core.new()
        local entity = core:createEntity()

        expect(function()
            core:removeComponent(entity, ComponentClass)
        end).to.throw()
    end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXE46E390D0A66434986BDCA4C1663758D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">EventStepper</string>
						<string name="ScriptGuid">{1B5945FE-43FA-4204-A611-9057047AABB6}</string>
						<ProtectedString name="Source"><![CDATA[--[[

An event stepper is responsible for stepping systems in a deterministic order in response to some event.

]]

local createCleaner = require(script.Parent.createCleaner)

local EventStepper = {}
EventStepper.__index = EventStepper

function EventStepper.new(event, systems)
    local self = setmetatable({
        _cleaner = createCleaner(),
        _event = event,
        _systems = systems,
    }, EventStepper)

    return self
end

function EventStepper:start()
    self._cleaner.stepConnection = self._event:Connect(function(...)
        for _, system in ipairs(self._systems) do
            system:step(...)
        end
    end)
end

return EventStepper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE089A3D2FCF048F8BCB3CA8923ABF00B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">System</string>
						<string name="ScriptGuid">{7760D471-5D0C-4738-8FEA-07F98F4732DF}</string>
						<ProtectedString name="Source"><![CDATA[local createCleaner = require(script.Parent.createCleaner)

local System = {}
System.__index = System
System._kind = System

function System.__isSystemClass(systemClass)
    if typeof(systemClass) ~= "table" then
        return false
    end

    return getmetatable(systemClass) == System
end

-- luacheck: ignore self
function System:extend(systemName)
    local systemClass = setmetatable({
        name = systemName,
    }, System)

    function systemClass._create(core)
        local systemInstance = setmetatable({
            core = core,
            maid = createCleaner(),
        }, {
            __index = systemClass
        })

        return systemInstance
    end

    setmetatable(systemClass, System)
    return systemClass
end

function System:step()
    error("override System:step() to provide functionality for your system", 0)
end

return System]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX408961EA862E4CEBA7B95E020EDDEEFF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TimeStepper</string>
						<string name="ScriptGuid">{32F43DC9-8084-4578-AC7C-1B4FFAE99257}</string>
						<ProtectedString name="Source"><![CDATA[--[[

A time stepper is responsible for stepping systems in a deterministic order at a set interval.

]]

local TimeStepper = {}
TimeStepper.__index = TimeStepper

function TimeStepper.new(interval, systems)
    local self = setmetatable({
        _systems = systems,
        _interval = interval,
    }, TimeStepper)

    return self
end

function TimeStepper:start()
    coroutine.resume(coroutine.create(function()
        while true do
            local timeStep, _ = wait(self._interval)
            for _, system in ipairs(self._systems) do
                system:step(timeStep)
            end
        end
    end))
end

return TimeStepper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX481FC84C47674B4081CA56820A16D8FF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createCleaner</string>
						<string name="ScriptGuid">{AC29A061-4F13-48AC-81FC-F5B90F59089F}</string>
						<ProtectedString name="Source"><![CDATA[local errorMessages = {
    cannotDestroy = "Cleaner cannot destroy %q of type %s (key %q)",
    overridingKey = "Cannot override built-in method %s",
}

local cleanerMethods = {}

local function hasFunction(table, key)
    return table[key] ~= nil and typeof(table[key]) == "function"
end

local function canDestroy(value)
    if typeof(value) == "function" then
        return true
    elseif typeof(value) == "Instance" then
        return true
    elseif typeof(value) == "RBXScriptConnection" then
        return true
    elseif typeof(value) == "table"
        and getmetatable(value) ~= nil
        and getmetatable(value).__index == cleanerMethods then

        return true
    elseif typeof(value) == "table" then
        return hasFunction(value, "destroy")
            or hasFunction(value, "Destroy")
            or hasFunction(value, "disconnect")
            or hasFunction(value, "Disconnect")
    end

    return false
end

cleanerMethods.give = function(self, key, value)
    assert(cleanerMethods[key] == nil, errorMessages.overridingKey:format(tostring(key)))

    if value ~= nil then
        assert(canDestroy(value), errorMessages.cannotDestroy:format(tostring(value), typeof(value), tostring(key)))
    end

    rawset(self, key, value)
end

cleanerMethods.clean = function(self)
    for key, value in pairs(self) do
        if typeof(value) == "function" then
            value()
        elseif typeof(value) == "Instance" then
            value:Destroy()
        elseif typeof(value) == "RBXScriptConnection" then
            value:Disconnect()
        elseif typeof(value) == "table"
            and getmetatable(value) ~= nil
            and getmetatable(value).__index == cleanerMethods then

            value:clean()
        elseif typeof(value) == "table" then
            if value.destroy ~= nil then
                value.destroy()
            elseif value.Destroy ~= nil then
                value.Destroy()
            elseif value.disconnect ~= nil then
                value.disconnect()
            elseif value.Disconnect ~= nil then
                value.Disconnect()
            end
        end

        rawset(self, key, nil)
    end
end

local function createCleaner()
    local cleaner = {}

    setmetatable(cleaner, {
        __index = cleanerMethods,
        __newindex = cleanerMethods.give,
    })

    return cleaner
end

return createCleaner]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX46CB9AAD217C41E381BD6A2F911A6F9F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createCleaner.spec</string>
						<string name="ScriptGuid">{6085F313-D3C4-40D2-9DBE-D1D4EB753801}</string>
						<ProtectedString name="Source"><![CDATA[local createCleaner = require(script.Parent.createCleaner)

return function()
    it("should create cleaners", function()
        expect(createCleaner()).to.be.ok()
    end)

    describe("Cleaner", function()
        it("should allow retrieval of given objects", function()
            local testInstance = Instance.new("Folder")
            local cleaner = createCleaner()
            cleaner.Test = testInstance

            expect(cleaner.Test).to.equal(testInstance)
        end)

        describe("give", function()
            it("should accept instances", function()
                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("Test", Instance.new("Folder"))
                end).to.never.throw()
            end)

            it("should accept functions", function()
                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("Test", function() end)
                end).to.never.throw()
            end)

            it("should accept connections", function()
                local event = Instance.new("BindableEvent")
                local connection = event.Event:Connect(function()
                end)

                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("Test", connection)
                end).to.never.throw()
            end)

            it("should accept other cleaners", function()
                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("Test", createCleaner())
                end).to.never.throw()
            end)

            local methods = { "destroy", "Destroy", "disconnect", "Disconnect" }
            for _, methodName in ipairs(methods) do
                it("should accept tables with " .. methodName .. " functions", function()
                    local cleaner = createCleaner()
                    expect(function()
                        cleaner.Test = {
                            [methodName] = function()
                            end,
                        }
                    end).to.never.throw()
                end)
            end

            it("should throw if given an uncleanable value", function()
                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("uncleanable", 1)
                    cleaner:give("uncleanable2", true)
                    cleaner:give("uncleanable3", {})
                end).to.throw()
            end)

            it("should throw if you try to override a method", function()
                local cleaner = createCleaner()
                expect(function()
                    cleaner:give("give", function() end)
                    cleaner:give("clean", function() end)
                end).to.throw()
            end)

            it("should be bound to __newindex", function()
                local cleaner = createCleaner()
                local event = Instance.new("BindableEvent")
                local connection = event.Event:Connect(function()
                end)

                expect(function()
                    cleaner.Instance = Instance.new("Folder")
                    cleaner.Function = function() end
                    cleaner.Connection = connection
                    cleaner.destroy = {
                        destroy = function() end,
                    }
                    cleaner.Destroy = {
                        Destroy = function() end,
                    }
                    cleaner.disconnect = {
                        disconnect = function() end,
                    }
                    cleaner.Disconnect = {
                        Disconnect = function() end,
                    }
                end).to.never.throw()

                expect(function()
                    cleaner.give = function() end
                    cleaner.clean = function() end
                end).to.throw()

                expect(function()
                    cleaner.Uncleanable = 1
                end).to.throw()
            end)
        end)

        describe("clean", function()
            it("should clear the cleaner", function()
                local testInstance = Instance.new("Folder")
                local cleaner = createCleaner()
                cleaner.Test = testInstance

                cleaner:clean()
                expect(cleaner.Test).to.equal(nil)
            end)

            it("should destroy instances", function()
                local testParent = Instance.new("Folder")
                local testInstance = Instance.new("Folder")
                testInstance.Name = "Test"
                testInstance.Parent = testParent

                local cleaner = createCleaner()
                cleaner.Test = testInstance

                cleaner:clean()
                expect(testParent:FindFirstChild("Test")).to.equal(nil)
            end)

            it("should call functions", function()
                local callCount = 0

                local cleaner = createCleaner()
                cleaner.Test = function()
                    callCount = callCount + 1
                end

                cleaner:clean()
                expect(callCount).to.equal(1)
            end)

            it("should disconnect connections", function()
                local event = Instance.new("BindableEvent")
                local connection = event.Event:Connect(function()
                end)

                local cleaner = createCleaner()
                cleaner.Test = connection

                cleaner:clean()
                expect(connection.Connected).to.equal(false)
            end)

            it("should clean up cleaners", function()
                local innerCleanCalled = false

                local cleaner = createCleaner()
                local innerCleaner = createCleaner()
                innerCleaner.Test = function()
                    innerCleanCalled = true
                end

                cleaner.Cleaner = innerCleaner
                cleaner:clean()
                expect(innerCleanCalled).to.equal(true)
            end)

            local methods = { "destroy", "Destroy", "disconnect", "Disconnect" }
            for _, methodName in ipairs(methods) do
                it("should call " .. methodName .. " on tables with it", function()
                    local methodCalled = false
                    local cleaner = createCleaner()
                    cleaner.Test = {
                        [methodName] = function()
                            methodCalled = true
                        end,
                    }

                    cleaner:clean()
                    expect(methodCalled).to.equal(true)
                end)
            end
        end)
    end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX15ED99BEB6D64BBEBE9403F4B4233178">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal</string>
						<string name="ScriptGuid">{8B3F70FA-895B-4C8F-8B3E-C0CF835D2F25}</string>
						<ProtectedString name="Source"><![CDATA[local function createSignal()
    local listeners = {}
    local signal = {}

    function signal:Connect(listener)
        listeners[listener] = true

        local connection = {
            Connected = true,
        }

        function connection.Disconnect()
            connection.Connected = false
            listeners[listener] = nil
        end
        connection.disconnect = connection.Disconnect

        return connection
    end
    signal.connect = signal.Connect

    local function fire(...)
        for listener, _ in pairs(listeners) do
            coroutine.wrap(listener)(...)
        end
    end

    return signal, fire
end

return createSignal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE677AA6B495A460E906E8D6F503E2DBD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal.spec</string>
						<string name="ScriptGuid">{110B7E07-E2DD-4584-8C3D-1770B4E4FCDF}</string>
						<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)

return function()
    it("should return a signal and a function", function()
        local signal, fire = createSignal()
        expect(signal).to.be.ok()
        expect(typeof(signal.Connect)).to.equal("function")
        expect(typeof(signal.connect)).to.equal("function")
        expect(typeof(fire)).to.equal("function")
    end)

    describe("Connect", function()
        it("should connect to the signal", function()
            local signal, fire = createSignal()
            local fired = false
            signal:Connect(function(value)
                expect(value).to.equal(1)
                fired = true
            end)

            fire(1)
            expect(fired).to.equal(true)
        end)

        it("should wrap all listeners in coroutines to avoid blocking", function()
            local signal, fire = createSignal()
            local done = false

            signal:Connect(function()
                wait(1)
                done = true
            end)

            fire()
            expect(done).to.equal(false)
        end)
    end)

    describe("connections", function()
        it("should be returned from Connect", function()
            local signal, _ = createSignal()
            local connection = signal:Connect(function()
            end)

            expect(connection).to.be.ok()
            expect(connection.Connected).to.equal(true)
        end)

        it("should disconnect the listener when Disconnect is called", function()
            local signal, fire = createSignal()
            local callCount = 0
            local connection = signal:Connect(function()
                callCount = callCount + 1
            end)

            expect(connection).to.be.ok()
            expect(connection.Connected).to.equal(true)

            fire()
            expect(callCount).to.equal(1)

            connection:Disconnect()
            expect(connection.Connected).to.equal(false)
            fire()
            expect(callCount).to.equal(1)
        end)
    end)

    describe("fire", function()
        it("should invoke listeners", function()
            local signal, fire = createSignal()
            local fired = false
            signal:Connect(function(value)
                expect(value).to.equal(1)
                fired = true
            end)

            fire(1)
            expect(fired).to.equal(true)
        end)

        it("should not serialize arguments", function()
            local testValue = {}
            local signal, fire = createSignal()

            signal:Connect(function(value)
                expect(value).to.equal(testValue)
            end)

            fire(testValue)
        end)
    end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3296F10AFC2F4706A2D2357B77E6069A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">defineComponent</string>
						<string name="ScriptGuid">{91E08364-99EA-408C-BCC7-CB6D24059364}</string>
						<ProtectedString name="Source"><![CDATA[--[[

    defineComponent is a utility function for defining a component. Given an
    argument table, it creates a component class.

    The argument table should have the following keys:
    - name (string)
    - generator (() -> table)
    - entityFilter (entity -> bool)

    The name must be a string; there are no restrictions on its value otherwise.
    However, duplicate names are not recommended, as Cores require that all
    components registered in them have unique names.

    The generator function must return a table. The exact contents of the table
    are up to the user; RECS imposes no restrictions on it. However, RECS does
    provide the className field that will refer to the class name of the
    component.

    The entity filter function must take an entity and return a boolean
    indicating whether the component can be applied to that entity. This can be
    used to ensure that a component is only attached to entities that are Roblox
    instances, or specific Roblox instances, or only abstract entities.

    If the entity filter function is not present in the args table, the
    component can be attached to any entity.

]]

local t = require(script.Parent.Parent.t)

local isComponentArgs = t.strictInterface({
    name = t.string,
    generator = t.callback,
    entityFilter = t.optional(t.callback),
})

local errorFormats = {
    nonTableDefaultPropsReturn =
        "The defaultProps generator for the %s component must return a table, but it returned a %s",
}

local function defineComponent(args)
    assert(isComponentArgs(args))

    local definition = {}
    definition.className = args.name
    definition.entityFilter = args.entityFilter
    definition.__index = definition

    local generator = args.generator

    function definition._create()
        local component = generator()

        if typeof(component) ~= "table" then
            error(errorFormats.nonTableDefaultPropsReturn:format(args.name, typeof(component)))
        end

        setmetatable(component, definition)
        return component
    end

    return definition
end

return defineComponent]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1C6AB2BB53AD498895311B975A8DBD50">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">defineComponent.spec</string>
						<string name="ScriptGuid">{7DC151A9-EBE5-4E3C-A517-A02E133DD261}</string>
						<ProtectedString name="Source"><![CDATA[local defineComponent = require(script.Parent.defineComponent)

return function()
    it("should create component classes", function()
        expect(defineComponent({
            name = "Test",
            generator = function() end,
        })).to.be.ok()
    end)

    it("should create component classes with a name and creator", function()
        local component = defineComponent({
            name = "Test",
            generator = function() end
        })

        expect(component.className).to.equal("Test")
        expect(typeof(component._create)).to.equal("function")
    end)

    it("should throw if args is not a table", function()
        expect(function()
            defineComponent("Test", function() end)
        end).to.throw()
    end)

    it("should throw if given a non-string name", function()
        expect(function()
            defineComponent({
                name = 123,
                generator = function()
                end,
            })
        end).to.throw()
    end)

    it("should throw if given a non-function generator", function()
        expect(function()
            defineComponent({
                name = "Test",
                generator = true,
            })
        end).to.throw()
    end)

    it("should accept an entity filter", function()
        defineComponent({
            name = "Test",
            generator = function() end,
            entityFilter = function() end,
        })
    end)

    it("should throw if given a non-function entity filter", function()
        expect(function()
            defineComponent({
                name = "Test",
                generator = function() end,
                entityFilter = true,
            })
        end).to.throw()
    end)

    describe("_create", function()
        it("should create components", function()
            local class = defineComponent({
                name = "Test",
                generator = function()
                    return {
                        a = 1,
                        b = 2,
                    }
                end,
            })

            local component = class._create()
            expect(component.a).to.equal(1)
            expect(component.b).to.equal(2)
        end)

        it("should throw if the generator function does not return a table", function()
            local class = defineComponent({
                name = "Test",
                generator = function()
                    return 123
                end,
            })

            expect(class._create).to.throw()
        end)

        it("should set up the metatable properly", function()
            local class = defineComponent({
                name = "Test",
                generator = function()
                    return {
                        a = 1,
                        b = 2,
                    }
                end,
            })

            function class:setA(newA)
                self.a = newA
            end

            local component = class._create()
            expect(component.a).to.equal(1)
            component:setA(2)
            expect(component.a).to.equal(2)
        end)
    end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF1C71B97F8A94022A0934E3EF2248BF2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">defineRegistration</string>
						<string name="ScriptGuid">{9BD9D7E7-A86A-4067-9521-7F8979E58144}</string>
						<ProtectedString name="Source"><![CDATA[--[[

    defineRegistration provides constructors for stepper definitions, which are
    instructions that Cores can use to create a stepper object to step systems
    in a defined order.

    The stepper definitions contain the kind of stepper to be created, any
    parameters that the stepper needs, and an array of system classes. When the
    Core creates a stepper, it maps the system classes to system instances that
    were created when the system classes were registered with the Core.

    Each stepper definition must have two fields:
    - type (string): The type of stepper that this definition refers to. Current
      valid values are "interval" and "event".
    - systemClasses (array): An array of system classes that the stepper will
      step when it is created.

    Any other fields are determined by the value of the type field.

    Cores will throw an error if they don't understand the value of the type
    field. Since stepper definitions are created using functions defined in this
    file, this shouldn't be encountered in normal use cases.

]]

local System = require(script.Parent.System)

local errorMessages = {
    nonNumberInterval = "intervalLength (1) must be a number, is a %s",
    nonPositiveInterval = "intervalLength (1) is %d, but must be positive",
    nonEvent = "event (1) must be an event, is a %s",
    nonTable = "systemsArray (2) must be a table, is a %s",
    notASystemClass = "the element at index %d is not a system class",
}

local function interval(intervalLength, systemsArray)
    assert(typeof(intervalLength == "number"), errorMessages.nonNumberInterval:format(typeof(intervalLength)))
    assert(intervalLength >= 0, errorMessages.nonPositiveInterval:format(intervalLength))
    assert(typeof(systemsArray) == "table", errorMessages.nonTable:format(typeof(systemsArray)))

    for index, system in ipairs(systemsArray) do
        if not System.__isSystemClass(system) then
            error(errorMessages.notASystemClass:format(index), 2)
        end
    end

    return {
        type = "interval",
        interval = intervalLength,
        systemClasses = systemsArray,
    }
end

local function event(eventObject, systemsArray)
    assert(typeof(eventObject) == "RBXScriptSignal", errorMessages.nonEvent:format(typeof(eventObject)))
    assert(typeof(systemsArray) == "table", errorMessages.nonTable:format(typeof(systemsArray)))

    for index, system in ipairs(systemsArray) do
        if not System.__isSystemClass(system) then
            error(errorMessages.notASystemClass:format(index), 2)
        end
    end

    return {
        type = "event",
        event = eventObject,
        systemClasses = systemsArray,
    }
end

return {
    interval = interval,
    event = event,
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFF0D6BFA62BF4C2FBC9139F4DE34C9BA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">defineRegistration.spec</string>
						<string name="ScriptGuid">{A37B4356-120F-4021-AB0E-440E7CE8FDE9}</string>
						<ProtectedString name="Source"><![CDATA[local defineRegistration = require(script.Parent.defineRegistration)
local System = require(script.Parent.System)

return function()
    describe("interval", function()
        it("should create stepper definitions", function()
            local TestSystem = System:extend("TestSystem")

            expect(defineRegistration.interval(1, {
                TestSystem,
            })).to.be.ok()
        end)

        it("should throw if given a non-number as the first argument", function()
            expect(function()
                defineRegistration.interval(false, {})
            end).to.throw()
        end)

        it("should throw if given a non-positive number as the first argument", function()
            expect(function()
                defineRegistration.interval(-1, {})
            end).to.throw()
        end)

        it("should throw if given a non-table as the second argument", function()
            expect(function()
                defineRegistration.interval(1, false)
            end).to.throw()
        end)

        it("should throw if the systems table has an element that is not a system class", function()
            expect(function()
                defineRegistration.interval(1, {
                    false
                })
            end).to.throw()
        end)
    end)

    describe("event", function()
        it("should create stepper definitions", function()
            local TestSystem = System:extend("TestSystem")

            local bindableEvent = Instance.new("BindableEvent")
            local event = bindableEvent.Event
            expect(defineRegistration.event(event, {
                TestSystem,
            })).to.be.ok()
        end)

        it("should throw if given a non-event as the first argument", function()
            expect(function()
                defineRegistration.event(false, {})
            end).to.throw()
        end)

        it("should throw if given a non-table as the second argument", function()
            local bindableEvent = Instance.new("BindableEvent")
            local event = bindableEvent.Event

            expect(function()
                defineRegistration.event(event, false)
            end).to.throw()
        end)

        it("should throw if the systems table has an element that is not a system class", function()
            local bindableEvent = Instance.new("BindableEvent")
            local event = bindableEvent.Event

            expect(function()
                defineRegistration.event(event, {
                    false
                })
            end).to.throw()
        end)
    end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2F2BF8DBC7BC4A4098C6D945EB4AB744">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BuiltInPlugins</string>
						<string name="ScriptGuid">{74D67071-BE4F-4B55-9587-52DCAF6A7AEB}</string>
						<ProtectedString name="Source"><![CDATA[return {
    CollectionService = require(script.CollectionService),
    ComponentChangedEvent = require(script.ComponentChangedEvent),
}
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA2BDFE16682C45049BC0166D0E09F24C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CollectionService</string>
							<string name="ScriptGuid">{A9BB665E-3BA6-453C-84D0-B2B8565DCF15}</string>
							<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

local function createCollectionServicePlugin()
    local collectionServicePlugin = {}
    local componentClasses = {}

    function collectionServicePlugin:componentRegistered(_, componentClass)
        table.insert(componentClasses, componentClass)
    end

    function collectionServicePlugin:beforeSystemStart(core)
        for _, componentClass in ipairs(componentClasses) do
            local name = componentClass.className

            for _, instance in ipairs(CollectionService:GetTagged(name)) do
                core:addComponent(instance, name)
            end

            local instanceAddedSignal = CollectionService:GetInstanceAddedSignal(name)
            instanceAddedSignal:Connect(function(instance)
                core:addComponent(instance, name)
            end)

            local instanceRemovedSignal = CollectionService:GetInstanceRemovedSignal(name)
            instanceRemovedSignal:Connect(function(instance)
                core:removeComponent(instance, name)
            end)
        end
    end

    return collectionServicePlugin
end

return createCollectionServicePlugin
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX746122BEB74B4EF0939D55979C467BE3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ComponentChangedEvent</string>
							<string name="ScriptGuid">{90390CC5-E759-45AC-BE42-8EA86BDF9EE5}</string>
							<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.Parent.createSignal)

local componentChangedEventPlugin = {}

function componentChangedEventPlugin:componentRegistered(core, componentClass)
    function componentClass.updateProperty(componentInstance, key, newValue)
        local oldValue = componentInstance[key]

        if oldValue == newValue then
            return
        end

        componentInstance[key] = newValue

        componentInstance.raisePropertyChanged(key, newValue, oldValue)
    end
end

function componentChangedEventPlugin:componentAdded(core, entityId, componentInstance)
    local propertyChangedSignal, raisePropertyChanged = createSignal()

    componentInstance.changed = propertyChangedSignal
    componentInstance.raisePropertyChanged = raisePropertyChanged
end

return componentChangedEventPlugin
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXE520E48F811A411CB7F1174561B9A361">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">t</string>
					<string name="ScriptGuid">{ED838508-7C29-481E-A78B-DFE2EAC1BB33}</string>
					<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

local t = {}

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = primitive("boolean")

--[[**
	ensures Lua primitive coroutine type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.coroutine = primitive("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = primitive("function")

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = primitive("nil")

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = primitive("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = primitive("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = primitive("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	if value ~= value then
		return true
	else
		return false, "unexpected non-NaN value"
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = primitive("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = primitive("BrickColor")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = primitive("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = primitive("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = primitive("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = primitive("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = primitive("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = primitive("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = primitive("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = primitive("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = primitive("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = primitive("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = primitive("Ray")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = primitive("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = primitive("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = primitive("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = primitive("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = primitive("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = primitive("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = primitive("Vector2")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = primitive("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = primitive("Vector3int16")

-- roblox enum types

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = primitive("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = primitive("EnumItem")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(literal)
	return function(value)
		if value ~= literal then
			return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
		end
		return true
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end
	if value%1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end
		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end
		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)
	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)
	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end
		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = {...}
	return function(...)
		local args = {...}
		for i = 1, #checks do
			local success, errMsg = checks[i](args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end
		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck), t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)
	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

do
	local arrayKeysCheck = t.keys(t.integer)
	--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)
		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _, _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
	--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				if check(value) then
					return true
				end
			end
			return false, "bad type for union"
		end
	end

	--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end
			return true
		end
	end
end

do
	local checkInterface = t.map(t.any, t.callback)
	--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end
			return true
		end
	end

	--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field '%s'", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instance(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		return true
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The functon to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

return t]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD84A2B345D584327ABEE27AD8AE3C834">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid">{9FBE469A-B959-431B-B3CC-6C84E77B10D6}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local t = require(script.Parent)

	it("should support basic types", function()
		expect(t.any("")).to.equal(true)
		expect(t.boolean(true)).to.equal(true)
		expect(t.none(nil)).to.equal(true)
		expect(t.number(1)).to.equal(true)
		expect(t.string("foo")).to.equal(true)
		expect(t.table({})).to.equal(true)

		expect(t.any(nil)).to.equal(false)
		expect(t.boolean("true")).to.equal(false)
		expect(t.none(1)).to.equal(false)
		expect(t.number(true)).to.equal(false)
		expect(t.string(true)).to.equal(false)
		expect(t.table(82)).to.equal(false)
	end)

	it("should support special number types", function()
		local maxTen = t.numberMax(10)
		local minTwo = t.numberMin(2)
		local maxTenEx = t.numberMaxExclusive(10)
		local minTwoEx = t.numberMinExclusive(2)
		local constrainedEightToEleven = t.numberConstrained(8, 11)
		local constrainedEightToElevenEx = t.numberConstrainedExclusive(8, 11)

		expect(maxTen(5)).to.equal(true)
		expect(maxTen(10)).to.equal(true)
		expect(maxTen(11)).to.equal(false)
		expect(maxTen()).to.equal(false)

		expect(minTwo(5)).to.equal(true)
		expect(minTwo(2)).to.equal(true)
		expect(minTwo(1)).to.equal(false)
		expect(minTwo()).to.equal(false)

		expect(maxTenEx(5)).to.equal(true)
		expect(maxTenEx(9)).to.equal(true)
		expect(maxTenEx(10)).to.equal(false)
		expect(maxTenEx()).to.equal(false)

		expect(minTwoEx(5)).to.equal(true)
		expect(minTwoEx(3)).to.equal(true)
		expect(minTwoEx(2)).to.equal(false)
		expect(minTwoEx()).to.equal(false)

		expect(constrainedEightToEleven(7)).to.equal(false)
		expect(constrainedEightToEleven(8)).to.equal(true)
		expect(constrainedEightToEleven(9)).to.equal(true)
		expect(constrainedEightToEleven(11)).to.equal(true)
		expect(constrainedEightToEleven(12)).to.equal(false)
		expect(constrainedEightToEleven()).to.equal(false)

		expect(constrainedEightToElevenEx(7)).to.equal(false)
		expect(constrainedEightToElevenEx(8)).to.equal(false)
		expect(constrainedEightToElevenEx(9)).to.equal(true)
		expect(constrainedEightToElevenEx(11)).to.equal(false)
		expect(constrainedEightToElevenEx(12)).to.equal(false)
		expect(constrainedEightToElevenEx()).to.equal(false)
	end)

	it("should support optional types", function()
		local check = t.optional(t.string)
		expect(check("")).to.equal(true)
		expect(check()).to.equal(true)
		expect(check(1)).to.equal(false)
	end)

	it("should support tuple  types", function()
		local myTupleCheck = t.tuple(t.number, t.string, t.optional(t.number))
		expect(myTupleCheck(1, "2", 3)).to.equal(true)
		expect(myTupleCheck(1, "2")).to.equal(true)
		expect(myTupleCheck(1, "2", "3")).to.equal(false)
	end)

	it("should support union  types", function()
		local numberOrString = t.union(t.number, t.string)
		expect(numberOrString(1)).to.equal(true)
		expect(numberOrString("1")).to.equal(true)
		expect(numberOrString(nil)).to.equal(false)
	end)

	it("should support exact types", function()
		local checkSingle = t.exactly("foo")
		local checkUnion = t.union(t.exactly("foo"), t.exactly("bar"), t.exactly("oof"))

		expect(checkSingle("foo")).to.equal(true)
		expect(checkUnion("foo")).to.equal(true)
		expect(checkUnion("bar")).to.equal(true)
		expect(checkUnion("oof")).to.equal(true)

		expect(checkSingle("FOO")).to.equal(false)
		expect(checkUnion("FOO")).to.equal(false)
		expect(checkUnion("BAR")).to.equal(false)
		expect(checkUnion("OOF")).to.equal(false)
	end)

	it("should support intersection  types", function()
		local integerMax5000 = t.intersection(t.integer, t.numberMax(5000))
		expect(integerMax5000(1)).to.equal(true)
		expect(integerMax5000(5001)).to.equal(false)
		expect(integerMax5000(1.1)).to.equal(false)
		expect(integerMax5000("1")).to.equal(false)
	end)

	describe("array", function()
		it("should support array  types", function()
			local stringArray = t.array(t.string)
			local anyArray = t.array(t.any)
			local stringValues = t.values(t.string)
			expect(anyArray("foo")).to.equal(false)
			expect(anyArray({1, "2", 3})).to.equal(true)
			expect(stringArray({1, "2", 3})).to.equal(false)
			expect(stringArray()).to.equal(false)
			expect(stringValues()).to.equal(false)
			expect(anyArray({"1", "2", "3"}, t.string)).to.equal(true)
			expect(anyArray({
				foo = "bar"
			})).to.equal(false)
			expect(anyArray({
				[1] = "non",
				[5] = "sequential"
			})).to.equal(false)
		end)

		it("should not be fooled by sparse arrays", function()
			local anyArray = t.array(t.any)

			expect(anyArray({
				[1] = 1,
				[2] = 2,
				[4] = 4,
			})).to.equal(false)
		end)
	end)

	it("should support map types", function()
		local stringNumberMap = t.map(t.string, t.number)
		expect(stringNumberMap({})).to.equal(true)
		expect(stringNumberMap({a = 1})).to.equal(true)
		expect(stringNumberMap({[1] = "a"})).to.equal(false)
		expect(stringNumberMap({a = "a"})).to.equal(false)
		expect(stringNumberMap()).to.equal(false)
	end)

	it("should support interface types", function()
		local IVector3 = t.interface({
			x = t.number,
			y = t.number,
			z = t.number,
		})

		expect(IVector3({
			w = 0,
			x = 1,
			y = 2,
			z = 3,
		})).to.equal(true)

		expect(IVector3({
			w = 0,
			x = 1,
			y = 2,
		})).to.equal(false)
	end)

	it("should support strict interface types", function()
		local IVector3 = t.strictInterface({
			x = t.number,
			y = t.number,
			z = t.number,
		})

		expect(IVector3({
			w = 0,
			x = 1,
			y = 2,
			z = 3,
		})).to.equal(false)

		expect(IVector3({
			w = 0,
			x = 1,
			y = 2,
		})).to.equal(false)

		expect(IVector3({
			x = 1,
			y = 2,
			z = 3,
		})).to.equal(true)
	end)

	it("should support deep interface types", function()
		local IPlayer = t.interface({
			name = t.string,
			inventory = t.interface({
				size = t.number
			})
		})

		expect(IPlayer({
			name = "TestPlayer",
			inventory = {
				size = 1
			}
		})).to.equal(true)

		expect(IPlayer({
			inventory = {
				size = 1
			}
		})).to.equal(false)

		expect(IPlayer({
			name = "TestPlayer",
			inventory = {
			}
		})).to.equal(false)

		expect(IPlayer({
			name = "TestPlayer",
		})).to.equal(false)
	end)

	it("should support deep optional interface types", function()
		local IPlayer = t.interface({
			name = t.string,
			inventory = t.optional(t.interface({
				size = t.number
			}))
		})

		expect(IPlayer({
			name = "TestPlayer"
		})).to.equal(true)

		expect(IPlayer({
			name = "TestPlayer",
			inventory = {
			}
		})).to.equal(false)

		expect(IPlayer({
			name = "TestPlayer",
			inventory = {
				size = 1
			}
		})).to.equal(true)
	end)

	it("should support Roblox Instance types", function()
		local stringValueCheck = t.instance("StringValue")
		local stringValue = Instance.new("StringValue")
		local boolValue = Instance.new("BoolValue")

		expect(stringValueCheck(stringValue)).to.equal(true)
		expect(stringValueCheck(boolValue)).to.equal(false)
		expect(stringValueCheck()).to.equal(false)
	end)

	it("should support Roblox Instance types inheritance", function()
		local guiObjectCheck = t.instanceIsA("GuiObject")
		local frame = Instance.new("Frame")
		local textLabel = Instance.new("TextLabel")
		local stringValue = Instance.new("StringValue")

		expect(guiObjectCheck(frame)).to.equal(true)
		expect(guiObjectCheck(textLabel)).to.equal(true)
		expect(guiObjectCheck(stringValue)).to.equal(false)
		expect(guiObjectCheck()).to.equal(false)
	end)

	it("should support Roblox Enum types", function()
		local sortOrderEnumCheck = t.enum(Enum.SortOrder)
		expect(t.Enum(Enum.SortOrder)).to.equal(true)
		expect(t.Enum("Enum.SortOrder")).to.equal(false)

		expect(t.EnumItem(Enum.SortOrder.Name)).to.equal(true)
		expect(t.EnumItem("Enum.SortOrder.Name")).to.equal(false)

		expect(sortOrderEnumCheck(Enum.SortOrder.Name)).to.equal(true)
		expect(sortOrderEnumCheck(Enum.SortOrder.Custom)).to.equal(true)
		expect(sortOrderEnumCheck(Enum.EasingStyle.Linear)).to.equal(false)
		expect(sortOrderEnumCheck()).to.equal(false)
	end)

	it("should support wrapping function types", function()
		local checkFoo = t.tuple(t.string, t.number, t.optional(t.string))
		local foo = t.wrap(function(a, b, c)
			local result = string.format("%s %d", a, b)
			if c then
				result = result .. " " .. c
			end
			return result
		end, checkFoo)

		expect(pcall(foo)).to.equal(false)
		expect(pcall(foo, "a")).to.equal(false)
		expect(pcall(foo, 2)).to.equal(false)
		expect(pcall(foo, "a", 1)).to.equal(true)
		expect(pcall(foo, "a", 1, "b")).to.equal(true)
	end)

	it("should support strict types", function()
		local myType = t.strict(t.tuple(t.string, t.number))
		expect(pcall(function()
			myType("a", "b")
		end)).to.equal(false)
		expect(pcall(function()
			myType("a", 1)
		end)).to.equal(true)
	end)

	it("should support common OOP types", function()
		local MyClass = {}
		MyClass.__index = MyClass

		function MyClass.new()
			local self = setmetatable({}, MyClass)
			return self
		end

		local function instanceOfClass(class)
			return function(value)
				local tableSuccess, tableErrMsg = t.table(value)
				if not tableSuccess then
					return false, tableErrMsg or ""
				end

				local mt = getmetatable(value)
				if not mt or mt.__index ~= class then
					return false, "bad member of class"
				end

				return true
			end
		end

		local instanceOfMyClass = instanceOfClass(MyClass)

		local myObject = MyClass.new()
		expect(instanceOfMyClass(myObject)).to.equal(true)
		expect(instanceOfMyClass({})).to.equal(false)
		expect(instanceOfMyClass()).to.equal(false)
	end)

	it("should not treat NaN as numbers", function()
		expect(t.number(1)).to.equal(true)
		expect(t.number(0/0)).to.equal(false)
		expect(t.number("1")).to.equal(false)
	end)

	it("should not treat numbers as NaN", function()
		expect(t.nan(1)).to.equal(false)
		expect(t.nan(0/0)).to.equal(true)
		expect(t.nan("1")).to.equal(false)
	end)

	it("should allow union of number and NaN", function()
		local numberOrNaN = t.union(t.number, t.nan)
		expect(numberOrNaN(1)).to.equal(true)
		expect(numberOrNaN(0/0)).to.equal(true)
		expect(numberOrNaN("1")).to.equal(false)
	end)

	it("should support non-string keys for interfaces", function()
		local key = {}
		local myInterface = t.interface({ [key] = t.number })
		expect(myInterface({ [key] = 1 })).to.equal(true)
		expect(myInterface({ [key] = "1" })).to.equal(false)
	end)

	it("should support failing on non-string keys for strict interfaces", function()
		local myInterface = t.strictInterface({ a = t.number })
		expect(myInterface({ a = 1, [{}] = 2 })).to.equal(false)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEE03D456C94D4B459343492A52D1F6F9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ts</string>
						<string name="ScriptGuid">{CD1A769D-8824-4BBD-8BDC-B0FF27EAF1C0}</string>
						<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

local t = {}

function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

t.boolean = primitive("boolean")
t.coroutine = primitive("thread")
t.callback = primitive("function")
t.none = primitive("nil")
t.string = primitive("string")
t.table = primitive("table")
t.userdata = primitive("userdata")

function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

function t.nan(value)
	if value ~= value then
		return true
	else
		return false
	end
end

-- roblox types

t.Axes = primitive("Axes")
t.BrickColor = primitive("BrickColor")
t.CFrame = primitive("CFrame")
t.Color3 = primitive("Color3")
t.ColorSequence = primitive("ColorSequence")
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")
t.Faces = primitive("Faces")
t.Instance = primitive("Instance")
t.NumberRange = primitive("NumberRange")
t.NumberSequence = primitive("NumberSequence")
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")
t.PathWaypoint = primitive("PathWaypoint")
t.PhysicalProperties = primitive("PhysicalProperties")
t.Random = primitive("Random")
t.Ray = primitive("Ray")
t.Rect = primitive("Rect")
t.Region3 = primitive("Region3")
t.Region3int16 = primitive("Region3int16")
t.TweenInfo = primitive("TweenInfo")
t.UDim = primitive("UDim")
t.UDim2 = primitive("UDim2")
t.Vector2 = primitive("Vector2")
t.Vector3 = primitive("Vector3")
t.Vector3int16 = primitive("Vector3int16")
t.Enum = primitive("Enum")
t.EnumItem = primitive("EnumItem")

function t.literal(literal)
	return function(value)
		if value ~= literal then
			return false
		end
		return true
	end
end

t.exactly = t.literal

function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end
	if value%1 == 0 then
		return true
	else
		return false
	end
end

function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value >= min then
			return true
		else
			return false
		end
	end
end

function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value <= max then
			return true
		else
			return false
		end
	end
end

function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if min < value then
			return true
		else
			return false
		end
	end
end

function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value < max then
			return true
		else
			return false
		end
	end
end

t.numberPositive = t.numberMinExclusive(0)
t.numberNegative = t.numberMaxExclusive(0)

function t.numberConstrained(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.numberConstrainedExclusive(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end
		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

function t.tuple(...)
	local checks = {...}
	return function(...)
		local args = {...}
		for i = 1, #checks do
			local success = checks[i](args[i])
			if success == false then
				return false
			end
		end
		return true
	end
end

function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck), t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)
	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

do
	local arrayKeysCheck = t.keys(t.integer)

	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)
		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _, _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)

	function t.union(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				if check(value) then
					return true
				end
			end
			return false
		end
	end

	function t.intersection(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end
			return true
		end
	end
end

do
	local checkInterface = t.map(t.any, t.callback)

	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end
			return true
		end
	end

	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

function t.instance(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		return true
	end
end

function t.instanceIsA(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		return true
	end
end

function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

return t]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXF78F2129CC8B40218BF5F05F1C2FDA31">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal</string>
					<string name="ScriptGuid">{1F45505A-F764-4C1B-B69F-08EA22FA3F1F}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	class Signal

	Description:
		Lua-side duplication of the API of Events on Roblox objects. Needed for nicer
		syntax, and to ensure that for local events objects are passed by reference
		rather than by value where possible, as the BindableEvent objects always pass
		their signal arguments by value, meaning tables will be deep copied when that
		is almost never the desired behavior.

	API:
		void fire(...)
			Fire the event with the given arguments.

		Connection connect(Function handler)
			Connect a new handler to the event, returning a connection object that
			can be disconnected.

		... wait()
			Wait for fire to be called, and return the arguments it was given.
--]]

local Signal = {}

function Signal.new()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		return unpack(mArgData, 1, mArgDataCount)
	end

	sig.Connect = sig.connect
	sig.Wait = sig.wait
	sig.Fire = sig.fire

	return sig
end

return Signal]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Model" referent="RBXA71F8C9FA7D3497BAD501FB28A252CD2">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">EgRig</string>
				<Ref name="PrimaryPart">RBXB820B352B06F4197AB92128C54CBDF49</Ref>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="MeshPart" referent="RBXF76F9105C92F4D5A99A1055969EBE8CB">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>8.98392582</X>
						<Y>3.74999905</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<Vector3 name="InitialSize">
						<X>1.95920002</X>
						<Y>2.48250008</Y>
						<Z>1.95644999</Z>
					</Vector3>
					<BinaryString name="LODData"></BinaryString>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">true</bool>
					<token name="Material">256</token>
					<Content name="MeshID"><url>http://www.roblox.com/asset/?id=1527559</url></Content>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=1527559</url></Content>
					<string name="Name">Torso</string>
					<SharedString name="PhysicalConfigData">wsIjNDaTykHUe0x+IVyZGg==</SharedString>
					<BinaryString name="PhysicsData"></BinaryString>
					<float name="Reflectance">0</float>
					<token name="RenderFidelity">1</token>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureID"><null></null></Content>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="size">
						<X>2</X>
						<Y>2.4000001</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Decal" referent="RBXBF8980058144467AAB486DB09F56F1E0">
					<Properties>
						<Color3 name="Color3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="Face">5</token>
						<string name="Name">Decal</string>
						<BinaryString name="Tags"></BinaryString>
						<Content name="Texture"><url>http://www.roblox.com/asset/?id=102312301</url></Content>
						<float name="Transparency">0</float>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX4D139E12032245E69B30968E718F35DA">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RootRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX021BC54994794C60BAE962119BE4717B">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">HatAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXC6F220F9468C428D9F5BDA4B53149692">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0.5</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RightHipRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXF904E8AD42F34BA3AB54E3E5B046E5A0">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>-0.5</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">LeftHipRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX8A5AE1256CE747AAB8444B75AEA089B0">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">HeadRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXB820B352B06F4197AB92128C54CBDF49">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>8.98392582</X>
						<Y>3.74999905</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4279069100</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">HumanoidRootPart</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">1</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXE185DA982196454DBB208328A4F12C91">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RootRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX8ECB40B8A2C544CE991B2AA9F1FAB2FC">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>8.98392582</X>
						<Y>4.99800491</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294298928</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">Head</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1.5</X>
						<Y>1.5</Y>
						<Z>1.5</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXA1880FC2119C4B74B7880BD3F29440D7">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-0.599999905</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">HeadRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Humanoid" referent="RBXB07CC5978F0C455EAD431186D9269E9A">
				<Properties>
					<bool name="AutoJumpEnabled">true</bool>
					<bool name="AutoRotate">true</bool>
					<bool name="AutomaticScalingEnabled">false</bool>
					<bool name="BreakJointsOnDeath">true</bool>
					<token name="CollisionType">0</token>
					<token name="DisplayDistanceType">0</token>
					<float name="HealthDisplayDistance">100</float>
					<token name="HealthDisplayType">2</token>
					<float name="Health_XML">100</float>
					<float name="HipHeight">2.70000005</float>
					<Vector3 name="InternalBodyScale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<float name="InternalHeadScale">1</float>
					<float name="JumpHeight">7.19999981</float>
					<float name="JumpPower">50</float>
					<float name="MaxHealth">100</float>
					<float name="MaxSlopeAngle">89.9000015</float>
					<string name="Name">Humanoid</string>
					<float name="NameDisplayDistance">100</float>
					<token name="NameOcclusion">2</token>
					<token name="RigType">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="UseJumpPower">true</bool>
					<float name="WalkSpeed">16</float>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX7B762A345FEC4E359C60DD23CC7E3D16">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>9.48392582</X>
						<Y>2.24999905</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">UpperRightLeg</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>1.5</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX7CAC26E476EA4BC3AB203FDAB0C8CBC6">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RightHipRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX3A6E2388B8D34CA6ABB695DE76CE1618">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-0.75</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RightKneeRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX6BB2F278F3EC4D1393461999DD07A31B">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>9.48392582</X>
						<Y>0.75000298</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">LowerRightLeg</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>1.5</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX5639B0E63BAB4713B228740003309D50">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.75</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">RightKneeRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX2148973EECB549DEA5476D31E1ACB19F">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>8.48392582</X>
						<Y>2.24999905</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">UpperLeftLeg</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>1.5</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX73363F9E99E847FD8EB660B15504346F">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-0.75</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">LeftKneeRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXB97B4911619444F9855454B3D2518A2F">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">LeftHipRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXCE0265D407E84CFFAEEF060F737CF1C6">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>8.48392582</X>
						<Y>0.75000298</Y>
						<Z>12.1085978</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294112243</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="Name">LowerLeftLeg</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.5</X>
						<Y>1.5</Y>
						<Z>0.5</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXDB018C3B746243FAA415660AE93ABF0C">
					<Properties>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.75</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">LeftKneeRigAttachment</string>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBXCFA11E03EA044BF3B3931B00BA146D3E">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX0E8393EE130246EBAB03B4D641DE478F">
		<Properties>
			<Color3 name="Ambient">
				<R>0.501960814</R>
				<G>0.501960814</G>
				<B>0.501960814</B>
			</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<bool name="LegacyOutlines">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
		<Item class="Sky" referent="RBX2C66E48B4C2A49A9B2C3628B96E04380">
			<Properties>
				<bool name="CelestialBodiesShown">false</bool>
				<float name="MoonAngularSize">11</float>
				<Content name="MoonTextureId"><url>rbxasset://sky/moon.jpg</url></Content>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<Content name="SkyboxDn"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<Content name="SkyboxFt"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<Content name="SkyboxLf"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<Content name="SkyboxRt"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<Content name="SkyboxUp"><url>http://www.roblox.com/asset/?ID=1361097</url></Content>
				<int name="StarCount">0</int>
				<float name="SunAngularSize">21</float>
				<Content name="SunTextureId"><url>rbxasset://sky/sun.jpg</url></Content>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="HttpService" referent="0">
		<Properties>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX3D1FFB724A3740DCA6D1EAFEF6D0F54B">
		<Properties>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBX73DCA80B74A34C418F1B7B49A55B38B4">
		<Properties>
			<bool name="AutomaticRetry">true</bool>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="CLRkqnIOEGwqJfkcOaVQeg==">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
AAAHAAAACAAAAAEAAAAIAAAAAgAAAAIAAAAJAAAAAwAAAAIAAAAIAAAACgAAAAIAAAAKAAAA
CwAAAAIAAAALAAAADAAAAAIAAAAMAAAACQAAAAQAAAANAAAADgAAAAQAAAAOAAAADwAAAAQA
AAAPAAAAEAAAAAQAAAAQAAAABQAAAAUAAAAQAAAAEQAAAAUAAAARAAAAEgAAAAUAAAASAAAA
BgAAAAYAAAASAAAAEwAAAAYAAAATAAAAFAAAAAcAAAAVAAAAFgAAAAcAAAAWAAAACAAAAAgA
AAAWAAAACgAAAAoAAAAWAAAAFwAAAAoAAAAXAAAAGAAAAAoAAAAYAAAAGQAAAAoAAAAZAAAA
GgAAAAoAAAAaAAAACwAAAAsAAAAaAAAAGwAAAAsAAAAbAAAAHAAAAAsAAAAcAAAADAAAAA0A
AAAdAAAADgAAAA4AAAAdAAAAHgAAAA4AAAAeAAAAHwAAAA4AAAAfAAAAIAAAAA4AAAAgAAAA
EAAAAA4AAAAQAAAADwAAABAAAAAgAAAAIQAAABAAAAAhAAAAIgAAABAAAAAiAAAAEQAAABEA
AAAiAAAAIwAAABEAAAAjAAAAEgAAABIAAAAjAAAAEwAAABMAAAAjAAAAJAAAABMAAAAkAAAA
FwAAABMAAAAXAAAAFgAAABMAAAAWAAAAFQAAABMAAAAVAAAAFAAAABcAAAAlAAAAGAAAABcA
AAAkAAAAJgAAABcAAAAmAAAAJQAAABgAAAAaAAAAGQAAABgAAAAlAAAAHwAAABgAAAAfAAAA
GgAAABoAAAAcAAAAGwAAABoAAAAfAAAAHgAAABoAAAAeAAAAHAAAABwAAAAeAAAAHQAAAB8A
AAAmAAAAJwAAAB8AAAAnAAAAIAAAAB8AAAAlAAAAJgAAACAAAAAnAAAAIQAAACEAAAAnAAAA
IwAAACEAAAAjAAAAIgAAACMAAAAnAAAAJgAAACMAAAAmAAAAJAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD+ZAAAABAAAAHSd/L4AQEu536j+vwAAAAAAQEu5
36j+v9Yfv79GnAS/Ber1v9Yfv79g49a8ZjX+v9Yfv78AAAA2Cpz+vwAAAACW+f+/QGwoPAAA
AABGnAS/Ber1v/+NX8AAQEu5QGwoPAAAAACOZSm/2Evuv9Yfv7/w/3+/rFrcv98Q/79GnAS/
kH7tvyOmAMAAAAA2Ber1vyiMH8AAAAA2rFrcvwAAAAAAAADAQGwoPCiMH8DPsd2/gKErPP4n
W8AAQEu5FeEBvwT6VsBGnAS/v7z6vv4nW8BGnAS/QGwoPAAAAADw/3+/rFrcv9Yfv7/I/7S/
oqizv91p+L/w/3+/6cLUv5LyFsDw/3+/bKK+v/VbHcBGnAS/6cLUv0v2NsBGnAS/iH6tv5IG
OsAAQEu5oqizvwhmTsAAQEu5nFF9v9Yfv78AAADAQGwoPAAAAAC8Ove/FeEBvwhmTsDw/3+/
QGwoPJIGOsDI/7S/QGwoPGpGOMBDd7G/AOK4viiMH8B4INa/zCzgviOmAMCy1e6/v7z6viOm
AMC8Ove/QGwoPEiXSsBGnAS/LJl0v6yEP8Dw/3+/pxZbv0iXSsDw/3+/zCzgvgAAAADI/7S/
oqizv9Yfv7/Psd2/nFF9vyOmAMB4INa/LJl0vyOmAMDI/7S/4mylvwxx77+vga2/1wGzvyP9
D8CcYqS/53Omv6vsLcDw/3+/SG2bv9Yfv7+8Ove/FeEBvwAAAAD6ou+/NLcmv7bCMsA6aqa/
upE9vyiMH8D8/7+/pxZbvwAAAADPsd2/nFF9vyiMH8A8way/IYeGvwHZKMBYnpK/mk2RvyYB
AAAAAAAAAQAAAAYAAAAAAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAA
BAAAAAEAAAABAAAABQAAAA0AAAABAAAADQAAABsAAAABAAAAGwAAAC0AAAABAAAALQAAADAA
AAABAAAAMAAAACUAAAABAAAAJQAAABIAAAABAAAAEgAAAAgAAAABAAAACAAAAAYAAAABAAAA
BAAAAAcAAAABAAAABwAAAAUAAAACAAAABgAAAAgAAAACAAAACAAAAAkAAAACAAAACQAAAAoA
AAACAAAACgAAAAMAAAADAAAACgAAAAsAAAADAAAACwAAAAQAAAAEAAAACwAAAAwAAAAEAAAA
DAAAAAcAAAAFAAAABwAAAA4AAAAFAAAADgAAAA0AAAAHAAAADAAAAA8AAAAHAAAADwAAABAA
AAAHAAAAEAAAABEAAAAHAAAAEQAAAA4AAAAIAAAAEgAAAAkAAAAJAAAAEgAAACUAAAAJAAAA
JQAAABMAAAAJAAAAEwAAABQAAAAJAAAAFAAAAAoAAAAKAAAAFAAAABUAAAAKAAAAFQAAABYA
AAAKAAAAFgAAAAwAAAAKAAAADAAAAAsAAAAMAAAAFgAAABcAAAAMAAAAFwAAABgAAAAMAAAA
GAAAABkAAAAMAAAAGQAAAA8AAAANAAAADgAAABoAAAANAAAAGgAAACwAAAANAAAALAAAABsA
AAAOAAAAEQAAABwAAAAOAAAAHAAAAB0AAAAOAAAAHQAAAB4AAAAOAAAAHgAAAB8AAAAOAAAA
HwAAACAAAAAOAAAAIAAAACEAAAAOAAAAIQAAABoAAAAPAAAAGQAAABAAAAAQAAAAGQAAACIA
AAAQAAAAIgAAACMAAAAQAAAAIwAAACQAAAAQAAAAJAAAABwAAAAQAAAAHAAAABEAAAATAAAA
JQAAADAAAAATAAAAMAAAACYAAAATAAAAJgAAACcAAAATAAAAJwAAACgAAAATAAAAKAAAACkA
AAATAAAAKQAAABQAAAAUAAAAKQAAACoAAAAUAAAAKgAAABUAAAAVAAAAKgAAACsAAAAVAAAA
KwAAABYAAAAWAAAAKwAAABcAAAAXAAAAIwAAACIAAAAXAAAAIgAAABkAAAAXAAAAGQAAABgA
AAAXAAAAKwAAACMAAAAaAAAAIQAAACAAAAAaAAAAIAAAACwAAAAbAAAALAAAAC0AAAAcAAAA
JAAAAB4AAAAcAAAAHgAAAB0AAAAeAAAAJAAAACMAAAAeAAAAIwAAAC4AAAAeAAAALgAAAC8A
AAAeAAAALwAAAB8AAAAfAAAALwAAACAAAAAgAAAALwAAACcAAAAgAAAAJwAAACYAAAAgAAAA
JgAAACwAAAAjAAAAKwAAAC4AAAAmAAAAMAAAAC0AAAAmAAAALQAAACwAAAAnAAAALwAAACoA
AAAnAAAAKgAAACgAAAAoAAAAKgAAACkAAAAqAAAALwAAADEAAAAqAAAAMQAAACsAAAArAAAA
MQAAADIAAAArAAAAMgAAAC4AAAAuAAAAMgAAAC8AAAAvAAAAMgAAADEAAAAQAAAAAAAAAAAA
AAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/kwAAAAQAAAAjpgDAAAAANt2R+D/fEP+/
RpwEv2km8D/WH7+/AEBLuZCrAEAAAAAAAEBLuZCrAED+J1vAAAAANp5KBz+SBjrAAEBLuYJQ
tj8ojB/AAEBLuYcC3z/dafi/8P9/v5p31z/WH7+/RpwEv92R+D/1Wx3ARpwEv5p31z+S8hbA
8P9/vyBXwT8AAAAARpwEv92R+D8AAAAAlvn/vwDFLjz/jV/AAEBLuQDFLjwE+lbARpwEv0Cu
Aj8IZk7AAEBLuSBXgT9L9jbARpwEv2kmsD8Mce+/r4GtvyKwtT/WH7+/yP+0v4JQtj/WH7+/
8P9/v4cC3z8AQLO5qDZbvx2n5j+r7C3A8P9/vywVnj8ojB/APMGsv3I1iT8j/Q/AnGKkv8kb
qT8AAAAA8P9/v4cC3z8AAAAA1mT9vwQYKT7WH7+/AAAAwADFLjz+J1vARpwEvwDFLjwIZk7A
8P9/vwDFLjxIl0rA8P9/v+L/6j6shD/A8P9/v1BzYD9Il0rARpwEv9H1eT8jpgDAyP+0vy8b
qD/WH7+/z7HdvyBXgT8AAAAAyP+0v4JQtj+2wjLAOmqmvzv7Qj8B2SjAWJ6Sv3/1kz8ojB/A
/P+/v1BzYD8jpgDAeCDWv9H1eT8AAAAAvDr3v55KBz/WH7+/vDr3v55KBz8jpgDAstXuv0Cu
Aj8jpgDAvDr3vwDFLjySBjrAyP+0vwDFLjxqRjjAQ3exvxy1wz4AAAAAZlblvybYXT8AAAAA
z7HdvyBXgT8ojB/AeCDWv+L/6j4ojB/Az7HdvwDFLjwaAQAAAAAAAAEAAAACAAAAAAAAAAIA
AAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAAFAAAAAAAAAAUAAAAGAAAAAAAAAAYAAAABAAAA
AQAAAAcAAAAIAAAAAQAAAAgAAAACAAAAAQAAAAYAAAAJAAAAAQAAAAkAAAAKAAAAAQAAAAoA
AAAHAAAAAgAAAAgAAAALAAAAAgAAAAsAAAADAAAAAwAAAAsAAAAYAAAAAwAAABgAAAAiAAAA
AwAAACIAAAAuAAAAAwAAAC4AAAAtAAAAAwAAAC0AAAAnAAAAAwAAACcAAAAZAAAAAwAAABkA
AAAMAAAAAwAAAAwAAAANAAAAAwAAAA0AAAAEAAAABAAAAA0AAAAOAAAABAAAAA4AAAAPAAAA
BAAAAA8AAAAFAAAABQAAAA8AAAAQAAAABQAAABAAAAAGAAAABgAAABAAAAAJAAAABwAAABEA
AAASAAAABwAAABIAAAATAAAABwAAABMAAAAIAAAABwAAAAoAAAARAAAACAAAABQAAAALAAAA
CAAAABMAAAAUAAAACQAAABAAAAAVAAAACQAAABUAAAAKAAAACgAAABUAAAAWAAAACgAAABYA
AAAXAAAACgAAABcAAAARAAAACwAAABQAAAAYAAAADAAAABkAAAAaAAAADAAAABoAAAAqAAAA
DAAAACoAAAAwAAAADAAAADAAAAArAAAADAAAACsAAAAcAAAADAAAABwAAAAbAAAADAAAABsA
AAANAAAADQAAABsAAAAOAAAADgAAABsAAAAcAAAADgAAABwAAAAdAAAADgAAAB0AAAAeAAAA
DgAAAB4AAAAfAAAADgAAAB8AAAAPAAAADwAAAB8AAAAQAAAAEAAAAB8AAAAeAAAAEAAAAB4A
AAAVAAAAEQAAABcAAAAgAAAAEQAAACAAAAASAAAAEgAAACEAAAAuAAAAEgAAAC4AAAAiAAAA
EgAAACIAAAAYAAAAEgAAABgAAAATAAAAEgAAACAAAAAhAAAAEwAAABgAAAAUAAAAFQAAACMA
AAAkAAAAFQAAACQAAAAWAAAAFQAAAB4AAAAjAAAAFgAAACQAAAAlAAAAFgAAACUAAAAXAAAA
FwAAACUAAAAmAAAAFwAAACYAAAAgAAAAGQAAACcAAAAoAAAAGQAAACgAAAAaAAAAGgAAACgA
AAApAAAAGgAAACkAAAAqAAAAHAAAACsAAAAsAAAAHAAAACwAAAAdAAAAHQAAACwAAAAeAAAA
HgAAACwAAAAjAAAAIAAAACYAAAAhAAAAIQAAACgAAAAtAAAAIQAAAC0AAAAuAAAAIQAAACYA
AAApAAAAIQAAACkAAAAoAAAAIwAAACUAAAAkAAAAIwAAACwAAAAlAAAAJQAAACwAAAAvAAAA
JQAAAC8AAAApAAAAJQAAACkAAAAmAAAAJwAAAC0AAAAoAAAAKQAAAC8AAAAwAAAAKQAAADAA
AAAqAAAAKwAAADAAAAAsAAAALAAAADAAAAAvAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA
AAAAAAAAAAAAAAAAAACAP5YAAAAEAAAA/o1fwABQTTkAkCs8mC1bwAAAAACeSgc/AvpWwIiP
BD9ArgI/mC1bwIiPBD8AkCs8AAAAAP7//z8AkCs8AAAAAAAAAACQqwBAB2ZOwAAAAAAgV4E/
B2ZOwP7/fz8AkCs84pxKwIiPBD/R9Xk/Roo/wP7/fz97ZmA/4pxKwP7/fz/i/+o+Ciu/v5T5
/z8AkCs8AAAAANRk/T8EGCk+AAAAAAhfHj72u/4/Ciu/vwAAAACQqwBALAw6wAAAAADtVrY/
SvY2wIiPBD/ULLA/LAw6wMv/tD8AkCs8quwtwP7/fz+WG54/zkA4wEZ3sT9ym8M+Gr0ywD5q
pj+S4UI/Ciu/v7o69z+eSgc/vasAwLo69z8AkCs8vasAwLLV7j8UuwI/AAAAALo69z+eSgc/
AAAAAIiPBD9HmPg/Ciu/v4iPBD9HmPg/3hD/v4iPBD/ULPA/vasAwAAAAABHmPg/jYYfwAAA
AADxCN8/9FsdwIiPBD+ad9c/jYYfwHgg1j/i/+o+jYYfwGWr3T8AkCs8LPgWwP7/fz+2UME/
iPcPwDZcpD80Iqk/jYYfwNW6rD9yNYk/ANkowMikkj9/9ZM/jYYfwP7/vz97ZmA/Ciu/v2Wr
3T8gV4E/AAAAAPqi7z+4ICw/vasAwHgg1j/R9Xk/AAAAAOQpWz+HreY/Ciu/v/7/fz/xCN8/
3Gn4v/7/fz+ad9c/vasAwMv/tD+aIag/Ciu/v8v/tD/tVrY/AAAAAGWr3T8gV4E/AAAAAP7/
fz/xCN8/C3Hvv7OBrT8isLU/AAAAAMv/tD/tVrY/IAEAAAAAAAABAAAAAgAAAAAAAAACAAAA
AwAAAAAAAAADAAAABwAAAAAAAAAHAAAAEQAAAAAAAAARAAAAIAAAAAAAAAAgAAAAFgAAAAAA
AAAWAAAACwAAAAAAAAALAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAGAAAA
AgAAAAEAAAAFAAAADgAAAAEAAAAOAAAAHAAAAAEAAAAcAAAAHQAAAAEAAAAdAAAADwAAAAEA
AAAPAAAABgAAAAIAAAAHAAAAAwAAAAIAAAAGAAAACAAAAAIAAAAIAAAACQAAAAIAAAAJAAAA
CgAAAAIAAAAKAAAABwAAAAQAAAALAAAADAAAAAQAAAAMAAAAGAAAAAQAAAAYAAAAJwAAAAQA
AAAnAAAALgAAAAQAAAAuAAAAMQAAAAQAAAAxAAAALwAAAAQAAAAvAAAAKQAAAAQAAAApAAAA
GQAAAAQAAAAZAAAADQAAAAQAAAANAAAABQAAAAUAAAANAAAADgAAAAYAAAAPAAAAEAAAAAYA
AAAQAAAACAAAAAcAAAAKAAAAEQAAAAgAAAAQAAAAEgAAAAgAAAASAAAACQAAAAkAAAATAAAA
CgAAAAkAAAASAAAAFAAAAAkAAAAUAAAAEwAAAAoAAAATAAAAEQAAAAsAAAAVAAAADAAAAAsA
AAAWAAAAFwAAAAsAAAAXAAAAFQAAAAwAAAAVAAAAGAAAAA0AAAAZAAAAGgAAAA0AAAAaAAAA
DgAAAA4AAAAaAAAAGwAAAA4AAAAbAAAAHAAAAA8AAAAdAAAAHgAAAA8AAAAeAAAAEAAAABAA
AAAeAAAAEgAAABEAAAATAAAAHwAAABEAAAAfAAAAIAAAABIAAAAeAAAAIQAAABIAAAAhAAAA
IgAAABIAAAAiAAAAIwAAABIAAAAjAAAAJAAAABIAAAAkAAAAFAAAABMAAAAUAAAAJQAAABMA
AAAlAAAAHwAAABQAAAAkAAAAJQAAABUAAAAmAAAAJwAAABUAAAAnAAAAGAAAABUAAAAXAAAA
JgAAABYAAAAgAAAAFwAAABcAAAAgAAAAHwAAABcAAAAfAAAAJQAAABcAAAAlAAAAKAAAABcA
AAAoAAAAJgAAABkAAAApAAAAGgAAABoAAAApAAAAKgAAABoAAAAqAAAAGwAAABsAAAAqAAAA
KwAAABsAAAArAAAAIQAAABsAAAAhAAAAHgAAABsAAAAeAAAAHQAAABsAAAAdAAAAHAAAACEA
AAArAAAALAAAACEAAAAsAAAAIgAAACIAAAAlAAAAIwAAACIAAAAsAAAAJQAAACMAAAAlAAAA
JAAAACUAAAAsAAAAKAAAACYAAAAoAAAALQAAACYAAAAtAAAAMQAAACYAAAAxAAAALgAAACYA
AAAuAAAAJwAAACgAAAAsAAAALQAAACkAAAAvAAAAKgAAACoAAAAtAAAAKwAAACoAAAAvAAAA
MQAAACoAAAAxAAAALQAAACsAAAAwAAAALAAAACsAAAAtAAAAMAAAACwAAAAwAAAALQAAABAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD+6AAAABAAAAAByYEAAAAAA
kKsAQAByYEC1ggQ/3ZH4PwDQszli+B0+9rv+PwDQszkAAAAAkKsAQAByYEC1ggS/3ZH4PwDQ
szkRHVs/h63mPwDQszm1ggQ/3ZH4PwByYEAAAIA/hwLfPwAAgLRnVuU/KFVYvwDQszm1ggS/
3ZH4PwDQszkRHVu/h63mPwByYEAAAIC/hwLfPwDQszkAAIA/hwLfPwDQszlJJKc/Uf3APwBy
YECO7LQ/rkO2PwByYEC9Ovc/zLoBvwByYEBnq90/bh59vwDQszlnq90/bh59vwDQszmGitE/
hGWOvwDQszmO7LQ/bpWzvwDQszkAAIA/ckfcvwDQszmpw3A/knzfvwDQszm1ggQ/yNb1vwDQ
szkAAAAA4Kj+vwDQszm1ggS/yNb1vwDQszkAAIC/ckfcvwDQszkVI6W/I8O/vwDQszmO7LS/
bpWzvwDQszlDGsG/ytijvwDQszlnq92/bh59vwDQszmRnO+/EYQmvwDQszm9Ove/zLoBvwDQ
szkAAADAAJArPADQsznWZP2/YrEoPgDQszm9Ove/9TAHPwDQszlnVuW/UctdPwDQszlnq92/
IFeBPwDQszmO7LS/rkO2PwDQszkAAIC/hwLfPwDQszmO7LQ/rkO2PwDQszkxpr8/aXuoPwDQ
szlnq90/IFeBPwDQszm9Ovc/9TAHPwDQsznWZP0/YrEoPgDQszkAAABAAJArPADQszm9Ovc/
zLoBvwByYECO7LS/rkO2PwByYEBnq90/IFeBPwByYEAAAABAAJArPAByYECO7LQ/bpWzvwBy
YEAAAIA/ckfcvwByYEC1ggQ/yNb1vwByYEAAAAAA4Kj+vwByYEC1ggS/yNb1vwByYEAAAIC/
ckfcvwByYECO7LS/bpWzvwByYEBnq92/bh59vwByYEC9Ove/zLoBvwByYEAAAADAAJArPABy
YEC9Ove/9TAHPwByYEBnq92/IFeBPwByYEC9Ovc/9TAHP2gBAAAAAAAAAQAAAAIAAAAAAAAA
AgAAAAMAAAAAAAAAAwAAAAkAAAAAAAAACQAAAAQAAAAAAAAABAAAAAsAAAAAAAAACwAAAC4A
AAAAAAAALgAAADwAAAAAAAAAPAAAADsAAAAAAAAAOwAAADoAAAAAAAAAOgAAADkAAAAAAAAA
OQAAADgAAAAAAAAAOAAAADcAAAAAAAAANwAAADYAAAAAAAAANgAAADUAAAAAAAAANQAAADQA
AAAAAAAANAAAADMAAAAAAAAAMwAAADIAAAAAAAAAMgAAADEAAAAAAAAAMQAAABAAAAAAAAAA
EAAAAA8AAAAAAAAADwAAADAAAAAAAAAAMAAAAD0AAAAAAAAAPQAAAC8AAAAAAAAALwAAAA4A
AAAAAAAADgAAAAcAAAAAAAAABwAAAAEAAAABAAAABQAAAAYAAAABAAAABgAAAAIAAAABAAAA
BwAAAAUAAAACAAAABgAAAAgAAAACAAAACAAAAAMAAAADAAAACAAAAAkAAAAEAAAACQAAAAoA
AAAEAAAACgAAAAsAAAAFAAAABwAAAAwAAAAFAAAADAAAAAgAAAAFAAAACAAAAAYAAAAHAAAA
DQAAAAwAAAAHAAAADgAAAA0AAAAIAAAADwAAABAAAAAIAAAAEAAAABEAAAAIAAAAEQAAABIA
AAAIAAAAEgAAABMAAAAIAAAAEwAAABQAAAAIAAAAFAAAABUAAAAIAAAAFQAAABYAAAAIAAAA
FgAAABcAAAAIAAAAFwAAABgAAAAIAAAAGAAAABkAAAAIAAAAGQAAABoAAAAIAAAAGgAAABsA
AAAIAAAAGwAAABwAAAAIAAAAHAAAAB0AAAAIAAAAHQAAAB4AAAAIAAAAHgAAAB8AAAAIAAAA
HwAAACAAAAAIAAAAIAAAACEAAAAIAAAAIQAAACIAAAAIAAAAIgAAACMAAAAIAAAAIwAAACQA
AAAIAAAAJAAAACUAAAAIAAAAJQAAACYAAAAIAAAAJgAAAAoAAAAIAAAACgAAAAkAAAAIAAAA
DAAAAA0AAAAIAAAADQAAACcAAAAIAAAAJwAAACgAAAAIAAAAKAAAACkAAAAIAAAAKQAAACoA
AAAIAAAAKgAAACsAAAAIAAAAKwAAACwAAAAIAAAALAAAAC0AAAAIAAAALQAAAA8AAAAKAAAA
JgAAAAsAAAALAAAAJgAAACUAAAALAAAAJQAAAC4AAAANAAAADgAAACcAAAAOAAAALwAAACgA
AAAOAAAAKAAAACcAAAAPAAAALQAAACwAAAAPAAAALAAAADAAAAAQAAAAEgAAABEAAAAQAAAA
MQAAABIAAAASAAAAMQAAABMAAAATAAAAMQAAADIAAAATAAAAMgAAABQAAAAUAAAAMgAAABUA
AAAVAAAAMgAAADMAAAAVAAAAMwAAABYAAAAWAAAAMwAAADQAAAAWAAAANAAAABcAAAAXAAAA
NAAAADUAAAAXAAAANQAAABgAAAAYAAAANQAAADYAAAAYAAAANgAAABkAAAAZAAAANgAAABoA
AAAaAAAANgAAADcAAAAaAAAANwAAABsAAAAbAAAANwAAABwAAAAcAAAANwAAADgAAAAcAAAA
OAAAAB0AAAAdAAAAOAAAAB4AAAAeAAAAOAAAADkAAAAeAAAAOQAAAB8AAAAfAAAAOQAAADoA
AAAfAAAAOgAAACAAAAAgAAAAOgAAACEAAAAhAAAAOgAAADsAAAAhAAAAOwAAACIAAAAiAAAA
OwAAACMAAAAjAAAAPAAAACQAAAAjAAAAOwAAADwAAAAkAAAAPAAAAC4AAAAkAAAALgAAACUA
AAAoAAAALwAAACkAAAApAAAALwAAAD0AAAApAAAAPQAAACoAAAAqAAAAPQAAACsAAAArAAAA
PQAAADAAAAArAAAAMAAAACwAAAA=</SharedString>
		<SharedString md5="wsIjNDaTykHUe0x+IVyZGg==">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
AAA2AAAANQAAADYAAAA3AAAANQAAADgAAAAbAAAANQAAABsAAAAaAAAAOQAAAA8AAAAOAAAA
OQAAAA4AAAA4AAAAOgAAAC4AAAAtAAAAOwAAADwAAAA5AAAAOwAAADkAAAA4AAAAOwAAADgA
AAA1AAAAOwAAADUAAAA3AAAAPQAAAD4AAAAvAAAAPwAAAEAAAABBAAAAQgAAAEMAAAAiAAAA
QgAAACIAAAAhAAAAQgAAACEAAAAVAAAAQgAAAEQAAABDAAAARQAAAEYAAABHAAAASAAAAEkA
AABKAAAASwAAAA4AAAAnAAAASwAAACcAAAAfAAAASwAAAB8AAAAcAAAASwAAABwAAAAbAAAA
SwAAADgAAAAOAAAASwAAABsAAAA4AAAATAAAAAMAAABNAAAATAAAAE0AAABOAAAATAAAAAQA
AAADAAAATAAAAE4AAABPAAAAUAAAABoAAAAZAAAAUAAAAFEAAABSAAAAUwAAAD4AAAARAAAA
UwAAABEAAAATAAAAVAAAABIAAAARAAAAVAAAAFUAAAAWAAAAVgAAABAAAAAPAAAAVgAAAA8A
AABBAAAAVwAAAFEAAABDAAAAVwAAAEMAAABEAAAAWAAAAD4AAABTAAAAWAAAAFMAAABPAAAA
WAAAADAAAAAvAAAAWAAAAC8AAAA+AAAAWQAAABgAAABWAAAAWQAAAFYAAABBAAAAWQAAAEEA
AABAAAAAWQAAAEAAAAAJAAAAWgAAAAoAAAANAAAAWwAAAFwAAABIAAAAXQAAAEgAAABKAAAA
XQAAAFsAAABIAAAAXQAAAF4AAABbAAAAXwAAAGAAAABhAAAAXwAAAGIAAABjAAAAZAAAAGUA
AABmAAAAZAAAAGYAAAApAAAAZwAAAGgAAAANAAAAZwAAAA0AAAAMAAAAaQAAAGgAAABnAAAA
aQAAAGcAAABqAAAAawAAAGwAAABtAAAAawAAAG0AAABuAAAAbwAAAHAAAABxAAAAcgAAAHMA
AAB0AAAAdQAAAHYAAAA9AAAAdQAAAD0AAAAvAAAAdQAAAC8AAAAxAAAAdwAAAAcAAAB4AAAA
dwAAAGYAAABlAAAAdwAAAHgAAABmAAAAdwAAAGUAAAB5AAAAegAAAG0AAABsAAAAegAAAHsA
AAB8AAAAfQAAAFwAAAB+AAAAfQAAAH4AAAB/AAAAgAAAAAEAAAAqAAAAgAAAAAIAAAABAAAA
gQAAADQAAAAQAAAAgQAAABAAAABWAAAAgQAAAFYAAAAYAAAAgQAAAAYAAAAFAAAAgQAAAAUA
AAA0AAAAgQAAABgAAAAGAAAAggAAAE8AAABTAAAAggAAABMAAAAzAAAAggAAAFMAAAATAAAA
ggAAADMAAAAEAAAAggAAAAQAAABMAAAAggAAAEwAAABPAAAAgwAAADIAAAASAAAAgwAAABIA
AABUAAAAgwAAAFQAAAAWAAAAgwAAABYAAAAVAAAAgwAAABUAAAAhAAAAgwAAACEAAAAyAAAA
hAAAABkAAAAeAAAAhAAAAFAAAAAZAAAAhAAAAFEAAABQAAAAhAAAAB4AAAAiAAAAhAAAACIA
AABDAAAAhAAAAEMAAABRAAAAhQAAAEcAAACGAAAAhQAAAIYAAACHAAAAiAAAAEgAAABcAAAA
iAAAAFwAAAB9AAAAiAAAAH0AAABSAAAAiAAAAEkAAABIAAAAiQAAAH8AAAB+AAAAigAAAIsA
AAALAAAAjAAAAIsAAACKAAAAjAAAAIoAAACNAAAAjAAAAHkAAACLAAAAjgAAAEAAAAA/AAAA
jgAAAD8AAACPAAAAkAAAAJEAAABpAAAAkAAAAGkAAABqAAAAkgAAAIsAAAB5AAAAkgAAAHkA
AABlAAAAkwAAAIsAAACSAAAAkwAAAJIAAACUAAAAkwAAAAsAAACLAAAAkwAAAAwAAAALAAAA
lQAAAH8AAACJAAAAlQAAAJYAAAA3AAAAlQAAADYAAAB/AAAAlQAAADcAAAA2AAAAlwAAAI8A
AAA/AAAAlwAAADwAAACYAAAAmQAAABQAAACaAAAAmQAAAHQAAABzAAAAmwAAAI0AAACKAAAA
mwAAAE4AAABNAAAAmwAAAE0AAACNAAAAmwAAAJwAAABOAAAAnQAAAHMAAAByAAAAnQAAAEoA
AABJAAAAnQAAAHIAAABKAAAAnQAAAEkAAABXAAAAnQAAAEQAAABzAAAAnQAAAFcAAABEAAAA
ngAAAIwAAACNAAAAngAAABcAAAAIAAAAnwAAAD0AAAB2AAAAnwAAAHYAAACgAAAAnwAAAKAA
AAChAAAAnwAAAKEAAABVAAAAogAAAKMAAACkAAAAogAAAKQAAAA6AAAApQAAAHYAAAB1AAAA
pQAAAKYAAABhAAAApwAAAKgAAACpAAAApwAAAKkAAACJAAAApwAAAIkAAAB+AAAApwAAAKoA
AACoAAAAqwAAAI8AAACsAAAAqwAAAKwAAACtAAAAqwAAAK4AAACvAAAAqwAAAK8AAACOAAAA
qwAAAI4AAACPAAAAqwAAAK0AAACuAAAAsAAAAHQAAACiAAAAsAAAAKIAAAA6AAAAsAAAAHIA
AAB0AAAAsAAAADoAAAAtAAAAsQAAALIAAACzAAAAsQAAALMAAAC0AAAAsQAAALQAAACQAAAA
sQAAAJAAAABqAAAAtQAAAA0AAABoAAAAtQAAAGgAAAC2AAAAtQAAALYAAACmAAAAtQAAAFoA
AAANAAAAtwAAALgAAAC5AAAAtwAAALkAAACFAAAAtwAAAIUAAACHAAAAtwAAALoAAAC4AAAA
uwAAAIcAAACGAAAAuwAAAAIAAACAAAAAuwAAAIYAAAACAAAAuwAAAIAAAAC8AAAAuwAAALwA
AAC9AAAAuwAAAL0AAACHAAAAvgAAAGIAAAC2AAAAvgAAAGgAAABpAAAAvgAAALYAAABoAAAA
vgAAAGkAAACRAAAAvwAAAGYAAAB4AAAAvwAAAK8AAACuAAAAvwAAAHgAAACvAAAAvwAAAK4A
AAAqAAAAvwAAACoAAAApAAAAvwAAACkAAABmAAAAwAAAAFsAAABeAAAAwAAAAF4AAADBAAAA
wAAAAMEAAADCAAAAwAAAAMIAAACqAAAAwwAAALgAAADCAAAAwwAAAGsAAABuAAAAwwAAAG4A
AAC5AAAAwwAAALkAAAC4AAAAwwAAAMIAAADBAAAAwwAAAMEAAABrAAAAxAAAAAAAAACzAAAA
xAAAALMAAACyAAAAxAAAALIAAABkAAAAxAAAAGQAAAApAAAAxAAAACkAAAABAAAAxAAAAAEA
AAAAAAAAxQAAAF4AAABdAAAAxQAAAC0AAAAsAAAAxgAAAGMAAADHAAAAxgAAAMcAAAB8AAAA
xgAAAHsAAADIAAAAxgAAAHwAAAB7AAAAyQAAAHAAAABvAAAAyQAAAKkAAACoAAAAyQAAAG8A
AACpAAAAyQAAAKgAAAC6AAAAygAAAK0AAACsAAAAygAAAKwAAABxAAAAygAAAHAAAAC9AAAA
ygAAAL0AAAC8AAAAygAAALwAAACtAAAAygAAAHEAAABwAAAAywAAAKMAAADMAAAAywAAAMwA
AABgAAAAywAAAMgAAACkAAAAywAAAKQAAACjAAAAzQAAAD0AAACfAAAAzQAAAJ8AAABVAAAA
zQAAAFUAAABUAAAAzQAAAFQAAAARAAAAzQAAAD4AAAA9AAAAzQAAABEAAAA+AAAAzgAAABQA
AACZAAAAzgAAAJkAAABzAAAAzgAAAEQAAABCAAAAzgAAABUAAAAUAAAAzgAAAEIAAAAVAAAA
zgAAAHMAAABEAAAAzwAAAFIAAAB9AAAAzwAAAH0AAAB/AAAAzwAAABoAAABQAAAAzwAAAFAA
AABSAAAAzwAAAH8AAAA2AAAAzwAAADYAAAAaAAAA0AAAABcAAACeAAAA0AAAAJ4AAACNAAAA
0AAAAI0AAABNAAAA0AAAAE0AAAADAAAA0AAAAAMAAAAGAAAA0AAAAAYAAAAXAAAA0QAAADwA
AACXAAAA0QAAAJcAAAA/AAAA0QAAAD8AAABBAAAA0QAAAA8AAAA5AAAA0QAAADkAAAA8AAAA
0QAAAEEAAAAPAAAA0gAAAFoAAAC1AAAA0gAAALUAAACmAAAA0gAAAKYAAAClAAAA0gAAAKUA
AAB1AAAA0gAAAHUAAAAxAAAA0gAAADEAAABaAAAA0wAAAHYAAAClAAAA0wAAAKUAAABhAAAA
0wAAAGEAAABgAAAA0wAAAGAAAADMAAAA0wAAAMwAAACgAAAA0wAAAKAAAAB2AAAA1AAAAFsA
AADAAAAA1AAAAMAAAACqAAAA1AAAAKoAAACnAAAA1AAAAKcAAAB+AAAA1AAAAFwAAABbAAAA
1AAAAH4AAABcAAAA1QAAAC0AAADFAAAA1QAAAMUAAABdAAAA1QAAAHIAAACwAAAA1QAAALAA
AAAtAAAA1QAAAEoAAAByAAAA1QAAAF0AAABKAAAA1gAAAG8AAABxAAAA1gAAAJgAAACWAAAA
1wAAAAoAAABaAAAA1wAAADEAAAAwAAAA1wAAAFoAAAAxAAAA1wAAADAAAACcAAAA2AAAAKEA
AACgAAAA2AAAAKAAAADMAAAA2AAAAMwAAACjAAAA2AAAAJoAAAChAAAA2QAAANoAAAC0AAAA
2QAAALQAAACzAAAA2QAAALMAAAAAAAAA2QAAAEYAAADaAAAA2wAAANwAAABFAAAA2wAAAG4A
AABtAAAA3QAAAJEAAACQAAAA3QAAALQAAADaAAAA3QAAAJAAAAC0AAAA3QAAANoAAADeAAAA
3QAAAN8AAACRAAAA3QAAAN4AAADfAAAA4AAAAHwAAADHAAAA4AAAAN8AAADeAAAA4AAAAMcA
AADfAAAA4AAAAN4AAADcAAAA4QAAABgAAABZAAAA4QAAAFkAAAAJAAAA4QAAAAgAAAAXAAAA
4QAAABcAAAAYAAAA4QAAAAkAAAAIAAAA4gAAAEkAAACIAAAA4gAAAIgAAABSAAAA4gAAAFEA
AABXAAAA4gAAAFcAAABJAAAA4gAAAFIAAABRAAAA4wAAAFUAAAChAAAA4wAAAKEAAACaAAAA
4wAAAJoAAAAUAAAA4wAAABQAAAAWAAAA4wAAABYAAABVAAAA5AAAADwAAAA7AAAA5AAAADsA
AAA3AAAA5AAAADcAAACWAAAA5AAAAJYAAACYAAAA5AAAAJgAAAA8AAAA5QAAADAAAABYAAAA
5QAAAFgAAABPAAAA5QAAAJwAAAAwAAAA5QAAAE4AAACcAAAA5QAAAE8AAABOAAAA5gAAAG8A
AADWAAAA5gAAANYAAACWAAAA5gAAAIkAAACpAAAA5gAAAJUAAACJAAAA5gAAAJYAAACVAAAA
5gAAAKkAAABvAAAA5wAAAJgAAADWAAAA5wAAANYAAABxAAAA5wAAAHEAAACsAAAA5wAAAJcA
AACYAAAA5wAAAI8AAACXAAAA5wAAAKwAAACPAAAA6AAAAEAAAACOAAAA6AAAAI4AAACvAAAA
6AAAAAcAAAAJAAAA6AAAAHgAAAAHAAAA6AAAAK8AAAB4AAAA6AAAAAkAAABAAAAA6QAAAJoA
AADYAAAA6QAAANgAAACjAAAA6QAAAKMAAACiAAAA6QAAAJkAAACaAAAA6QAAAHQAAACZAAAA
6QAAAKIAAAB0AAAA6gAAAAoAAADXAAAA6gAAANcAAACcAAAA6gAAAIoAAAALAAAA6gAAAJsA
AACKAAAA6gAAAJwAAACbAAAA6gAAAAsAAAAKAAAA6wAAAHkAAACMAAAA6wAAAIwAAACeAAAA
6wAAAJ4AAAAIAAAA6wAAAAgAAAAHAAAA6wAAAAcAAAB3AAAA6wAAAHcAAAB5AAAA7AAAAKYA
AAC2AAAA7AAAALYAAABiAAAA7AAAAGIAAABfAAAA7AAAAF8AAABhAAAA7AAAAGEAAACmAAAA
7QAAAMIAAAC4AAAA7QAAALgAAAC6AAAA7QAAALoAAACoAAAA7QAAAKgAAACqAAAA7QAAAKoA
AADCAAAA7gAAANwAAADeAAAA7gAAAN4AAADaAAAA7gAAAEYAAABFAAAA7gAAAEUAAADcAAAA
7gAAANoAAABGAAAA7wAAALwAAACAAAAA7wAAAIAAAAAqAAAA7wAAACoAAACuAAAA7wAAAK4A
AACtAAAA7wAAAK0AAAC8AAAA8AAAAEYAAADZAAAA8AAAANkAAAAAAAAA8AAAAEcAAABGAAAA
8AAAAIYAAABHAAAA8AAAAAIAAACGAAAA8AAAAAAAAAACAAAA8QAAAG4AAADbAAAA8QAAANsA
AABFAAAA8QAAAEUAAABHAAAA8QAAAEcAAACFAAAA8QAAAIUAAAC5AAAA8QAAALkAAABuAAAA
8gAAAHwAAADgAAAA8gAAAOAAAADcAAAA8gAAANwAAADbAAAA8gAAANsAAABtAAAA8gAAAG0A
AAB6AAAA8gAAAHoAAAB8AAAA8wAAALEAAABqAAAA8wAAALIAAACxAAAA9AAAAHsAAAB6AAAA
9AAAAHoAAABsAAAA9AAAAGwAAAAsAAAA9AAAACwAAAAuAAAA9QAAALIAAADzAAAA9QAAAPMA
AACUAAAA9QAAAJQAAACSAAAA9QAAAJIAAABlAAAA9QAAAGUAAABkAAAA9QAAAGQAAACyAAAA
9gAAAJQAAADzAAAA9gAAAPMAAABqAAAA9gAAAAwAAACTAAAA9gAAAJMAAACUAAAA9gAAAGcA
AAAMAAAA9gAAAGoAAABnAAAA9wAAAGIAAAC+AAAA9wAAAJEAAADfAAAA9wAAAL4AAACRAAAA
9wAAAN8AAADHAAAA9wAAAMcAAABjAAAA9wAAAGMAAABiAAAA+AAAAHsAAAD0AAAA+AAAAPQA
AAAuAAAA+AAAAC4AAAA6AAAA+AAAADoAAACkAAAA+AAAAMgAAAB7AAAA+AAAAKQAAADIAAAA
+QAAAHAAAADJAAAA+QAAAMkAAAC6AAAA+QAAALoAAAC3AAAA+QAAALcAAACHAAAA+QAAAL0A
AABwAAAA+QAAAIcAAAC9AAAA+gAAAF4AAADFAAAA+gAAAMUAAAAsAAAA+gAAACwAAABsAAAA
+gAAAGwAAABrAAAA+gAAAGsAAADBAAAA+gAAAMEAAABeAAAA+wAAAMgAAADLAAAA+wAAAGAA
AABfAAAA+wAAAMsAAABgAAAA+wAAAF8AAABjAAAA+wAAAGMAAADGAAAA+wAAAMYAAADIAAAA
</SharedString>
	</SharedStrings>
</roblox>